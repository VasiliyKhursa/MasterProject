
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000f0  00800200  000044e2  00004576  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000044e2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000003a6  008002f0  008002f0  00004666  2**0
                  ALLOC
  3 .stab         00001014  00000000  00000000  00004668  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000342  00000000  00000000  0000567c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000d10  00000000  00000000  000059be  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00001a54  00000000  00000000  000066ce  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000b9d0  00000000  00000000  00008122  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002fd0  00000000  00000000  00013af2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000c210  00000000  00000000  00016ac2  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001620  00000000  00000000  00022cd4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00002c65  00000000  00000000  000242f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000aeb7  00000000  00000000  00026f59  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00000d2d  00000000  00000000  00031e10  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000da8  00000000  00000000  00032b3d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	portSAVE_CONTEXT();
	vTaskSwitchContext();
	portRESTORE_CONTEXT();

	asm volatile ( "ret" );
}
       0:	0c 94 35 06 	jmp	0xc6a	; 0xc6a <__ctors_end>

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
}
       4:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
			| ((DWORD)/*rtc.month*/10 << 21)
			| ((DWORD)/*rtc.mday*/7 << 16)
			| ((DWORD)/*rtc.hour*/1 << 11)
			| ((DWORD)/*rtc.min*/26 << 5)
			| ((DWORD)/*rtc.sec*/6 >> 1);
}
       8:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
       c:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      10:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      14:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      18:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      1c:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      20:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      24:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      28:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      2c:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      30:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      34:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      38:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      3c:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      40:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      44:	0c 94 ba 0d 	jmp	0x1b74	; 0x1b74 <__vector_17>
      48:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      4c:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      50:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      54:	0c 94 b7 1b 	jmp	0x376e	; 0x376e <__vector_21>
      58:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      5c:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      60:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      64:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      68:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      6c:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      70:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      74:	0c 94 f7 1b 	jmp	0x37ee	; 0x37ee <__vector_29>
      78:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      7c:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      80:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      84:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      88:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      8c:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      90:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      94:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      98:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      9c:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      a0:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      a4:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      a8:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      ac:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      b0:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      b4:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      b8:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      bc:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      c0:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      c4:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      c8:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      cc:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      d0:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      d4:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      d8:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      dc:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>
      e0:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__bad_interrupt>

000000e4 <font6x8>:
	...
      ec:	00 5f 00 00 00 00 03 00 03 00 22 7f 22 22 7f 22     ._........".""."
      fc:	00 24 2a 6b 2a 12 00 23 13 08 64 62 00 3a 45 45     .$*k*..#..db.:EE
     10c:	3a 28 00 00 00 02 01 00 00 00 3e 41 00 00 00 00     :(........>A....
     11c:	41 3e 00 00 00 2a 1c 1c 2a 00 00 08 08 3e 08 08     A>...*..*....>..
     12c:	00 00 80 40 00 00 00 08 08 08 08 00 00 00 00 40     ...@...........@
     13c:	00 00 00 20 10 08 04 02 00 3e 51 49 45 3e 00 00     ... .....>QIE>..
     14c:	42 7f 40 00 00 62 51 51 51 4e 00 21 41 45 45 3b     B.@..bQQQN.!AEE;
     15c:	00 18 16 11 7f 10 00 27 45 45 45 39 00 3e 49 49     .......'EEE9.>II
     16c:	49 32 00 01 61 11 09 07 00 36 49 49 49 36 00 26     I2..a....6III6.&
     17c:	49 49 49 3e 00 00 00 12 00 00 00 00 20 12 00 00     III>........ ...
     18c:	00 08 14 22 41 00 00 14 14 14 14 14 00 41 22 14     ..."A........A".
     19c:	08 00 00 06 01 51 09 06 00 00 00 00 00 00 00 00     .....Q..........
     1ac:	00 5f 00 00 00 00 03 00 03 00 22 7f 22 22 7f 22     ._........".""."
     1bc:	00 24 2a 6b 2a 12 00 23 13 08 64 62 00 3a 45 45     .$*k*..#..db.:EE
     1cc:	3a 28 00 00 00 02 01 00 00 00 3e 41 00 00 00 00     :(........>A....
     1dc:	41 3e 00 00 00 2a 1c 1c 2a 00 00 08 08 3e 08 08     A>...*..*....>..
     1ec:	00 00 80 40 00 00 00 08 08 08 08 00 00 00 00 40     ...@...........@
     1fc:	00 00 00 20 10 08 04 02 00 3e 51 49 45 3e 00 00     ... .....>QIE>..
     20c:	42 7f 40 00 00 62 51 51 51 4e 00 21 41 45 45 3b     B.@..bQQQN.!AEE;
     21c:	00 18 16 11 7f 10 00 27 45 45 45 39 00 3e 49 49     .......'EEE9.>II
     22c:	49 32 00 01 61 11 09 07 00 36 49 49 49 36 00 26     I2..a....6III6.&
     23c:	49 49 49 3e 00 00 00 12 00 00 00 00 20 12 00 00     III>........ ...
     24c:	00 08 14 22 41 00 00 14 14 14 14 14 00 41 22 14     ..."A........A".
     25c:	08 00 00 06 01 51 09 06 00 3e 41 4d 4d 2e 00 78     .....Q...>AMM..x
     26c:	16 11 16 78 00 7f 49 49 49 36 00 3e 41 41 41 22     ...x..III6.>AAA"
     27c:	00 7f 41 41 41 3e 00 7f 49 49 49 41 00 7f 09 09     ..AAA>..IIIA....
     28c:	09 01 00 3e 41 41 51 32 00 7f 08 08 08 7f 00 00     ...>AAQ2........
     29c:	41 7f 41 00 00 30 40 41 41 3f 00 7f 08 08 14 63     A.A..0@AA?.....c
     2ac:	00 7f 40 40 40 60 00 7f 04 18 04 7f 00 7f 04 08     ..@@@`..........
     2bc:	10 7f 00 3e 41 41 41 3e 00 7f 09 09 09 06 00 3e     ...>AAA>.......>
     2cc:	41 61 21 5e 00 7f 09 09 19 66 00 26 49 49 49 32     Aa!^.....f.&III2
     2dc:	00 01 01 7f 01 01 00 3f 40 40 40 3f 00 07 18 60     .......?@@@?...`
     2ec:	18 07 00 1f 60 18 60 1f 00 63 14 08 14 63 00 03     ....`.`..c...c..
     2fc:	04 78 04 03 00 61 51 49 45 43 00 00 7f 41 00 00     .x...aQIEC...A..
     30c:	00 02 04 08 10 20 00 00 41 7f 00 00 00 00 00 00     ..... ..A.......
     31c:	00 00 40 40 40 40 40 40 00 00 00 01 02 00 00 20     ..@@@@@@....... 
     32c:	54 54 54 78 00 7e 48 48 48 30 00 38 44 44 44 28     TTTx.~HHH0.8DDD(
     33c:	00 30 48 48 48 7e 00 38 54 54 54 18 00 10 7c 12     .0HHH~.8TTT...|.
     34c:	02 04 00 0c 52 52 3c 02 00 7e 08 08 08 70 00 00     ....RR<..~...p..
     35c:	00 74 00 00 00 40 80 80 74 00 00 7e 10 10 10 6c     .t...@..t..~...l
     36c:	00 00 02 7e 00 00 00 7c 04 78 04 78 00 7c 04 04     ...~...|.x.x.|..
     37c:	04 78 00 38 44 44 44 38 00 fc 24 24 24 18 00 18     .x.8DDD8..$$$...
     38c:	24 24 24 fc 00 7c 08 04 04 08 00 48 54 54 54 20     $$$..|.....HTTT 
     39c:	00 08 3e 48 40 00 00 3c 40 40 40 3c 00 1c 20 40     ..>H@..<@@@<.. @
     3ac:	20 1c 00 3c 40 30 40 3c 00 44 28 10 28 44 00 1c      ..<@0@<.D(.(D..
     3bc:	20 a0 a0 7c 00 44 64 54 4c 44 00 08 36 41 00 00      ..|.DdTLD..6A..
     3cc:	00 00 00 7f 00 00 00 00 41 36 08 00 02 01 01 02     ........A6......
     3dc:	02 01 00 7f 7f 7f 7f 7f 00 00 00 00 00 00 00 00     ................
     3ec:	00 5f 00 00 00 00 03 00 03 00 22 7f 22 22 7f 22     ._........".""."
     3fc:	00 24 2a 6b 2a 12 00 23 13 08 64 62 00 3a 45 45     .$*k*..#..db.:EE
     40c:	3a 28 00 00 00 02 01 00 00 00 3e 41 00 00 00 00     :(........>A....
     41c:	41 3e 00 00 00 2a 1c 1c 2a 00 00 08 08 3e 08 08     A>...*..*....>..
     42c:	00 00 80 40 00 00 00 08 08 08 08 00 00 00 00 40     ...@...........@
     43c:	00 00 00 20 10 08 04 02 00 3e 51 49 45 3e 00 00     ... .....>QIE>..
     44c:	42 7f 40 00 00 62 51 51 51 4e 00 21 41 45 45 3b     B.@..bQQQN.!AEE;
     45c:	00 18 16 11 7f 10 00 27 45 45 45 39 00 3e 49 49     .......'EEE9.>II
     46c:	49 32 00 01 61 11 09 07 00 36 49 49 49 36 00 26     I2..a....6III6.&
     47c:	49 49 49 3e 00 00 00 12 00 00 00 00 20 12 00 00     III>........ ...
     48c:	00 08 14 22 41 00 00 14 14 14 14 14 00 41 22 14     ..."A........A".
     49c:	08 00 00 06 01 51 09 06 00 3e 41 4d 4d 2e 00 78     .....Q...>AMM..x
     4ac:	16 11 16 78 00 7f 49 49 49 36 00 3e 41 41 41 22     ...x..III6.>AAA"
     4bc:	00 7f 41 41 41 3e 00 7f 49 49 49 41 00 7f 09 09     ..AAA>..IIIA....
     4cc:	09 01 00 3e 41 41 51 32 00 7f 08 08 08 7f 00 00     ...>AAQ2........
     4dc:	41 7f 41 00 00 30 40 41 41 3f 00 7f 08 08 14 63     A.A..0@AA?.....c
     4ec:	00 7f 40 40 40 60 00 7f 04 18 04 7f 00 7f 04 08     ..@@@`..........
     4fc:	10 7f 00 3e 41 41 41 3e 00 7f 09 09 09 06 00 3e     ...>AAA>.......>
     50c:	41 61 21 5e 00 7f 09 09 19 66 00 26 49 49 49 32     Aa!^.....f.&III2
     51c:	00 01 01 7f 01 01 00 3f 40 40 40 3f 00 07 18 60     .......?@@@?...`
     52c:	18 07 00 1f 60 18 60 1f 00 63 14 08 14 63 00 03     ....`.`..c...c..
     53c:	04 78 04 03 00 61 51 49 45 43 00 00 7f 41 00 00     .x...aQIEC...A..
     54c:	00 02 04 08 10 20 00 00 41 7f 00 00 00 00 00 00     ..... ..A.......
     55c:	00 00 40 40 40 40 40 40 00 78 16 11 16 78 00 20     ..@@@@@@.x...x. 
     56c:	54 54 54 78 00 7f 49 49 49 36 00 38 44 44 44 28     TTTx..III6.8DDD(
     57c:	00 30 48 48 48 7e 00 7f 49 49 49 41 00 10 7c 12     .0HHH~..IIIA..|.
     58c:	02 04 00 0c 52 52 3c 02 00 7e 08 08 08 70 00 00     ....RR<..~...p..
     59c:	00 74 00 00 00 7f 08 08 14 63 00 7f 08 08 14 63     .t.......c.....c
     5ac:	00 00 02 7e 00 00 00 7c 04 78 04 78 00 7c 04 04     ...~...|.x.x.|..
     5bc:	04 78 00 38 44 44 44 38 00 fc 24 24 24 18 00 18     .x.8DDD8..$$$...
     5cc:	24 24 24 fc 00 7c 08 04 04 08 00 48 54 54 54 20     $$$..|.....HTTT 
     5dc:	00 08 3e 48 40 00 00 3c 40 40 40 3c 00 1c 20 40     ..>H@..<@@@<.. @
     5ec:	20 1c 00 3c 40 30 40 3c 00 44 28 10 28 44 00 1c      ..<@0@<.D(.(D..
     5fc:	20 a0 a0 7c 00 44 64 54 4c 44 00 08 36 41 00 00      ..|.DdTLD..6A..
     60c:	00 00 00 7f 00 00 00 00 41 36 08 00 02 01 01 02     ........A6......
     61c:	02 01 00 7f 7f 7f 7f 7f 00 20 54 54 54 78 00 20     ......... TTTx. 
     62c:	54 54 54 78 00 7e 48 48 48 30 00 38 44 44 44 28     TTTx.~HHH0.8DDD(
     63c:	00 0c 52 52 3c 02 00 0c 52 52 3c 02 00 10 7c 12     ..RR<...RR<...|.
     64c:	02 04 00 0c 52 52 3c 02 00 7e 08 08 08 70 00 00     ....RR<..~...p..
     65c:	00 74 00 00 00 40 80 80 74 00 00 7e 10 10 10 6c     .t...@..t..~...l
     66c:	00 00 02 7e 00 00 00 38 44 44 44 38 00 38 44 44     ...~...8DDD8.8DD
     67c:	44 38 00 38 44 44 44 38 00 fc 24 24 24 18 00 fc     D8.8DDD8..$$$...
     68c:	24 24 24 18 00 7c 08 04 04 08 00 48 54 54 54 20     $$$..|.....HTTT 
     69c:	00 08 3e 48 40 00 00 3c 40 40 40 3c 00 1c 20 40     ..>H@..<@@@<.. @
     6ac:	20 1c 00 3c 40 30 40 3c 00 44 28 10 28 44 00 1c      ..<@0@<.D(.(D..
     6bc:	20 a0 a0 7c 00 44 64 54 4c 44 00 08 36 41 00 00      ..|.DdTLD..6A..
     6cc:	00 00 00 7f 00 00 00 00 41 36 08 00 02 01 01 02     ........A6......
     6dc:	02 01 00 7f 7f 7f 7f 7f                             ........

000006e4 <font8x14>:
	...
     6f4:	00 18 3c 3c 3c 18 18 00 18 18 00 00 00 66 66 66     ..<<<........fff
     704:	24 00 00 00 00 00 00 00 00 00 00 00 00 6c 6c fe     $............ll.
     714:	6c 6c 6c fe 6c 6c 00 00 00 18 18 7c c6 c2 c0 7c     lll.ll.....|...|
     724:	06 86 c6 7c 18 18 00 00 00 00 00 c2 c6 0c 18 30     ...|...........0
     734:	66 c6 00 00 00 00 00 38 6c 6c 38 76 dc cc cc 76     f......8ll8v...v
     744:	00 00 00 18 18 18 30 00 00 00 00 00 00 00 00 00     ......0.........
     754:	00 00 00 0c 18 30 30 30 30 30 18 0c 00 00 00 00     .....00000......
     764:	00 30 18 0c 0c 0c 0c 0c 18 30 00 00 00 00 00 00     .0.......0......
     774:	00 66 3c ff 3c 66 00 00 00 00 00 00 00 00 00 18     .f<.<f..........
     784:	18 7e 18 18 00 00 00 00 00 00 00 00 00 00 00 00     .~..............
     794:	00 18 18 18 30 00 00 00 00 00 00 00 00 fe 00 00     ....0...........
	...
     7b0:	00 00 18 18 00 00 00 00 00 02 06 0c 18 30 60 c0     .............0`.
     7c0:	80 00 00 00 00 00 00 38 6c c6 c6 d6 c6 c6 6c 38     .......8l.....l8
     7d0:	00 00 00 00 00 18 38 78 18 18 18 18 18 7e 00 00     ......8x.....~..
     7e0:	00 00 00 7c c6 06 0c 18 30 60 c6 fe 00 00 00 00     ...|....0`......
     7f0:	00 7c c6 06 06 3c 06 06 c6 7c 00 00 00 00 00 0c     .|...<...|......
     800:	1c 3c 6c cc fe 0c 0c 1e 00 00 00 00 00 fe c0 c0     .<l.............
     810:	c0 fc 06 06 c6 7c 00 00 00 00 00 38 60 c0 c0 fc     .....|.....8`...
     820:	c6 c6 c6 7c 00 00 00 00 00 fe c6 06 0c 18 30 30     ...|..........00
     830:	30 30 00 00 00 00 00 7c c6 c6 c6 7c c6 c6 c6 7c     00.....|...|...|
     840:	00 00 00 00 00 7c c6 c6 c6 7e 06 06 0c 78 00 00     .....|...~...x..
     850:	00 00 00 00 18 18 00 00 00 18 18 00 00 00 00 00     ................
     860:	00 00 18 18 00 00 00 18 18 30 00 00 00 00 00 0c     .........0......
     870:	18 30 60 c0 60 30 18 0c 00 00 00 00 00 00 00 00     .0`.`0..........
     880:	7e 00 00 7e 00 00 00 00 00 00 00 60 30 18 0c 06     ~..~.......`0...
     890:	0c 18 30 60 00 00 00 00 00 7c c6 c6 0c 18 18 00     ..0`.....|......
     8a0:	18 18 00 00 00 00 00 7c c6 c6 de de de dc c0 7c     .......|.......|
     8b0:	00 00 00 00 00 10 38 6c c6 c6 fe c6 c6 c6 00 00     ......8l........
     8c0:	00 00 00 fc 66 66 66 7c 66 66 66 fc 00 00 00 00     ....fff|fff.....
     8d0:	00 3c 66 c2 c0 c0 c0 c2 66 3c 00 00 00 00 00 f8     .<f.....f<......
     8e0:	6c 66 66 66 66 66 6c f8 00 00 00 00 00 fe 66 62     lfffffl.......fb
     8f0:	68 78 68 62 66 fe 00 00 00 00 00 fe 66 62 68 78     hxhbf.......fbhx
     900:	68 60 60 f0 00 00 00 00 00 3c 66 c2 c0 c0 de c6     h``......<f.....
     910:	66 3a 00 00 00 00 00 c6 c6 c6 c6 fe c6 c6 c6 c6     f:..............
     920:	00 00 00 00 00 3c 18 18 18 18 18 18 18 3c 00 00     .....<.......<..
     930:	00 00 00 1e 0c 0c 0c 0c 0c cc cc 78 00 00 00 00     ...........x....
     940:	00 e6 66 6c 6c 78 6c 6c 66 e6 00 00 00 00 00 f0     ..fllxllf.......
     950:	60 60 60 60 60 62 66 fe 00 00 00 00 00 c6 ee fe     `````bf.........
     960:	d6 c6 c6 c6 c6 c6 00 00 00 00 00 c6 e6 f6 fe de     ................
     970:	ce c6 c6 c6 00 00 00 00 00 7c c6 c6 c6 c6 c6 c6     .........|......
     980:	c6 7c 00 00 00 00 00 fc 66 66 66 7c 60 60 60 f0     .|......fff|```.
     990:	00 00 00 00 00 7c c6 c6 c6 c6 c6 d6 de 7c 0e 00     .....|.......|..
     9a0:	00 00 00 fc 66 66 66 7c 6c 66 66 e6 00 00 00 00     ....fff|lff.....
     9b0:	00 7c c6 c6 60 38 0c c6 c6 7c 00 00 00 00 00 7e     .|..`8...|.....~
     9c0:	7e 5a 18 18 18 18 18 3c 00 00 00 00 00 c6 c6 c6     ~Z.....<........
     9d0:	c6 c6 c6 c6 c6 7c 00 00 00 00 00 c6 c6 c6 c6 c6     .....|..........
     9e0:	c6 6c 38 10 00 00 00 00 00 c6 c6 c6 c6 d6 d6 fe     .l8.............
     9f0:	6c 6c 00 00 00 00 00 c6 c6 c6 7c 38 7c c6 c6 c6     ll........|8|...
     a00:	00 00 00 00 00 66 66 66 66 3c 18 18 18 3c 00 00     .....ffff<...<..
     a10:	00 00 00 fe c6 8c 18 30 60 c2 c6 fe 00 00 00 00     .......0`.......
     a20:	00 3c 30 30 30 30 30 30 30 3c 00 00 00 00 00 80     .<0000000<......
     a30:	c0 e0 70 38 1c 0e 06 02 00 00 00 00 00 3c 0c 0c     ..p8.........<..
     a40:	0c 0c 0c 0c 0c 3c 00 00 10 38 6c c6 00 00 00 00     .....<...8l.....
	...
     a60:	00 00 00 ff 00 30 18 0c 00 00 00 00 00 00 00 00     .....0..........
	...
     a78:	78 0c 7c cc cc 76 00 00 00 00 00 e0 60 60 78 6c     x.|..v......``xl
     a88:	66 66 66 7c 00 00 00 00 00 00 00 00 7c c6 c0 c0     fff|........|...
     a98:	c6 7c 00 00 00 00 00 1c 0c 0c 3c 6c cc cc cc 76     .|........<l...v
	...
     ab0:	7c c6 fe c0 c6 7c 00 00 00 00 00 1c 36 32 30 7c     |....|......620|
     ac0:	30 30 30 78 00 00 00 00 00 00 00 00 76 cc cc cc     000x........v...
     ad0:	7c 0c cc 78 00 00 00 e0 60 60 6c 76 66 66 66 e6     |..x....``lvfff.
     ae0:	00 00 00 00 00 18 18 00 38 18 18 18 18 3c 00 00     ........8....<..
     af0:	00 00 00 06 06 00 0e 06 06 06 06 66 66 3c 00 00     ...........ff<..
     b00:	00 e0 60 60 66 6c 78 6c 66 e6 00 00 00 00 00 38     ..``flxlf......8
     b10:	18 18 18 18 18 18 18 3c 00 00 00 00 00 00 00 00     .......<........
     b20:	ec fe d6 d6 d6 d6 00 00 00 00 00 00 00 00 dc 66     ...............f
     b30:	66 66 66 66 00 00 00 00 00 00 00 00 7c c6 c6 c6     ffff........|...
     b40:	c6 7c 00 00 00 00 00 00 00 00 dc 66 66 66 7c 60     .|.........fff|`
     b50:	60 f0 00 00 00 00 00 00 76 cc cc cc 7c 0c 0c 1e     `.......v...|...
     b60:	00 00 00 00 00 00 dc 76 66 60 60 f0 00 00 00 00     .......vf``.....
     b70:	00 00 00 00 7c c6 70 1c c6 7c 00 00 00 00 00 10     ....|.p..|......
     b80:	30 30 fc 30 30 30 36 1c 00 00 00 00 00 00 00 00     00.0006.........
     b90:	cc cc cc cc cc 76 00 00 00 00 00 00 00 00 c6 c6     .....v..........
     ba0:	c6 6c 38 10 00 00 00 00 00 00 00 00 c6 c6 d6 d6     .l8.............
     bb0:	fe 6c 00 00 00 00 00 00 00 00 c6 6c 38 38 6c c6     .l.........l88l.
	...
     bc8:	c6 c6 c6 c6 7e 06 0c 78 00 00 00 00 00 00 fe cc     ....~..x........
     bd8:	18 30 66 fe 00 00 00 00 00 0e 18 18 18 70 18 18     .0f..........p..
     be8:	18 0e 00 00 00 00 00 18 18 18 18 18 18 18 18 18     ................
     bf8:	00 00 00 00 00 70 18 18 18 0e 18 18 18 70 00 00     .....p.......p..
     c08:	00 76 dc 00 00 00 00 00 00 00 00 00 00 00 00 00     .v..............
     c18:	00 00 00 10 38 6c c6 c6 fe 00 00 00                 ....8l......

00000c24 <init_array_0>:
     c24:	fd fd fd fd ef 00 ee 04 1b 04 fe fe fe fe ef 90     ................
     c34:	4a 04 7f 3f ee 04 43 06                             J..?..C.

00000c3c <init_array_1>:
     c3c:	ef 90 09 83 08 00 0b af 0a 00 05 00 06 00 07 00     ................
     c4c:	ef 00 ee 0c ef 90 00 80 ef b0 49 02 ef 00 7f 01     ..........I.....
     c5c:	e1 81 e2 02 e2 76 e1 83 80 01 ef 90 00 00           .....v........

00000c6a <__ctors_end>:
     c6a:	11 24       	eor	r1, r1
     c6c:	1f be       	out	0x3f, r1	; 63
     c6e:	cf ef       	ldi	r28, 0xFF	; 255
     c70:	d1 e2       	ldi	r29, 0x21	; 33
     c72:	de bf       	out	0x3e, r29	; 62
     c74:	cd bf       	out	0x3d, r28	; 61
     c76:	00 e0       	ldi	r16, 0x00	; 0
     c78:	0c bf       	out	0x3c, r16	; 60

00000c7a <__do_copy_data>:
     c7a:	12 e0       	ldi	r17, 0x02	; 2
     c7c:	a0 e0       	ldi	r26, 0x00	; 0
     c7e:	b2 e0       	ldi	r27, 0x02	; 2
     c80:	e2 ee       	ldi	r30, 0xE2	; 226
     c82:	f4 e4       	ldi	r31, 0x44	; 68
     c84:	02 c0       	rjmp	.+4      	; 0xc8a <.do_copy_data_start>

00000c86 <.do_copy_data_loop>:
     c86:	05 90       	lpm	r0, Z+
     c88:	0d 92       	st	X+, r0

00000c8a <.do_copy_data_start>:
     c8a:	a0 3f       	cpi	r26, 0xF0	; 240
     c8c:	b1 07       	cpc	r27, r17
     c8e:	d9 f7       	brne	.-10     	; 0xc86 <.do_copy_data_loop>

00000c90 <__do_clear_bss>:
     c90:	16 e0       	ldi	r17, 0x06	; 6
     c92:	a0 ef       	ldi	r26, 0xF0	; 240
     c94:	b2 e0       	ldi	r27, 0x02	; 2
     c96:	01 c0       	rjmp	.+2      	; 0xc9a <.do_clear_bss_start>

00000c98 <.do_clear_bss_loop>:
     c98:	1d 92       	st	X+, r1

00000c9a <.do_clear_bss_start>:
     c9a:	a6 39       	cpi	r26, 0x96	; 150
     c9c:	b1 07       	cpc	r27, r17
     c9e:	e1 f7       	brne	.-8      	; 0xc98 <.do_clear_bss_loop>
     ca0:	0e 94 35 1d 	call	0x3a6a	; 0x3a6a <main>
     ca4:	0c 94 70 22 	jmp	0x44e0	; 0x44e0 <_exit>

00000ca8 <__bad_interrupt>:
     ca8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000cac <enc28j60_rxtx>:
#define enc28j60_select() ENC28J60_SPI_PORT &= ~ENC28J60_SPI_CS
#define enc28j60_release() ENC28J60_SPI_PORT |= ENC28J60_SPI_CS

uint8_t enc28j60_rxtx(uint8_t data)
{
	SPDR = data;
     cac:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)))
     cae:	0d b4       	in	r0, 0x2d	; 45
     cb0:	07 fe       	sbrs	r0, 7
     cb2:	fd cf       	rjmp	.-6      	; 0xcae <enc28j60_rxtx+0x2>
		;
	return SPDR;
     cb4:	8e b5       	in	r24, 0x2e	; 46
}
     cb6:	08 95       	ret

00000cb8 <enc28j60_read_op>:
#define enc28j60_rx() enc28j60_rxtx(0xff)
#define enc28j60_tx(data) enc28j60_rxtx(data)

// Generic SPI read command
uint8_t enc28j60_read_op(uint8_t cmd, uint8_t adr)
{
     cb8:	df 93       	push	r29
     cba:	cf 93       	push	r28
     cbc:	0f 92       	push	r0
     cbe:	cd b7       	in	r28, 0x3d	; 61
     cc0:	de b7       	in	r29, 0x3e	; 62
	uint8_t data;

	enc28j60_select();
     cc2:	2c 98       	cbi	0x05, 4	; 5
	enc28j60_tx(cmd | (adr & ENC28J60_ADDR_MASK));
     cc4:	96 2f       	mov	r25, r22
     cc6:	9f 71       	andi	r25, 0x1F	; 31
     cc8:	89 2b       	or	r24, r25
     cca:	69 83       	std	Y+1, r22	; 0x01
     ccc:	0e 94 56 06 	call	0xcac	; 0xcac <enc28j60_rxtx>
	if(adr & 0x80) // throw out dummy byte 
     cd0:	69 81       	ldd	r22, Y+1	; 0x01
     cd2:	67 ff       	sbrs	r22, 7
     cd4:	03 c0       	rjmp	.+6      	; 0xcdc <enc28j60_read_op+0x24>
		enc28j60_rx(); // when reading MII/MAC register
     cd6:	8f ef       	ldi	r24, 0xFF	; 255
     cd8:	0e 94 56 06 	call	0xcac	; 0xcac <enc28j60_rxtx>
	data = enc28j60_rx();
     cdc:	8f ef       	ldi	r24, 0xFF	; 255
     cde:	0e 94 56 06 	call	0xcac	; 0xcac <enc28j60_rxtx>
	enc28j60_release();
     ce2:	2c 9a       	sbi	0x05, 4	; 5
	return data;
}
     ce4:	0f 90       	pop	r0
     ce6:	cf 91       	pop	r28
     ce8:	df 91       	pop	r29
     cea:	08 95       	ret

00000cec <enc28j60_write_op>:

// Generic SPI write command
void enc28j60_write_op(uint8_t cmd, uint8_t adr, uint8_t data)
{
     cec:	df 93       	push	r29
     cee:	cf 93       	push	r28
     cf0:	0f 92       	push	r0
     cf2:	cd b7       	in	r28, 0x3d	; 61
     cf4:	de b7       	in	r29, 0x3e	; 62
	enc28j60_select();
     cf6:	2c 98       	cbi	0x05, 4	; 5
	enc28j60_tx(cmd | (adr & ENC28J60_ADDR_MASK));
     cf8:	6f 71       	andi	r22, 0x1F	; 31
     cfa:	86 2b       	or	r24, r22
     cfc:	49 83       	std	Y+1, r20	; 0x01
     cfe:	0e 94 56 06 	call	0xcac	; 0xcac <enc28j60_rxtx>
	enc28j60_tx(data);
     d02:	49 81       	ldd	r20, Y+1	; 0x01
     d04:	84 2f       	mov	r24, r20
     d06:	0e 94 56 06 	call	0xcac	; 0xcac <enc28j60_rxtx>
	enc28j60_release();
     d0a:	2c 9a       	sbi	0x05, 4	; 5
}
     d0c:	0f 90       	pop	r0
     d0e:	cf 91       	pop	r28
     d10:	df 91       	pop	r29
     d12:	08 95       	ret

00000d14 <enc28j60_soft_reset>:

// Initiate software reset
void enc28j60_soft_reset()
{
	enc28j60_select();
     d14:	2c 98       	cbi	0x05, 4	; 5
	enc28j60_tx(ENC28J60_SPI_SC);
     d16:	8f ef       	ldi	r24, 0xFF	; 255
     d18:	0e 94 56 06 	call	0xcac	; 0xcac <enc28j60_rxtx>
	enc28j60_release();
     d1c:	2c 9a       	sbi	0x05, 4	; 5
	
	enc28j60_current_bank = 0;
     d1e:	10 92 f0 02 	sts	0x02F0, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     d22:	87 eb       	ldi	r24, 0xB7	; 183
     d24:	9b e0       	ldi	r25, 0x0B	; 11
     d26:	01 97       	sbiw	r24, 0x01	; 1
     d28:	f1 f7       	brne	.-4      	; 0xd26 <enc28j60_soft_reset+0x12>
     d2a:	00 c0       	rjmp	.+0      	; 0xd2c <enc28j60_soft_reset+0x18>
     d2c:	00 00       	nop
	_delay_ms(1); // Wait until device initializes
}
     d2e:	08 95       	ret

00000d30 <enc28j60_set_bank>:
 * Memory access
 */

// Set register bank
void enc28j60_set_bank(uint8_t adr)
{
     d30:	1f 93       	push	r17
	uint8_t bank;

	if( (adr & ENC28J60_ADDR_MASK) < ENC28J60_COMMON_CR )
     d32:	28 2f       	mov	r18, r24
     d34:	30 e0       	ldi	r19, 0x00	; 0
     d36:	2f 71       	andi	r18, 0x1F	; 31
     d38:	30 70       	andi	r19, 0x00	; 0
     d3a:	2b 31       	cpi	r18, 0x1B	; 27
     d3c:	31 05       	cpc	r19, r1
     d3e:	a4 f4       	brge	.+40     	; 0xd68 <enc28j60_set_bank+0x38>
	{
		bank = (adr >> 5) & 0x03; //BSEL1|BSEL0=0x03
     d40:	18 2f       	mov	r17, r24
     d42:	12 95       	swap	r17
     d44:	16 95       	lsr	r17
     d46:	13 70       	andi	r17, 0x03	; 3
		if(bank != enc28j60_current_bank)
     d48:	80 91 f0 02 	lds	r24, 0x02F0
     d4c:	18 17       	cp	r17, r24
     d4e:	61 f0       	breq	.+24     	; 0xd68 <enc28j60_set_bank+0x38>
		{
			enc28j60_write_op(ENC28J60_SPI_BFC, ECON1, 0x03);
     d50:	80 ea       	ldi	r24, 0xA0	; 160
     d52:	6f e1       	ldi	r22, 0x1F	; 31
     d54:	43 e0       	ldi	r20, 0x03	; 3
     d56:	0e 94 76 06 	call	0xcec	; 0xcec <enc28j60_write_op>
			enc28j60_write_op(ENC28J60_SPI_BFS, ECON1, bank);
     d5a:	80 e8       	ldi	r24, 0x80	; 128
     d5c:	6f e1       	ldi	r22, 0x1F	; 31
     d5e:	41 2f       	mov	r20, r17
     d60:	0e 94 76 06 	call	0xcec	; 0xcec <enc28j60_write_op>
			enc28j60_current_bank = bank;
     d64:	10 93 f0 02 	sts	0x02F0, r17
		}
	}
}
     d68:	1f 91       	pop	r17
     d6a:	08 95       	ret

00000d6c <enc28j60_rcr>:

// Read register
uint8_t enc28j60_rcr(uint8_t adr)
{
     d6c:	df 93       	push	r29
     d6e:	cf 93       	push	r28
     d70:	0f 92       	push	r0
     d72:	cd b7       	in	r28, 0x3d	; 61
     d74:	de b7       	in	r29, 0x3e	; 62
     d76:	68 2f       	mov	r22, r24
	enc28j60_set_bank(adr);
     d78:	69 83       	std	Y+1, r22	; 0x01
     d7a:	0e 94 98 06 	call	0xd30	; 0xd30 <enc28j60_set_bank>
	return enc28j60_read_op(ENC28J60_SPI_RCR, adr);
     d7e:	80 e0       	ldi	r24, 0x00	; 0
     d80:	69 81       	ldd	r22, Y+1	; 0x01
     d82:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <enc28j60_read_op>
}
     d86:	0f 90       	pop	r0
     d88:	cf 91       	pop	r28
     d8a:	df 91       	pop	r29
     d8c:	08 95       	ret

00000d8e <enc28j60_wcr>:
		(enc28j60_read_op(ENC28J60_SPI_RCR, adr+1) << 8);
}

// Write register
void enc28j60_wcr(uint8_t adr, uint8_t arg)
{
     d8e:	1f 93       	push	r17
     d90:	df 93       	push	r29
     d92:	cf 93       	push	r28
     d94:	0f 92       	push	r0
     d96:	cd b7       	in	r28, 0x3d	; 61
     d98:	de b7       	in	r29, 0x3e	; 62
     d9a:	18 2f       	mov	r17, r24
	enc28j60_set_bank(adr);
     d9c:	69 83       	std	Y+1, r22	; 0x01
     d9e:	0e 94 98 06 	call	0xd30	; 0xd30 <enc28j60_set_bank>
	enc28j60_write_op(ENC28J60_SPI_WCR, adr, arg);
     da2:	80 e4       	ldi	r24, 0x40	; 64
     da4:	61 2f       	mov	r22, r17
     da6:	49 81       	ldd	r20, Y+1	; 0x01
     da8:	0e 94 76 06 	call	0xcec	; 0xcec <enc28j60_write_op>
}
     dac:	0f 90       	pop	r0
     dae:	cf 91       	pop	r28
     db0:	df 91       	pop	r29
     db2:	1f 91       	pop	r17
     db4:	08 95       	ret

00000db6 <enc28j60_wcr16>:

// Write register pair
void enc28j60_wcr16(uint8_t adr, uint16_t arg)
{
     db6:	1f 93       	push	r17
     db8:	df 93       	push	r29
     dba:	cf 93       	push	r28
     dbc:	0f 92       	push	r0
     dbe:	0f 92       	push	r0
     dc0:	cd b7       	in	r28, 0x3d	; 61
     dc2:	de b7       	in	r29, 0x3e	; 62
     dc4:	18 2f       	mov	r17, r24
	enc28j60_set_bank(adr);
     dc6:	69 83       	std	Y+1, r22	; 0x01
     dc8:	7a 83       	std	Y+2, r23	; 0x02
     dca:	0e 94 98 06 	call	0xd30	; 0xd30 <enc28j60_set_bank>
	enc28j60_write_op(ENC28J60_SPI_WCR, adr, arg);
     dce:	80 e4       	ldi	r24, 0x40	; 64
     dd0:	61 2f       	mov	r22, r17
     dd2:	49 81       	ldd	r20, Y+1	; 0x01
     dd4:	0e 94 76 06 	call	0xcec	; 0xcec <enc28j60_write_op>
	enc28j60_write_op(ENC28J60_SPI_WCR, adr+1, arg>>8);
     dd8:	61 2f       	mov	r22, r17
     dda:	6f 5f       	subi	r22, 0xFF	; 255
     ddc:	80 e4       	ldi	r24, 0x40	; 64
     dde:	7a 81       	ldd	r23, Y+2	; 0x02
     de0:	47 2f       	mov	r20, r23
     de2:	0e 94 76 06 	call	0xcec	; 0xcec <enc28j60_write_op>
}
     de6:	0f 90       	pop	r0
     de8:	0f 90       	pop	r0
     dea:	cf 91       	pop	r28
     dec:	df 91       	pop	r29
     dee:	1f 91       	pop	r17
     df0:	08 95       	ret

00000df2 <enc28j60_bfc>:

// Clear bits in register (reg &= ~mask)
void enc28j60_bfc(uint8_t adr, uint8_t mask)
{
     df2:	1f 93       	push	r17
     df4:	df 93       	push	r29
     df6:	cf 93       	push	r28
     df8:	0f 92       	push	r0
     dfa:	cd b7       	in	r28, 0x3d	; 61
     dfc:	de b7       	in	r29, 0x3e	; 62
     dfe:	18 2f       	mov	r17, r24
	enc28j60_set_bank(adr);
     e00:	69 83       	std	Y+1, r22	; 0x01
     e02:	0e 94 98 06 	call	0xd30	; 0xd30 <enc28j60_set_bank>
	enc28j60_write_op(ENC28J60_SPI_BFC, adr, mask);
     e06:	80 ea       	ldi	r24, 0xA0	; 160
     e08:	61 2f       	mov	r22, r17
     e0a:	49 81       	ldd	r20, Y+1	; 0x01
     e0c:	0e 94 76 06 	call	0xcec	; 0xcec <enc28j60_write_op>
}
     e10:	0f 90       	pop	r0
     e12:	cf 91       	pop	r28
     e14:	df 91       	pop	r29
     e16:	1f 91       	pop	r17
     e18:	08 95       	ret

00000e1a <enc28j60_bfs>:

// Set bits in register (reg |= mask)
void enc28j60_bfs(uint8_t adr, uint8_t mask)
{
     e1a:	1f 93       	push	r17
     e1c:	df 93       	push	r29
     e1e:	cf 93       	push	r28
     e20:	0f 92       	push	r0
     e22:	cd b7       	in	r28, 0x3d	; 61
     e24:	de b7       	in	r29, 0x3e	; 62
     e26:	18 2f       	mov	r17, r24
	enc28j60_set_bank(adr);
     e28:	69 83       	std	Y+1, r22	; 0x01
     e2a:	0e 94 98 06 	call	0xd30	; 0xd30 <enc28j60_set_bank>
	enc28j60_write_op(ENC28J60_SPI_BFS, adr, mask);
     e2e:	80 e8       	ldi	r24, 0x80	; 128
     e30:	61 2f       	mov	r22, r17
     e32:	49 81       	ldd	r20, Y+1	; 0x01
     e34:	0e 94 76 06 	call	0xcec	; 0xcec <enc28j60_write_op>
}
     e38:	0f 90       	pop	r0
     e3a:	cf 91       	pop	r28
     e3c:	df 91       	pop	r29
     e3e:	1f 91       	pop	r17
     e40:	08 95       	ret

00000e42 <enc28j60_read_buffer>:

// Read Rx/Tx buffer (at ERDPT)
void enc28j60_read_buffer(uint8_t *buf, uint16_t len)
{
     e42:	0f 93       	push	r16
     e44:	1f 93       	push	r17
     e46:	cf 93       	push	r28
     e48:	df 93       	push	r29
     e4a:	ec 01       	movw	r28, r24
     e4c:	8b 01       	movw	r16, r22
	enc28j60_select();
     e4e:	2c 98       	cbi	0x05, 4	; 5
	enc28j60_tx(ENC28J60_SPI_RBM);
     e50:	8a e3       	ldi	r24, 0x3A	; 58
     e52:	0e 94 56 06 	call	0xcac	; 0xcac <enc28j60_rxtx>
	while(len--)
     e56:	06 c0       	rjmp	.+12     	; 0xe64 <enc28j60_read_buffer+0x22>
		*(buf++) = enc28j60_rx();
     e58:	8f ef       	ldi	r24, 0xFF	; 255
     e5a:	0e 94 56 06 	call	0xcac	; 0xcac <enc28j60_rxtx>
     e5e:	89 93       	st	Y+, r24
     e60:	01 50       	subi	r16, 0x01	; 1
     e62:	10 40       	sbci	r17, 0x00	; 0
// Read Rx/Tx buffer (at ERDPT)
void enc28j60_read_buffer(uint8_t *buf, uint16_t len)
{
	enc28j60_select();
	enc28j60_tx(ENC28J60_SPI_RBM);
	while(len--)
     e64:	01 15       	cp	r16, r1
     e66:	11 05       	cpc	r17, r1
     e68:	b9 f7       	brne	.-18     	; 0xe58 <enc28j60_read_buffer+0x16>
		*(buf++) = enc28j60_rx();
	enc28j60_release();
     e6a:	2c 9a       	sbi	0x05, 4	; 5
}
     e6c:	df 91       	pop	r29
     e6e:	cf 91       	pop	r28
     e70:	1f 91       	pop	r17
     e72:	0f 91       	pop	r16
     e74:	08 95       	ret

00000e76 <enc28j60_write_buffer>:

// Write Rx/Tx buffer (at EWRPT)
void enc28j60_write_buffer(uint8_t *buf, uint16_t len)
{
     e76:	0f 93       	push	r16
     e78:	1f 93       	push	r17
     e7a:	cf 93       	push	r28
     e7c:	df 93       	push	r29
     e7e:	ec 01       	movw	r28, r24
     e80:	8b 01       	movw	r16, r22
	enc28j60_select();
     e82:	2c 98       	cbi	0x05, 4	; 5
	enc28j60_tx(ENC28J60_SPI_WBM);
     e84:	8a e7       	ldi	r24, 0x7A	; 122
     e86:	0e 94 56 06 	call	0xcac	; 0xcac <enc28j60_rxtx>
	while(len--)
     e8a:	05 c0       	rjmp	.+10     	; 0xe96 <enc28j60_write_buffer+0x20>
		enc28j60_tx(*(buf++));
     e8c:	89 91       	ld	r24, Y+
     e8e:	0e 94 56 06 	call	0xcac	; 0xcac <enc28j60_rxtx>
     e92:	01 50       	subi	r16, 0x01	; 1
     e94:	10 40       	sbci	r17, 0x00	; 0
// Write Rx/Tx buffer (at EWRPT)
void enc28j60_write_buffer(uint8_t *buf, uint16_t len)
{
	enc28j60_select();
	enc28j60_tx(ENC28J60_SPI_WBM);
	while(len--)
     e96:	01 15       	cp	r16, r1
     e98:	11 05       	cpc	r17, r1
     e9a:	c1 f7       	brne	.-16     	; 0xe8c <enc28j60_write_buffer+0x16>
		enc28j60_tx(*(buf++));
	enc28j60_release();
     e9c:	2c 9a       	sbi	0x05, 4	; 5
}
     e9e:	df 91       	pop	r29
     ea0:	cf 91       	pop	r28
     ea2:	1f 91       	pop	r17
     ea4:	0f 91       	pop	r16
     ea6:	08 95       	ret

00000ea8 <enc28j60_write_phy>:
	return enc28j60_rcr16(MIRD);
}

// Write PHY register
void enc28j60_write_phy(uint8_t adr, uint16_t data)
{
     ea8:	cf 93       	push	r28
     eaa:	df 93       	push	r29
     eac:	98 2f       	mov	r25, r24
     eae:	eb 01       	movw	r28, r22
	enc28j60_wcr(MIREGADR, adr);
     eb0:	84 ed       	ldi	r24, 0xD4	; 212
     eb2:	69 2f       	mov	r22, r25
     eb4:	0e 94 c7 06 	call	0xd8e	; 0xd8e <enc28j60_wcr>
	enc28j60_wcr16(MIWR, data);
     eb8:	86 ed       	ldi	r24, 0xD6	; 214
     eba:	be 01       	movw	r22, r28
     ebc:	0e 94 db 06 	call	0xdb6	; 0xdb6 <enc28j60_wcr16>
	while(enc28j60_rcr(MISTAT) & MISTAT_BUSY)
     ec0:	8a ee       	ldi	r24, 0xEA	; 234
     ec2:	0e 94 b6 06 	call	0xd6c	; 0xd6c <enc28j60_rcr>
     ec6:	80 fd       	sbrc	r24, 0
     ec8:	fb cf       	rjmp	.-10     	; 0xec0 <enc28j60_write_phy+0x18>
		;
}
     eca:	df 91       	pop	r29
     ecc:	cf 91       	pop	r28
     ece:	08 95       	ret

00000ed0 <enc28j60_init>:
/*
 * Init & packet Rx/Tx
 */

void enc28j60_init(uint8_t *macadr)
{
     ed0:	cf 93       	push	r28
     ed2:	df 93       	push	r29
     ed4:	ec 01       	movw	r28, r24
	// Initialize SPI
	ENC28J60_SPI_DDR |= ENC28J60_SPI_CS|ENC28J60_SPI_MOSI|ENC28J60_SPI_SCK;
     ed6:	84 b1       	in	r24, 0x04	; 4
     ed8:	86 61       	ori	r24, 0x16	; 22
     eda:	84 b9       	out	0x04, r24	; 4
	ENC28J60_SPI_DDR &= ~ENC28J60_SPI_MISO;
     edc:	23 98       	cbi	0x04, 3	; 4
	enc28j60_release();
     ede:	2c 9a       	sbi	0x05, 4	; 5

	SPCR = (1<<SPE)|(1<<MSTR);
     ee0:	80 e5       	ldi	r24, 0x50	; 80
     ee2:	8c bd       	out	0x2c, r24	; 44
	SPSR |= (1<<SPI2X); // Maximum speed
     ee4:	8d b5       	in	r24, 0x2d	; 45
     ee6:	81 60       	ori	r24, 0x01	; 1
     ee8:	8d bd       	out	0x2d, r24	; 45

	// Reset ENC28J60
	enc28j60_soft_reset();
     eea:	0e 94 8a 06 	call	0xd14	; 0xd14 <enc28j60_soft_reset>

	// Setup Rx/Tx buffer
	enc28j60_wcr16(ERXST, ENC28J60_RXSTART);
     eee:	88 e0       	ldi	r24, 0x08	; 8
     ef0:	60 e0       	ldi	r22, 0x00	; 0
     ef2:	70 e0       	ldi	r23, 0x00	; 0
     ef4:	0e 94 db 06 	call	0xdb6	; 0xdb6 <enc28j60_wcr16>
	enc28j60_wcr16(ERXRDPT, ENC28J60_RXSTART);
     ef8:	8c e0       	ldi	r24, 0x0C	; 12
     efa:	60 e0       	ldi	r22, 0x00	; 0
     efc:	70 e0       	ldi	r23, 0x00	; 0
     efe:	0e 94 db 06 	call	0xdb6	; 0xdb6 <enc28j60_wcr16>
	enc28j60_wcr16(ERXND, ENC28J60_RXEND);
     f02:	8a e0       	ldi	r24, 0x0A	; 10
     f04:	6f ef       	ldi	r22, 0xFF	; 255
     f06:	79 e1       	ldi	r23, 0x19	; 25
     f08:	0e 94 db 06 	call	0xdb6	; 0xdb6 <enc28j60_wcr16>
	enc28j60_rxrdpt = ENC28J60_RXSTART;
     f0c:	10 92 f2 02 	sts	0x02F2, r1
     f10:	10 92 f1 02 	sts	0x02F1, r1

	// Setup MAC
	enc28j60_wcr(MACON1, MACON1_TXPAUS| // Enable flow control
     f14:	80 ec       	ldi	r24, 0xC0	; 192
     f16:	6d e0       	ldi	r22, 0x0D	; 13
     f18:	0e 94 c7 06 	call	0xd8e	; 0xd8e <enc28j60_wcr>
		MACON1_RXPAUS|MACON1_MARXEN); // Enable MAC Rx
	enc28j60_wcr(MACON2, 0); // Clear reset
     f1c:	81 ec       	ldi	r24, 0xC1	; 193
     f1e:	60 e0       	ldi	r22, 0x00	; 0
     f20:	0e 94 c7 06 	call	0xd8e	; 0xd8e <enc28j60_wcr>
	enc28j60_wcr(MACON3, MACON3_PADCFG0| // Enable padding,
     f24:	82 ec       	ldi	r24, 0xC2	; 194
     f26:	63 e3       	ldi	r22, 0x33	; 51
     f28:	0e 94 c7 06 	call	0xd8e	; 0xd8e <enc28j60_wcr>
		MACON3_TXCRCEN|MACON3_FRMLNEN|MACON3_FULDPX); // Enable crc & frame len chk
	enc28j60_wcr16(MAMXFL, ENC28J60_MAXFRAME);
     f2c:	8a ec       	ldi	r24, 0xCA	; 202
     f2e:	60 e0       	ldi	r22, 0x00	; 0
     f30:	72 e0       	ldi	r23, 0x02	; 2
     f32:	0e 94 db 06 	call	0xdb6	; 0xdb6 <enc28j60_wcr16>
	enc28j60_wcr(MABBIPG, 0x15); // Set inter-frame gap
     f36:	84 ec       	ldi	r24, 0xC4	; 196
     f38:	65 e1       	ldi	r22, 0x15	; 21
     f3a:	0e 94 c7 06 	call	0xd8e	; 0xd8e <enc28j60_wcr>
	enc28j60_wcr(MAIPGL, 0x12);
     f3e:	86 ec       	ldi	r24, 0xC6	; 198
     f40:	62 e1       	ldi	r22, 0x12	; 18
     f42:	0e 94 c7 06 	call	0xd8e	; 0xd8e <enc28j60_wcr>
	enc28j60_wcr(MAIPGH, 0x0c);
     f46:	87 ec       	ldi	r24, 0xC7	; 199
     f48:	6c e0       	ldi	r22, 0x0C	; 12
     f4a:	0e 94 c7 06 	call	0xd8e	; 0xd8e <enc28j60_wcr>
	enc28j60_wcr(MAADR5, macadr[0]); // Set MAC address
     f4e:	84 ee       	ldi	r24, 0xE4	; 228
     f50:	68 81       	ld	r22, Y
     f52:	0e 94 c7 06 	call	0xd8e	; 0xd8e <enc28j60_wcr>
	enc28j60_wcr(MAADR4, macadr[1]);
     f56:	85 ee       	ldi	r24, 0xE5	; 229
     f58:	69 81       	ldd	r22, Y+1	; 0x01
     f5a:	0e 94 c7 06 	call	0xd8e	; 0xd8e <enc28j60_wcr>
	enc28j60_wcr(MAADR3, macadr[2]);
     f5e:	82 ee       	ldi	r24, 0xE2	; 226
     f60:	6a 81       	ldd	r22, Y+2	; 0x02
     f62:	0e 94 c7 06 	call	0xd8e	; 0xd8e <enc28j60_wcr>
	enc28j60_wcr(MAADR2, macadr[3]);
     f66:	83 ee       	ldi	r24, 0xE3	; 227
     f68:	6b 81       	ldd	r22, Y+3	; 0x03
     f6a:	0e 94 c7 06 	call	0xd8e	; 0xd8e <enc28j60_wcr>
	enc28j60_wcr(MAADR1, macadr[4]);
     f6e:	80 ee       	ldi	r24, 0xE0	; 224
     f70:	6c 81       	ldd	r22, Y+4	; 0x04
     f72:	0e 94 c7 06 	call	0xd8e	; 0xd8e <enc28j60_wcr>
	enc28j60_wcr(MAADR0, macadr[5]);
     f76:	81 ee       	ldi	r24, 0xE1	; 225
     f78:	6d 81       	ldd	r22, Y+5	; 0x05
     f7a:	0e 94 c7 06 	call	0xd8e	; 0xd8e <enc28j60_wcr>

	// Setup PHY
	enc28j60_write_phy(PHCON1, PHCON1_PDPXMD); // Force full-duplex mode
     f7e:	80 e0       	ldi	r24, 0x00	; 0
     f80:	60 e0       	ldi	r22, 0x00	; 0
     f82:	71 e0       	ldi	r23, 0x01	; 1
     f84:	0e 94 54 07 	call	0xea8	; 0xea8 <enc28j60_write_phy>
	enc28j60_write_phy(PHCON2, PHCON2_HDLDIS); // Disable loopback
     f88:	80 e1       	ldi	r24, 0x10	; 16
     f8a:	60 e0       	ldi	r22, 0x00	; 0
     f8c:	71 e0       	ldi	r23, 0x01	; 1
     f8e:	0e 94 54 07 	call	0xea8	; 0xea8 <enc28j60_write_phy>
	enc28j60_write_phy(PHLCON, PHLCON_LACFG2| // Configure LED ctrl
     f92:	84 e1       	ldi	r24, 0x14	; 20
     f94:	66 e7       	ldi	r22, 0x76	; 118
     f96:	74 e0       	ldi	r23, 0x04	; 4
     f98:	0e 94 54 07 	call	0xea8	; 0xea8 <enc28j60_write_phy>
		PHLCON_LBCFG2|PHLCON_LBCFG1|PHLCON_LBCFG0|
		PHLCON_LFRQ0|PHLCON_STRCH);

	// Enable Rx packets
	enc28j60_bfs(ECON1, ECON1_RXEN);
     f9c:	8f e1       	ldi	r24, 0x1F	; 31
     f9e:	64 e0       	ldi	r22, 0x04	; 4
     fa0:	0e 94 0d 07 	call	0xe1a	; 0xe1a <enc28j60_bfs>
}
     fa4:	df 91       	pop	r29
     fa6:	cf 91       	pop	r28
     fa8:	08 95       	ret

00000faa <enc28j60_send_packet>:

void enc28j60_send_packet(uint8_t *data, uint16_t len)
{
     faa:	0f 93       	push	r16
     fac:	1f 93       	push	r17
     fae:	cf 93       	push	r28
     fb0:	df 93       	push	r29
     fb2:	8c 01       	movw	r16, r24
     fb4:	eb 01       	movw	r28, r22
	while(enc28j60_rcr(ECON1) & ECON1_TXRTS)
     fb6:	0d c0       	rjmp	.+26     	; 0xfd2 <enc28j60_send_packet+0x28>
	{
		// TXRTS may not clear - ENC28J60 bug. We must reset
		// transmit logic in cause of Tx error
		if(enc28j60_rcr(EIR) & EIR_TXERIF)
     fb8:	8c e1       	ldi	r24, 0x1C	; 28
     fba:	0e 94 b6 06 	call	0xd6c	; 0xd6c <enc28j60_rcr>
     fbe:	81 ff       	sbrs	r24, 1
     fc0:	08 c0       	rjmp	.+16     	; 0xfd2 <enc28j60_send_packet+0x28>
		{
			enc28j60_bfs(ECON1, ECON1_TXRST);
     fc2:	8f e1       	ldi	r24, 0x1F	; 31
     fc4:	60 e8       	ldi	r22, 0x80	; 128
     fc6:	0e 94 0d 07 	call	0xe1a	; 0xe1a <enc28j60_bfs>
			enc28j60_bfc(ECON1, ECON1_TXRST);
     fca:	8f e1       	ldi	r24, 0x1F	; 31
     fcc:	60 e8       	ldi	r22, 0x80	; 128
     fce:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <enc28j60_bfc>
	enc28j60_bfs(ECON1, ECON1_RXEN);
}

void enc28j60_send_packet(uint8_t *data, uint16_t len)
{
	while(enc28j60_rcr(ECON1) & ECON1_TXRTS)
     fd2:	8f e1       	ldi	r24, 0x1F	; 31
     fd4:	0e 94 b6 06 	call	0xd6c	; 0xd6c <enc28j60_rcr>
     fd8:	83 fd       	sbrc	r24, 3
     fda:	ee cf       	rjmp	.-36     	; 0xfb8 <enc28j60_send_packet+0xe>
			enc28j60_bfs(ECON1, ECON1_TXRST);
			enc28j60_bfc(ECON1, ECON1_TXRST);
		}
	}

	enc28j60_wcr16(EWRPT, ENC28J60_TXSTART);
     fdc:	82 e0       	ldi	r24, 0x02	; 2
     fde:	60 e0       	ldi	r22, 0x00	; 0
     fe0:	7a e1       	ldi	r23, 0x1A	; 26
     fe2:	0e 94 db 06 	call	0xdb6	; 0xdb6 <enc28j60_wcr16>
	enc28j60_write_buffer((uint8_t*)"\x00", 1);
     fe6:	80 e0       	ldi	r24, 0x00	; 0
     fe8:	92 e0       	ldi	r25, 0x02	; 2
     fea:	61 e0       	ldi	r22, 0x01	; 1
     fec:	70 e0       	ldi	r23, 0x00	; 0
     fee:	0e 94 3b 07 	call	0xe76	; 0xe76 <enc28j60_write_buffer>
	enc28j60_write_buffer(data, len);
     ff2:	c8 01       	movw	r24, r16
     ff4:	be 01       	movw	r22, r28
     ff6:	0e 94 3b 07 	call	0xe76	; 0xe76 <enc28j60_write_buffer>

	enc28j60_wcr16(ETXST, ENC28J60_TXSTART);
     ffa:	84 e0       	ldi	r24, 0x04	; 4
     ffc:	60 e0       	ldi	r22, 0x00	; 0
     ffe:	7a e1       	ldi	r23, 0x1A	; 26
    1000:	0e 94 db 06 	call	0xdb6	; 0xdb6 <enc28j60_wcr16>
	enc28j60_wcr16(ETXND, ENC28J60_TXSTART + len);
    1004:	be 01       	movw	r22, r28
    1006:	60 50       	subi	r22, 0x00	; 0
    1008:	76 4e       	sbci	r23, 0xE6	; 230
    100a:	86 e0       	ldi	r24, 0x06	; 6
    100c:	0e 94 db 06 	call	0xdb6	; 0xdb6 <enc28j60_wcr16>

	enc28j60_bfs(ECON1, ECON1_TXRTS); // Request packet send
    1010:	8f e1       	ldi	r24, 0x1F	; 31
    1012:	68 e0       	ldi	r22, 0x08	; 8
    1014:	0e 94 0d 07 	call	0xe1a	; 0xe1a <enc28j60_bfs>
}
    1018:	df 91       	pop	r29
    101a:	cf 91       	pop	r28
    101c:	1f 91       	pop	r17
    101e:	0f 91       	pop	r16
    1020:	08 95       	ret

00001022 <enc28j60_recv_packet>:

uint16_t enc28j60_recv_packet(uint8_t *buf, uint16_t buflen)
{
    1022:	ef 92       	push	r14
    1024:	ff 92       	push	r15
    1026:	0f 93       	push	r16
    1028:	1f 93       	push	r17
    102a:	df 93       	push	r29
    102c:	cf 93       	push	r28
    102e:	00 d0       	rcall	.+0      	; 0x1030 <enc28j60_recv_packet+0xe>
    1030:	0f 92       	push	r0
    1032:	cd b7       	in	r28, 0x3d	; 61
    1034:	de b7       	in	r29, 0x3e	; 62
    1036:	7c 01       	movw	r14, r24
    1038:	16 2f       	mov	r17, r22
    103a:	07 2f       	mov	r16, r23
	uint16_t len = 0, rxlen, status, temp;

	if(enc28j60_rcr(EPKTCNT))
    103c:	89 e3       	ldi	r24, 0x39	; 57
    103e:	0e 94 b6 06 	call	0xd6c	; 0xd6c <enc28j60_rcr>
    1042:	88 23       	and	r24, r24
    1044:	e9 f1       	breq	.+122    	; 0x10c0 <enc28j60_recv_packet+0x9e>
	{
		enc28j60_wcr16(ERDPT, enc28j60_rxrdpt);
    1046:	20 91 f1 02 	lds	r18, 0x02F1
    104a:	30 91 f2 02 	lds	r19, 0x02F2
    104e:	80 e0       	ldi	r24, 0x00	; 0
    1050:	b9 01       	movw	r22, r18
    1052:	0e 94 db 06 	call	0xdb6	; 0xdb6 <enc28j60_wcr16>

		enc28j60_read_buffer((void*)&enc28j60_rxrdpt, sizeof(enc28j60_rxrdpt));
    1056:	81 ef       	ldi	r24, 0xF1	; 241
    1058:	92 e0       	ldi	r25, 0x02	; 2
    105a:	62 e0       	ldi	r22, 0x02	; 2
    105c:	70 e0       	ldi	r23, 0x00	; 0
    105e:	0e 94 21 07 	call	0xe42	; 0xe42 <enc28j60_read_buffer>
		enc28j60_read_buffer((void*)&rxlen, sizeof(rxlen));
    1062:	ce 01       	movw	r24, r28
    1064:	01 96       	adiw	r24, 0x01	; 1
    1066:	62 e0       	ldi	r22, 0x02	; 2
    1068:	70 e0       	ldi	r23, 0x00	; 0
    106a:	0e 94 21 07 	call	0xe42	; 0xe42 <enc28j60_read_buffer>
		enc28j60_read_buffer((void*)&status, sizeof(status));
    106e:	ce 01       	movw	r24, r28
    1070:	03 96       	adiw	r24, 0x03	; 3
    1072:	62 e0       	ldi	r22, 0x02	; 2
    1074:	70 e0       	ldi	r23, 0x00	; 0
    1076:	0e 94 21 07 	call	0xe42	; 0xe42 <enc28j60_read_buffer>

		if(status & 0x80) //success
    107a:	8b 81       	ldd	r24, Y+3	; 0x03
    107c:	87 ff       	sbrs	r24, 7
    107e:	0f c0       	rjmp	.+30     	; 0x109e <enc28j60_recv_packet+0x7c>
		{
			len = rxlen - 4; //throw out crc
    1080:	89 81       	ldd	r24, Y+1	; 0x01
    1082:	9a 81       	ldd	r25, Y+2	; 0x02
    1084:	04 97       	sbiw	r24, 0x04	; 4
    1086:	98 01       	movw	r18, r16
    1088:	03 2f       	mov	r16, r19
    108a:	12 2f       	mov	r17, r18
    108c:	80 17       	cp	r24, r16
    108e:	91 07       	cpc	r25, r17
    1090:	08 f4       	brcc	.+2      	; 0x1094 <enc28j60_recv_packet+0x72>
    1092:	8c 01       	movw	r16, r24
			if(len > buflen) len = buflen;
			enc28j60_read_buffer(buf, len);	
    1094:	c7 01       	movw	r24, r14
    1096:	b8 01       	movw	r22, r16
    1098:	0e 94 21 07 	call	0xe42	; 0xe42 <enc28j60_read_buffer>
    109c:	02 c0       	rjmp	.+4      	; 0x10a2 <enc28j60_recv_packet+0x80>
	enc28j60_bfs(ECON1, ECON1_TXRTS); // Request packet send
}

uint16_t enc28j60_recv_packet(uint8_t *buf, uint16_t buflen)
{
	uint16_t len = 0, rxlen, status, temp;
    109e:	00 e0       	ldi	r16, 0x00	; 0
    10a0:	10 e0       	ldi	r17, 0x00	; 0
			if(len > buflen) len = buflen;
			enc28j60_read_buffer(buf, len);	
		}

		// Set Rx read pointer to next packet
		temp = (enc28j60_rxrdpt - 1) & ENC28J60_BUFEND;
    10a2:	60 91 f1 02 	lds	r22, 0x02F1
    10a6:	70 91 f2 02 	lds	r23, 0x02F2
    10aa:	61 50       	subi	r22, 0x01	; 1
    10ac:	70 40       	sbci	r23, 0x00	; 0
    10ae:	7f 71       	andi	r23, 0x1F	; 31
		enc28j60_wcr16(ERXRDPT, temp);
    10b0:	8c e0       	ldi	r24, 0x0C	; 12
    10b2:	0e 94 db 06 	call	0xdb6	; 0xdb6 <enc28j60_wcr16>

		// Decrement packet counter
		enc28j60_bfs(ECON2, ECON2_PKTDEC);
    10b6:	8e e1       	ldi	r24, 0x1E	; 30
    10b8:	60 e4       	ldi	r22, 0x40	; 64
    10ba:	0e 94 0d 07 	call	0xe1a	; 0xe1a <enc28j60_bfs>
    10be:	02 c0       	rjmp	.+4      	; 0x10c4 <enc28j60_recv_packet+0xa2>
	enc28j60_bfs(ECON1, ECON1_TXRTS); // Request packet send
}

uint16_t enc28j60_recv_packet(uint8_t *buf, uint16_t buflen)
{
	uint16_t len = 0, rxlen, status, temp;
    10c0:	00 e0       	ldi	r16, 0x00	; 0
    10c2:	10 e0       	ldi	r17, 0x00	; 0
		// Decrement packet counter
		enc28j60_bfs(ECON2, ECON2_PKTDEC);
	}

	return len;
}
    10c4:	c8 01       	movw	r24, r16
    10c6:	0f 90       	pop	r0
    10c8:	0f 90       	pop	r0
    10ca:	0f 90       	pop	r0
    10cc:	0f 90       	pop	r0
    10ce:	cf 91       	pop	r28
    10d0:	df 91       	pop	r29
    10d2:	1f 91       	pop	r17
    10d4:	0f 91       	pop	r16
    10d6:	ff 90       	pop	r15
    10d8:	ef 90       	pop	r14
    10da:	08 95       	ret

000010dc <udp_filter>:
void udp_filter(eth_frame_t *frame, uint16_t len)
{
	ip_packet_t *ip = (void*)(frame->data);
	udp_packet_t *udp = (void*)(ip->data);

	if(len >= sizeof(udp_packet_t))
    10dc:	68 30       	cpi	r22, 0x08	; 8
    10de:	71 05       	cpc	r23, r1
    10e0:	50 f0       	brcs	.+20     	; 0x10f6 <udp_filter+0x1a>
	{
		udp_packet(frame, ntohs(udp->len) - 
    10e2:	fc 01       	movw	r30, r24
    10e4:	66 a1       	ldd	r22, Z+38	; 0x26
    10e6:	77 a1       	ldd	r23, Z+39	; 0x27
    10e8:	76 27       	eor	r23, r22
    10ea:	67 27       	eor	r22, r23
    10ec:	76 27       	eor	r23, r22
    10ee:	68 50       	subi	r22, 0x08	; 8
    10f0:	70 40       	sbci	r23, 0x00	; 0
    10f2:	0e 94 07 1c 	call	0x380e	; 0x380e <udp_packet>
    10f6:	08 95       	ret

000010f8 <ip_cksum>:
 * IP
 */

// calculate IP checksum
uint16_t ip_cksum(uint32_t sum, uint8_t *buf, size_t len)
{
    10f8:	ef 92       	push	r14
    10fa:	ff 92       	push	r15
    10fc:	0f 93       	push	r16
    10fe:	1f 93       	push	r17
    1100:	cf 93       	push	r28
    1102:	df 93       	push	r29
    1104:	ea 01       	movw	r28, r20
    1106:	a9 01       	movw	r20, r18
	while(len >= 2)
    1108:	d9 01       	movw	r26, r18
    110a:	fe 01       	movw	r30, r28
    110c:	0e c0       	rjmp	.+28     	; 0x112a <ip_cksum+0x32>
	{
		sum += ((uint16_t)*buf << 8) | *(buf+1);
    110e:	f0 80       	ld	r15, Z
    1110:	ee 24       	eor	r14, r14
    1112:	01 81       	ldd	r16, Z+1	; 0x01
    1114:	10 e0       	ldi	r17, 0x00	; 0
    1116:	0e 29       	or	r16, r14
    1118:	1f 29       	or	r17, r15
    111a:	20 e0       	ldi	r18, 0x00	; 0
    111c:	30 e0       	ldi	r19, 0x00	; 0
    111e:	60 0f       	add	r22, r16
    1120:	71 1f       	adc	r23, r17
    1122:	82 1f       	adc	r24, r18
    1124:	93 1f       	adc	r25, r19
		buf += 2;
    1126:	32 96       	adiw	r30, 0x02	; 2
		len -= 2;
    1128:	12 97       	sbiw	r26, 0x02	; 2
 */

// calculate IP checksum
uint16_t ip_cksum(uint32_t sum, uint8_t *buf, size_t len)
{
	while(len >= 2)
    112a:	a2 30       	cpi	r26, 0x02	; 2
    112c:	b1 05       	cpc	r27, r1
    112e:	78 f7       	brcc	.-34     	; 0x110e <ip_cksum+0x16>
/*
 * IP
 */

// calculate IP checksum
uint16_t ip_cksum(uint32_t sum, uint8_t *buf, size_t len)
    1130:	fa 01       	movw	r30, r20
    1132:	ee 7f       	andi	r30, 0xFE	; 254
{
	while(len >= 2)
    1134:	ec 0f       	add	r30, r28
    1136:	fd 1f       	adc	r31, r29
		sum += ((uint16_t)*buf << 8) | *(buf+1);
		buf += 2;
		len -= 2;
	}

	if(len)
    1138:	40 ff       	sbrs	r20, 0
    113a:	0b c0       	rjmp	.+22     	; 0x1152 <ip_cksum+0x5a>
		sum += (uint16_t)*buf << 8;
    113c:	30 81       	ld	r19, Z
    113e:	20 e0       	ldi	r18, 0x00	; 0
    1140:	40 e0       	ldi	r20, 0x00	; 0
    1142:	50 e0       	ldi	r21, 0x00	; 0
    1144:	02 c0       	rjmp	.+4      	; 0x114a <ip_cksum+0x52>

	while(sum >> 16)
		sum = (sum & 0xffff) + (sum >> 16);
    1146:	80 70       	andi	r24, 0x00	; 0
    1148:	90 70       	andi	r25, 0x00	; 0
    114a:	62 0f       	add	r22, r18
    114c:	73 1f       	adc	r23, r19
    114e:	84 1f       	adc	r24, r20
    1150:	95 1f       	adc	r25, r21
	}

	if(len)
		sum += (uint16_t)*buf << 8;

	while(sum >> 16)
    1152:	9c 01       	movw	r18, r24
    1154:	44 27       	eor	r20, r20
    1156:	55 27       	eor	r21, r21
    1158:	21 15       	cp	r18, r1
    115a:	31 05       	cpc	r19, r1
    115c:	41 05       	cpc	r20, r1
    115e:	51 05       	cpc	r21, r1
    1160:	91 f7       	brne	.-28     	; 0x1146 <ip_cksum+0x4e>
		sum = (sum & 0xffff) + (sum >> 16);

	return ~htons((uint16_t)sum);
    1162:	36 2f       	mov	r19, r22
    1164:	27 2f       	mov	r18, r23
    1166:	20 95       	com	r18
    1168:	30 95       	com	r19
}
    116a:	c9 01       	movw	r24, r18
    116c:	df 91       	pop	r29
    116e:	cf 91       	pop	r28
    1170:	1f 91       	pop	r17
    1172:	0f 91       	pop	r16
    1174:	ff 90       	pop	r15
    1176:	ef 90       	pop	r14
    1178:	08 95       	ret

0000117a <arp_search_cache>:
uint8_t *arp_search_cache(uint32_t node_ip_addr)
{
	uint8_t i;
	for(i = 0; i < ARP_CACHE_SIZE; ++i)
	{
		if(arp_cache[i].ip_addr == node_ip_addr)
    117a:	20 91 37 05 	lds	r18, 0x0537
    117e:	30 91 38 05 	lds	r19, 0x0538
    1182:	40 91 39 05 	lds	r20, 0x0539
    1186:	50 91 3a 05 	lds	r21, 0x053A
    118a:	26 17       	cp	r18, r22
    118c:	37 07       	cpc	r19, r23
    118e:	48 07       	cpc	r20, r24
    1190:	59 07       	cpc	r21, r25
    1192:	e1 f0       	breq	.+56     	; 0x11cc <arp_search_cache+0x52>
    1194:	20 91 41 05 	lds	r18, 0x0541
    1198:	30 91 42 05 	lds	r19, 0x0542
    119c:	40 91 43 05 	lds	r20, 0x0543
    11a0:	50 91 44 05 	lds	r21, 0x0544
    11a4:	26 17       	cp	r18, r22
    11a6:	37 07       	cpc	r19, r23
    11a8:	48 07       	cpc	r20, r24
    11aa:	59 07       	cpc	r21, r25
    11ac:	89 f0       	breq	.+34     	; 0x11d0 <arp_search_cache+0x56>
    11ae:	20 91 4b 05 	lds	r18, 0x054B
    11b2:	30 91 4c 05 	lds	r19, 0x054C
    11b6:	40 91 4d 05 	lds	r20, 0x054D
    11ba:	50 91 4e 05 	lds	r21, 0x054E
    11be:	26 17       	cp	r18, r22
    11c0:	37 07       	cpc	r19, r23
    11c2:	48 07       	cpc	r20, r24
    11c4:	59 07       	cpc	r21, r25
    11c6:	a1 f4       	brne	.+40     	; 0x11f0 <arp_search_cache+0x76>

// search ARP cache
uint8_t *arp_search_cache(uint32_t node_ip_addr)
{
	uint8_t i;
	for(i = 0; i < ARP_CACHE_SIZE; ++i)
    11c8:	22 e0       	ldi	r18, 0x02	; 2
    11ca:	03 c0       	rjmp	.+6      	; 0x11d2 <arp_search_cache+0x58>
    11cc:	20 e0       	ldi	r18, 0x00	; 0
    11ce:	01 c0       	rjmp	.+2      	; 0x11d2 <arp_search_cache+0x58>
    11d0:	21 e0       	ldi	r18, 0x01	; 1
	{
		if(arp_cache[i].ip_addr == node_ip_addr)
			return arp_cache[i].mac_addr;
    11d2:	82 2f       	mov	r24, r18
    11d4:	90 e0       	ldi	r25, 0x00	; 0
    11d6:	9c 01       	movw	r18, r24
    11d8:	22 0f       	add	r18, r18
    11da:	33 1f       	adc	r19, r19
    11dc:	43 e0       	ldi	r20, 0x03	; 3
    11de:	88 0f       	add	r24, r24
    11e0:	99 1f       	adc	r25, r25
    11e2:	4a 95       	dec	r20
    11e4:	e1 f7       	brne	.-8      	; 0x11de <arp_search_cache+0x64>
    11e6:	28 0f       	add	r18, r24
    11e8:	39 1f       	adc	r19, r25
    11ea:	25 5c       	subi	r18, 0xC5	; 197
    11ec:	3a 4f       	sbci	r19, 0xFA	; 250
    11ee:	02 c0       	rjmp	.+4      	; 0x11f4 <arp_search_cache+0x7a>
	}
	return 0;
    11f0:	20 e0       	ldi	r18, 0x00	; 0
    11f2:	30 e0       	ldi	r19, 0x00	; 0
}
    11f4:	c9 01       	movw	r24, r18
    11f6:	08 95       	ret

000011f8 <eth_send>:
// fields must be set:
//	- frame.to_addr
//	- frame.type
void eth_send(eth_frame_t *frame, uint16_t len)
{
	memcpy(frame->from_addr, mac_addr, 6);
    11f8:	dc 01       	movw	r26, r24
    11fa:	16 96       	adiw	r26, 0x06	; 6
    11fc:	ec ed       	ldi	r30, 0xDC	; 220
    11fe:	f2 e0       	ldi	r31, 0x02	; 2
    1200:	26 e0       	ldi	r18, 0x06	; 6
    1202:	01 90       	ld	r0, Z+
    1204:	0d 92       	st	X+, r0
    1206:	21 50       	subi	r18, 0x01	; 1
    1208:	e1 f7       	brne	.-8      	; 0x1202 <eth_send+0xa>
	enc28j60_send_packet((void*)frame, len +
    120a:	62 5f       	subi	r22, 0xF2	; 242
    120c:	7f 4f       	sbci	r23, 0xFF	; 255
    120e:	0e 94 d5 07 	call	0xfaa	; 0xfaa <enc28j60_send_packet>
		sizeof(eth_frame_t));
}
    1212:	08 95       	ret

00001214 <arp_resolve>:

// resolve MAC address
// returns 0 if still resolving
// (invalidates net_buffer if not resolved)
uint8_t *arp_resolve(uint32_t node_ip_addr)
{
    1214:	af 92       	push	r10
    1216:	bf 92       	push	r11
    1218:	cf 92       	push	r12
    121a:	df 92       	push	r13
    121c:	ef 92       	push	r14
    121e:	ff 92       	push	r15
    1220:	0f 93       	push	r16
    1222:	1f 93       	push	r17
    1224:	cf 93       	push	r28
    1226:	df 93       	push	r29
    1228:	6b 01       	movw	r12, r22
    122a:	7c 01       	movw	r14, r24
	eth_frame_t *frame = (void*)net_buf;
	arp_message_t *msg = (void*)(frame->data);
	uint8_t *mac;

	// search arp cache
	if((mac = arp_search_cache(node_ip_addr)))
    122c:	0e 94 bd 08 	call	0x117a	; 0x117a <arp_search_cache>
    1230:	5c 01       	movw	r10, r24
    1232:	00 97       	sbiw	r24, 0x00	; 0
    1234:	09 f0       	breq	.+2      	; 0x1238 <arp_resolve+0x24>
    1236:	46 c0       	rjmp	.+140    	; 0x12c4 <arp_resolve+0xb0>
// resolve MAC address
// returns 0 if still resolving
// (invalidates net_buffer if not resolved)
uint8_t *arp_resolve(uint32_t node_ip_addr)
{
	eth_frame_t *frame = (void*)net_buf;
    1238:	07 e3       	ldi	r16, 0x37	; 55
    123a:	13 e0       	ldi	r17, 0x03	; 3
	arp_message_t *msg = (void*)(frame->data);
    123c:	e8 01       	movw	r28, r16
    123e:	2e 96       	adiw	r28, 0x0e	; 14
	// search arp cache
	if((mac = arp_search_cache(node_ip_addr)))
		return mac;

	// send request
	memset(frame->to_addr, 0xff, 6);
    1240:	c8 01       	movw	r24, r16
    1242:	6f ef       	ldi	r22, 0xFF	; 255
    1244:	70 e0       	ldi	r23, 0x00	; 0
    1246:	46 e0       	ldi	r20, 0x06	; 6
    1248:	50 e0       	ldi	r21, 0x00	; 0
    124a:	0e 94 58 1f 	call	0x3eb0	; 0x3eb0 <memset>
	frame->type = ETH_TYPE_ARP;
    124e:	88 e0       	ldi	r24, 0x08	; 8
    1250:	96 e0       	ldi	r25, 0x06	; 6
    1252:	90 93 44 03 	sts	0x0344, r25
    1256:	80 93 43 03 	sts	0x0343, r24

	msg->hw_type = ARP_HW_TYPE_ETH;
    125a:	80 e0       	ldi	r24, 0x00	; 0
    125c:	91 e0       	ldi	r25, 0x01	; 1
    125e:	90 93 46 03 	sts	0x0346, r25
    1262:	80 93 45 03 	sts	0x0345, r24
	msg->proto_type = ARP_PROTO_TYPE_IP;
    1266:	28 e0       	ldi	r18, 0x08	; 8
    1268:	30 e0       	ldi	r19, 0x00	; 0
    126a:	3b 83       	std	Y+3, r19	; 0x03
    126c:	2a 83       	std	Y+2, r18	; 0x02
	msg->hw_addr_len = 6;
    126e:	26 e0       	ldi	r18, 0x06	; 6
    1270:	2c 83       	std	Y+4, r18	; 0x04
	msg->proto_addr_len = 4;
    1272:	24 e0       	ldi	r18, 0x04	; 4
    1274:	2d 83       	std	Y+5, r18	; 0x05
	msg->type = ARP_TYPE_REQUEST;
    1276:	9f 83       	std	Y+7, r25	; 0x07
    1278:	8e 83       	std	Y+6, r24	; 0x06
	memcpy(msg->mac_addr_from, mac_addr, 6);
    127a:	d8 01       	movw	r26, r16
    127c:	56 96       	adiw	r26, 0x16	; 22
    127e:	ec ed       	ldi	r30, 0xDC	; 220
    1280:	f2 e0       	ldi	r31, 0x02	; 2
    1282:	86 e0       	ldi	r24, 0x06	; 6
    1284:	01 90       	ld	r0, Z+
    1286:	0d 92       	st	X+, r0
    1288:	81 50       	subi	r24, 0x01	; 1
    128a:	e1 f7       	brne	.-8      	; 0x1284 <arp_resolve+0x70>
	msg->ip_addr_from = ip_addr;
    128c:	80 91 e2 02 	lds	r24, 0x02E2
    1290:	90 91 e3 02 	lds	r25, 0x02E3
    1294:	a0 91 e4 02 	lds	r26, 0x02E4
    1298:	b0 91 e5 02 	lds	r27, 0x02E5
    129c:	8e 87       	std	Y+14, r24	; 0x0e
    129e:	9f 87       	std	Y+15, r25	; 0x0f
    12a0:	a8 8b       	std	Y+16, r26	; 0x10
    12a2:	b9 8b       	std	Y+17, r27	; 0x11
	memset(msg->mac_addr_to, 0x00, 6);
    12a4:	87 e5       	ldi	r24, 0x57	; 87
    12a6:	93 e0       	ldi	r25, 0x03	; 3
    12a8:	26 e0       	ldi	r18, 0x06	; 6
    12aa:	dc 01       	movw	r26, r24
    12ac:	1d 92       	st	X+, r1
    12ae:	2a 95       	dec	r18
    12b0:	e9 f7       	brne	.-6      	; 0x12ac <arp_resolve+0x98>
	msg->ip_addr_to = node_ip_addr;
    12b2:	c8 8e       	std	Y+24, r12	; 0x18
    12b4:	d9 8e       	std	Y+25, r13	; 0x19
    12b6:	ea 8e       	std	Y+26, r14	; 0x1a
    12b8:	fb 8e       	std	Y+27, r15	; 0x1b

	eth_send(frame, sizeof(arp_message_t));
    12ba:	80 97       	sbiw	r24, 0x20	; 32
    12bc:	6c e1       	ldi	r22, 0x1C	; 28
    12be:	70 e0       	ldi	r23, 0x00	; 0
    12c0:	0e 94 fc 08 	call	0x11f8	; 0x11f8 <eth_send>
	return 0;
}
    12c4:	c5 01       	movw	r24, r10
    12c6:	df 91       	pop	r29
    12c8:	cf 91       	pop	r28
    12ca:	1f 91       	pop	r17
    12cc:	0f 91       	pop	r16
    12ce:	ff 90       	pop	r15
    12d0:	ef 90       	pop	r14
    12d2:	df 90       	pop	r13
    12d4:	cf 90       	pop	r12
    12d6:	bf 90       	pop	r11
    12d8:	af 90       	pop	r10
    12da:	08 95       	ret

000012dc <ip_send>:
// fields must be set:
//	- ip.dst
//	- ip.proto
// len is IP packet payload length
uint8_t ip_send(eth_frame_t *frame, uint16_t len)
{
    12dc:	af 92       	push	r10
    12de:	bf 92       	push	r11
    12e0:	cf 92       	push	r12
    12e2:	df 92       	push	r13
    12e4:	ef 92       	push	r14
    12e6:	ff 92       	push	r15
    12e8:	0f 93       	push	r16
    12ea:	1f 93       	push	r17
    12ec:	cf 93       	push	r28
    12ee:	df 93       	push	r29
    12f0:	6c 01       	movw	r12, r24
    12f2:	5b 01       	movw	r10, r22
	ip_packet_t *ip = (void*)(frame->data);
    12f4:	ec 01       	movw	r28, r24
    12f6:	2e 96       	adiw	r28, 0x0e	; 14
	uint32_t route_ip;
	uint8_t *mac_addr_to;

	// apply route
	if( ((ip->to_addr ^ ip_addr) & ip_mask) == 0 )
    12f8:	e8 88       	ldd	r14, Y+16	; 0x10
    12fa:	f9 88       	ldd	r15, Y+17	; 0x11
    12fc:	0a 89       	ldd	r16, Y+18	; 0x12
    12fe:	1b 89       	ldd	r17, Y+19	; 0x13
    1300:	80 91 e2 02 	lds	r24, 0x02E2
    1304:	90 91 e3 02 	lds	r25, 0x02E3
    1308:	a0 91 e4 02 	lds	r26, 0x02E4
    130c:	b0 91 e5 02 	lds	r27, 0x02E5
    1310:	8e 25       	eor	r24, r14
    1312:	9f 25       	eor	r25, r15
    1314:	a0 27       	eor	r26, r16
    1316:	b1 27       	eor	r27, r17
    1318:	20 91 e6 02 	lds	r18, 0x02E6
    131c:	30 91 e7 02 	lds	r19, 0x02E7
    1320:	40 91 e8 02 	lds	r20, 0x02E8
    1324:	50 91 e9 02 	lds	r21, 0x02E9
    1328:	82 23       	and	r24, r18
    132a:	93 23       	and	r25, r19
    132c:	a4 23       	and	r26, r20
    132e:	b5 23       	and	r27, r21
    1330:	00 97       	sbiw	r24, 0x00	; 0
    1332:	a1 05       	cpc	r26, r1
    1334:	b1 05       	cpc	r27, r1
    1336:	41 f0       	breq	.+16     	; 0x1348 <ip_send+0x6c>
		route_ip = ip->to_addr;
	else
		route_ip = ip_gateway;
    1338:	e0 90 ea 02 	lds	r14, 0x02EA
    133c:	f0 90 eb 02 	lds	r15, 0x02EB
    1340:	00 91 ec 02 	lds	r16, 0x02EC
    1344:	10 91 ed 02 	lds	r17, 0x02ED

	// resolve mac address
	if(!(mac_addr_to = arp_resolve(route_ip)))
    1348:	c8 01       	movw	r24, r16
    134a:	b7 01       	movw	r22, r14
    134c:	0e 94 0a 09 	call	0x1214	; 0x1214 <arp_resolve>
    1350:	00 97       	sbiw	r24, 0x00	; 0
    1352:	d1 f1       	breq	.+116    	; 0x13c8 <ip_send+0xec>
		return 0;

	// send packet
	len += sizeof(ip_packet_t);
    1354:	85 01       	movw	r16, r10
    1356:	0c 5e       	subi	r16, 0xEC	; 236
    1358:	1f 4f       	sbci	r17, 0xFF	; 255

	memcpy(frame->to_addr, mac_addr_to, 6);
    135a:	d6 01       	movw	r26, r12
    135c:	fc 01       	movw	r30, r24
    135e:	86 e0       	ldi	r24, 0x06	; 6
    1360:	01 90       	ld	r0, Z+
    1362:	0d 92       	st	X+, r0
    1364:	81 50       	subi	r24, 0x01	; 1
    1366:	e1 f7       	brne	.-8      	; 0x1360 <ip_send+0x84>
	frame->type = ETH_TYPE_IP;
    1368:	88 e0       	ldi	r24, 0x08	; 8
    136a:	90 e0       	ldi	r25, 0x00	; 0
    136c:	f6 01       	movw	r30, r12
    136e:	95 87       	std	Z+13, r25	; 0x0d
    1370:	84 87       	std	Z+12, r24	; 0x0c

	ip->ver_head_len = 0x45;
    1372:	85 e4       	ldi	r24, 0x45	; 69
    1374:	86 87       	std	Z+14, r24	; 0x0e
	ip->tos = 0;
    1376:	19 82       	std	Y+1, r1	; 0x01
	ip->total_len = htons(len);
    1378:	90 2f       	mov	r25, r16
    137a:	81 2f       	mov	r24, r17
    137c:	9b 83       	std	Y+3, r25	; 0x03
    137e:	8a 83       	std	Y+2, r24	; 0x02
	ip->fragment_id = 0;
    1380:	1d 82       	std	Y+5, r1	; 0x05
    1382:	1c 82       	std	Y+4, r1	; 0x04
	ip->flags_framgent_offset = 0;
    1384:	1f 82       	std	Y+7, r1	; 0x07
    1386:	1e 82       	std	Y+6, r1	; 0x06
	ip->ttl = IP_PACKET_TTL;
    1388:	80 e4       	ldi	r24, 0x40	; 64
    138a:	88 87       	std	Y+8, r24	; 0x08
	ip->cksum = 0;
    138c:	1b 86       	std	Y+11, r1	; 0x0b
    138e:	1a 86       	std	Y+10, r1	; 0x0a
	ip->from_addr = ip_addr;
    1390:	80 91 e2 02 	lds	r24, 0x02E2
    1394:	90 91 e3 02 	lds	r25, 0x02E3
    1398:	a0 91 e4 02 	lds	r26, 0x02E4
    139c:	b0 91 e5 02 	lds	r27, 0x02E5
    13a0:	8c 87       	std	Y+12, r24	; 0x0c
    13a2:	9d 87       	std	Y+13, r25	; 0x0d
    13a4:	ae 87       	std	Y+14, r26	; 0x0e
    13a6:	bf 87       	std	Y+15, r27	; 0x0f
	ip->cksum = ip_cksum(0, (void*)ip, sizeof(ip_packet_t));
    13a8:	60 e0       	ldi	r22, 0x00	; 0
    13aa:	70 e0       	ldi	r23, 0x00	; 0
    13ac:	cb 01       	movw	r24, r22
    13ae:	ae 01       	movw	r20, r28
    13b0:	24 e1       	ldi	r18, 0x14	; 20
    13b2:	30 e0       	ldi	r19, 0x00	; 0
    13b4:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <ip_cksum>
    13b8:	9b 87       	std	Y+11, r25	; 0x0b
    13ba:	8a 87       	std	Y+10, r24	; 0x0a

	eth_send(frame, len);
    13bc:	c6 01       	movw	r24, r12
    13be:	b8 01       	movw	r22, r16
    13c0:	0e 94 fc 08 	call	0x11f8	; 0x11f8 <eth_send>
	return 1;
    13c4:	81 e0       	ldi	r24, 0x01	; 1
    13c6:	01 c0       	rjmp	.+2      	; 0x13ca <ip_send+0xee>
	else
		route_ip = ip_gateway;

	// resolve mac address
	if(!(mac_addr_to = arp_resolve(route_ip)))
		return 0;
    13c8:	80 e0       	ldi	r24, 0x00	; 0
	ip->from_addr = ip_addr;
	ip->cksum = ip_cksum(0, (void*)ip, sizeof(ip_packet_t));

	eth_send(frame, len);
	return 1;
}
    13ca:	df 91       	pop	r29
    13cc:	cf 91       	pop	r28
    13ce:	1f 91       	pop	r17
    13d0:	0f 91       	pop	r16
    13d2:	ff 90       	pop	r15
    13d4:	ef 90       	pop	r14
    13d6:	df 90       	pop	r13
    13d8:	cf 90       	pop	r12
    13da:	bf 90       	pop	r11
    13dc:	af 90       	pop	r10
    13de:	08 95       	ret

000013e0 <udp_send>:
//	- ip.dst
//	- udp.src_port
//	- udp.dst_port
// uint16_t len is UDP data payload length
uint8_t udp_send(eth_frame_t *frame, uint16_t len)
{
    13e0:	ef 92       	push	r14
    13e2:	ff 92       	push	r15
    13e4:	0f 93       	push	r16
    13e6:	1f 93       	push	r17
    13e8:	cf 93       	push	r28
    13ea:	df 93       	push	r29
    13ec:	ec 01       	movw	r28, r24
	ip_packet_t *ip = (void*)(frame->data);
    13ee:	fc 01       	movw	r30, r24
    13f0:	3e 96       	adiw	r30, 0x0e	; 14
	udp_packet_t *udp = (void*)(ip->data);
    13f2:	8c 01       	movw	r16, r24
    13f4:	0e 5d       	subi	r16, 0xDE	; 222
    13f6:	1f 4f       	sbci	r17, 0xFF	; 255

	len += sizeof(udp_packet_t);
    13f8:	a8 e0       	ldi	r26, 0x08	; 8
    13fa:	ea 2e       	mov	r14, r26
    13fc:	f1 2c       	mov	r15, r1
    13fe:	e6 0e       	add	r14, r22
    1400:	f7 1e       	adc	r15, r23

	ip->protocol = IP_PROTOCOL_UDP;
    1402:	81 e1       	ldi	r24, 0x11	; 17
    1404:	81 87       	std	Z+9, r24	; 0x09
	ip->from_addr = ip_addr;
    1406:	80 91 e2 02 	lds	r24, 0x02E2
    140a:	90 91 e3 02 	lds	r25, 0x02E3
    140e:	a0 91 e4 02 	lds	r26, 0x02E4
    1412:	b0 91 e5 02 	lds	r27, 0x02E5
    1416:	84 87       	std	Z+12, r24	; 0x0c
    1418:	95 87       	std	Z+13, r25	; 0x0d
    141a:	a6 87       	std	Z+14, r26	; 0x0e
    141c:	b7 87       	std	Z+15, r27	; 0x0f

	udp->len = htons(len);
    141e:	9e 2d       	mov	r25, r14
    1420:	8f 2d       	mov	r24, r15
    1422:	f8 01       	movw	r30, r16
    1424:	95 83       	std	Z+5, r25	; 0x05
    1426:	84 83       	std	Z+4, r24	; 0x04
	udp->cksum = 0;
    1428:	17 82       	std	Z+7, r1	; 0x07
    142a:	16 82       	std	Z+6, r1	; 0x06
	udp->cksum = ip_cksum(len + IP_PROTOCOL_UDP, 
    142c:	67 5e       	subi	r22, 0xE7	; 231
    142e:	7f 4f       	sbci	r23, 0xFF	; 255
    1430:	80 e0       	ldi	r24, 0x00	; 0
    1432:	90 e0       	ldi	r25, 0x00	; 0
    1434:	ae 01       	movw	r20, r28
    1436:	46 5e       	subi	r20, 0xE6	; 230
    1438:	5f 4f       	sbci	r21, 0xFF	; 255
    143a:	97 01       	movw	r18, r14
    143c:	28 5f       	subi	r18, 0xF8	; 248
    143e:	3f 4f       	sbci	r19, 0xFF	; 255
    1440:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <ip_cksum>
    1444:	f8 01       	movw	r30, r16
    1446:	97 83       	std	Z+7, r25	; 0x07
    1448:	86 83       	std	Z+6, r24	; 0x06
		(uint8_t*)udp-8, len+8);

	return ip_send(frame, len);
    144a:	ce 01       	movw	r24, r28
    144c:	b7 01       	movw	r22, r14
    144e:	0e 94 6e 09 	call	0x12dc	; 0x12dc <ip_send>
}
    1452:	df 91       	pop	r29
    1454:	cf 91       	pop	r28
    1456:	1f 91       	pop	r17
    1458:	0f 91       	pop	r16
    145a:	ff 90       	pop	r15
    145c:	ef 90       	pop	r14
    145e:	08 95       	ret

00001460 <eth_reply>:
}

// send Ethernet frame back
void eth_reply(eth_frame_t *frame, uint16_t len)
{
	memcpy(frame->to_addr, frame->from_addr, 6);
    1460:	dc 01       	movw	r26, r24
    1462:	fc 01       	movw	r30, r24
    1464:	36 96       	adiw	r30, 0x06	; 6
    1466:	26 e0       	ldi	r18, 0x06	; 6
    1468:	01 90       	ld	r0, Z+
    146a:	0d 92       	st	X+, r0
    146c:	21 50       	subi	r18, 0x01	; 1
    146e:	e1 f7       	brne	.-8      	; 0x1468 <eth_reply+0x8>
	memcpy(frame->from_addr, mac_addr, 6);
    1470:	dc 01       	movw	r26, r24
    1472:	16 96       	adiw	r26, 0x06	; 6
    1474:	ec ed       	ldi	r30, 0xDC	; 220
    1476:	f2 e0       	ldi	r31, 0x02	; 2
    1478:	26 e0       	ldi	r18, 0x06	; 6
    147a:	01 90       	ld	r0, Z+
    147c:	0d 92       	st	X+, r0
    147e:	21 50       	subi	r18, 0x01	; 1
    1480:	e1 f7       	brne	.-8      	; 0x147a <eth_reply+0x1a>
	enc28j60_send_packet((void*)frame, len + 
    1482:	62 5f       	subi	r22, 0xF2	; 242
    1484:	7f 4f       	sbci	r23, 0xFF	; 255
    1486:	0e 94 d5 07 	call	0xfaa	; 0xfaa <enc28j60_send_packet>
		sizeof(eth_frame_t));
}
    148a:	08 95       	ret

0000148c <arp_filter>:
	return 0;
}

// process arp packet
void arp_filter(eth_frame_t *frame, uint16_t len)
{
    148c:	ef 92       	push	r14
    148e:	ff 92       	push	r15
    1490:	0f 93       	push	r16
    1492:	1f 93       	push	r17
    1494:	cf 93       	push	r28
    1496:	df 93       	push	r29
    1498:	ec 01       	movw	r28, r24
	arp_message_t *msg = (void*)(frame->data);

	if(len >= sizeof(arp_message_t))
    149a:	6c 31       	cpi	r22, 0x1C	; 28
    149c:	71 05       	cpc	r23, r1
    149e:	08 f4       	brcc	.+2      	; 0x14a2 <arp_filter+0x16>
    14a0:	9f c0       	rjmp	.+318    	; 0x15e0 <arp_filter+0x154>
}

// process arp packet
void arp_filter(eth_frame_t *frame, uint16_t len)
{
	arp_message_t *msg = (void*)(frame->data);
    14a2:	fc 01       	movw	r30, r24
    14a4:	3e 96       	adiw	r30, 0x0e	; 14

	if(len >= sizeof(arp_message_t))
	{
		if( (msg->hw_type == ARP_HW_TYPE_ETH) &&
    14a6:	8e 85       	ldd	r24, Y+14	; 0x0e
    14a8:	9f 85       	ldd	r25, Y+15	; 0x0f
    14aa:	21 e0       	ldi	r18, 0x01	; 1
    14ac:	80 30       	cpi	r24, 0x00	; 0
    14ae:	92 07       	cpc	r25, r18
    14b0:	09 f0       	breq	.+2      	; 0x14b4 <arp_filter+0x28>
    14b2:	96 c0       	rjmp	.+300    	; 0x15e0 <arp_filter+0x154>
    14b4:	82 81       	ldd	r24, Z+2	; 0x02
    14b6:	93 81       	ldd	r25, Z+3	; 0x03
    14b8:	88 30       	cpi	r24, 0x08	; 8
    14ba:	91 05       	cpc	r25, r1
    14bc:	09 f0       	breq	.+2      	; 0x14c0 <arp_filter+0x34>
    14be:	90 c0       	rjmp	.+288    	; 0x15e0 <arp_filter+0x154>
			(msg->proto_type == ARP_PROTO_TYPE_IP) &&
    14c0:	20 8d       	ldd	r18, Z+24	; 0x18
    14c2:	31 8d       	ldd	r19, Z+25	; 0x19
    14c4:	42 8d       	ldd	r20, Z+26	; 0x1a
    14c6:	53 8d       	ldd	r21, Z+27	; 0x1b
    14c8:	80 91 e2 02 	lds	r24, 0x02E2
    14cc:	90 91 e3 02 	lds	r25, 0x02E3
    14d0:	a0 91 e4 02 	lds	r26, 0x02E4
    14d4:	b0 91 e5 02 	lds	r27, 0x02E5
    14d8:	28 17       	cp	r18, r24
    14da:	39 07       	cpc	r19, r25
    14dc:	4a 07       	cpc	r20, r26
    14de:	5b 07       	cpc	r21, r27
    14e0:	09 f0       	breq	.+2      	; 0x14e4 <arp_filter+0x58>
    14e2:	7e c0       	rjmp	.+252    	; 0x15e0 <arp_filter+0x154>
			(msg->ip_addr_to == ip_addr) )
		{
			switch(msg->type)
    14e4:	86 81       	ldd	r24, Z+6	; 0x06
    14e6:	97 81       	ldd	r25, Z+7	; 0x07
    14e8:	a1 e0       	ldi	r26, 0x01	; 1
    14ea:	80 30       	cpi	r24, 0x00	; 0
    14ec:	9a 07       	cpc	r25, r26
    14ee:	31 f0       	breq	.+12     	; 0x14fc <arp_filter+0x70>
    14f0:	b2 e0       	ldi	r27, 0x02	; 2
    14f2:	80 30       	cpi	r24, 0x00	; 0
    14f4:	9b 07       	cpc	r25, r27
    14f6:	09 f0       	breq	.+2      	; 0x14fa <arp_filter+0x6e>
    14f8:	73 c0       	rjmp	.+230    	; 0x15e0 <arp_filter+0x154>
    14fa:	39 c0       	rjmp	.+114    	; 0x156e <arp_filter+0xe2>
			{
			case ARP_TYPE_REQUEST:
				msg->type = ARP_TYPE_RESPONSE;
    14fc:	80 e0       	ldi	r24, 0x00	; 0
    14fe:	92 e0       	ldi	r25, 0x02	; 2
    1500:	97 83       	std	Z+7, r25	; 0x07
    1502:	86 83       	std	Z+6, r24	; 0x06
				memcpy(msg->mac_addr_to, msg->mac_addr_from, 6);
    1504:	ce 01       	movw	r24, r28
    1506:	80 96       	adiw	r24, 0x20	; 32
    1508:	ae 01       	movw	r20, r28
    150a:	4a 5e       	subi	r20, 0xEA	; 234
    150c:	5f 4f       	sbci	r21, 0xFF	; 255
    150e:	26 e0       	ldi	r18, 0x06	; 6
    1510:	da 01       	movw	r26, r20
    1512:	0d 90       	ld	r0, X+
    1514:	ad 01       	movw	r20, r26
    1516:	dc 01       	movw	r26, r24
    1518:	0d 92       	st	X+, r0
    151a:	cd 01       	movw	r24, r26
    151c:	21 50       	subi	r18, 0x01	; 1
    151e:	c1 f7       	brne	.-16     	; 0x1510 <arp_filter+0x84>
				memcpy(msg->mac_addr_from, mac_addr, 6);
    1520:	cf 01       	movw	r24, r30
    1522:	08 96       	adiw	r24, 0x08	; 8
    1524:	4c ed       	ldi	r20, 0xDC	; 220
    1526:	52 e0       	ldi	r21, 0x02	; 2
    1528:	26 e0       	ldi	r18, 0x06	; 6
    152a:	da 01       	movw	r26, r20
    152c:	0d 90       	ld	r0, X+
    152e:	ad 01       	movw	r20, r26
    1530:	dc 01       	movw	r26, r24
    1532:	0d 92       	st	X+, r0
    1534:	cd 01       	movw	r24, r26
    1536:	21 50       	subi	r18, 0x01	; 1
    1538:	c1 f7       	brne	.-16     	; 0x152a <arp_filter+0x9e>
				msg->ip_addr_to = msg->ip_addr_from;
    153a:	86 85       	ldd	r24, Z+14	; 0x0e
    153c:	97 85       	ldd	r25, Z+15	; 0x0f
    153e:	a0 89       	ldd	r26, Z+16	; 0x10
    1540:	b1 89       	ldd	r27, Z+17	; 0x11
    1542:	80 8f       	std	Z+24, r24	; 0x18
    1544:	91 8f       	std	Z+25, r25	; 0x19
    1546:	a2 8f       	std	Z+26, r26	; 0x1a
    1548:	b3 8f       	std	Z+27, r27	; 0x1b
				msg->ip_addr_from = ip_addr;
    154a:	80 91 e2 02 	lds	r24, 0x02E2
    154e:	90 91 e3 02 	lds	r25, 0x02E3
    1552:	a0 91 e4 02 	lds	r26, 0x02E4
    1556:	b0 91 e5 02 	lds	r27, 0x02E5
    155a:	86 87       	std	Z+14, r24	; 0x0e
    155c:	97 87       	std	Z+15, r25	; 0x0f
    155e:	a0 8b       	std	Z+16, r26	; 0x10
    1560:	b1 8b       	std	Z+17, r27	; 0x11
				eth_reply(frame, sizeof(arp_message_t));
    1562:	ce 01       	movw	r24, r28
    1564:	6c e1       	ldi	r22, 0x1C	; 28
    1566:	70 e0       	ldi	r23, 0x00	; 0
    1568:	0e 94 30 0a 	call	0x1460	; 0x1460 <eth_reply>
				break;
    156c:	39 c0       	rjmp	.+114    	; 0x15e0 <arp_filter+0x154>
			case ARP_TYPE_RESPONSE:
				if(!arp_search_cache(msg->ip_addr_from))
    156e:	e6 84       	ldd	r14, Z+14	; 0x0e
    1570:	f7 84       	ldd	r15, Z+15	; 0x0f
    1572:	00 89       	ldd	r16, Z+16	; 0x10
    1574:	11 89       	ldd	r17, Z+17	; 0x11
    1576:	c8 01       	movw	r24, r16
    1578:	b7 01       	movw	r22, r14
    157a:	0e 94 bd 08 	call	0x117a	; 0x117a <arp_search_cache>
    157e:	00 97       	sbiw	r24, 0x00	; 0
    1580:	79 f5       	brne	.+94     	; 0x15e0 <arp_filter+0x154>
				{
					arp_cache[arp_cache_wr].ip_addr = msg->ip_addr_from;
    1582:	20 91 36 03 	lds	r18, 0x0336
    1586:	82 2f       	mov	r24, r18
    1588:	90 e0       	ldi	r25, 0x00	; 0
    158a:	fc 01       	movw	r30, r24
    158c:	ee 0f       	add	r30, r30
    158e:	ff 1f       	adc	r31, r31
    1590:	33 e0       	ldi	r19, 0x03	; 3
    1592:	88 0f       	add	r24, r24
    1594:	99 1f       	adc	r25, r25
    1596:	3a 95       	dec	r19
    1598:	e1 f7       	brne	.-8      	; 0x1592 <arp_filter+0x106>
    159a:	e8 0f       	add	r30, r24
    159c:	f9 1f       	adc	r31, r25
    159e:	e9 5c       	subi	r30, 0xC9	; 201
    15a0:	fa 4f       	sbci	r31, 0xFA	; 250
    15a2:	e0 82       	st	Z, r14
    15a4:	f1 82       	std	Z+1, r15	; 0x01
    15a6:	02 83       	std	Z+2, r16	; 0x02
    15a8:	13 83       	std	Z+3, r17	; 0x03
					memcpy(arp_cache[arp_cache_wr].mac_addr, msg->mac_addr_from, 6);
    15aa:	82 2f       	mov	r24, r18
    15ac:	90 e0       	ldi	r25, 0x00	; 0
    15ae:	fc 01       	movw	r30, r24
    15b0:	ee 0f       	add	r30, r30
    15b2:	ff 1f       	adc	r31, r31
    15b4:	b3 e0       	ldi	r27, 0x03	; 3
    15b6:	88 0f       	add	r24, r24
    15b8:	99 1f       	adc	r25, r25
    15ba:	ba 95       	dec	r27
    15bc:	e1 f7       	brne	.-8      	; 0x15b6 <arp_filter+0x12a>
    15be:	e8 0f       	add	r30, r24
    15c0:	f9 1f       	adc	r31, r25
    15c2:	e5 5c       	subi	r30, 0xC5	; 197
    15c4:	fa 4f       	sbci	r31, 0xFA	; 250
    15c6:	66 96       	adiw	r28, 0x16	; 22
    15c8:	86 e0       	ldi	r24, 0x06	; 6
    15ca:	09 90       	ld	r0, Y+
    15cc:	01 92       	st	Z+, r0
    15ce:	81 50       	subi	r24, 0x01	; 1
    15d0:	e1 f7       	brne	.-8      	; 0x15ca <arp_filter+0x13e>
					arp_cache_wr++;
    15d2:	2f 5f       	subi	r18, 0xFF	; 255
    15d4:	20 93 36 03 	sts	0x0336, r18
					if(arp_cache_wr == ARP_CACHE_SIZE)
    15d8:	23 30       	cpi	r18, 0x03	; 3
    15da:	11 f4       	brne	.+4      	; 0x15e0 <arp_filter+0x154>
						arp_cache_wr = 0;
    15dc:	10 92 36 03 	sts	0x0336, r1
				}
				break;
			}
		}
	}
}
    15e0:	df 91       	pop	r29
    15e2:	cf 91       	pop	r28
    15e4:	1f 91       	pop	r17
    15e6:	0f 91       	pop	r16
    15e8:	ff 90       	pop	r15
    15ea:	ef 90       	pop	r14
    15ec:	08 95       	ret

000015ee <ip_reply>:
}

// send IP packet back
// len is IP packet payload length
void ip_reply(eth_frame_t *frame, uint16_t len)
{
    15ee:	ef 92       	push	r14
    15f0:	ff 92       	push	r15
    15f2:	0f 93       	push	r16
    15f4:	1f 93       	push	r17
    15f6:	cf 93       	push	r28
    15f8:	df 93       	push	r29
    15fa:	7c 01       	movw	r14, r24
    15fc:	8b 01       	movw	r16, r22
	ip_packet_t *packet = (void*)(frame->data);
    15fe:	ec 01       	movw	r28, r24
    1600:	2e 96       	adiw	r28, 0x0e	; 14

	len += sizeof(ip_packet_t);
    1602:	0c 5e       	subi	r16, 0xEC	; 236
    1604:	1f 4f       	sbci	r17, 0xFF	; 255

	packet->total_len = htons(len);
    1606:	90 2f       	mov	r25, r16
    1608:	81 2f       	mov	r24, r17
    160a:	9b 83       	std	Y+3, r25	; 0x03
    160c:	8a 83       	std	Y+2, r24	; 0x02
	packet->fragment_id = 0;
    160e:	1d 82       	std	Y+5, r1	; 0x05
    1610:	1c 82       	std	Y+4, r1	; 0x04
	packet->flags_framgent_offset = 0;
    1612:	1f 82       	std	Y+7, r1	; 0x07
    1614:	1e 82       	std	Y+6, r1	; 0x06
	packet->ttl = IP_PACKET_TTL;
    1616:	80 e4       	ldi	r24, 0x40	; 64
    1618:	88 87       	std	Y+8, r24	; 0x08
	packet->cksum = 0;
    161a:	1b 86       	std	Y+11, r1	; 0x0b
    161c:	1a 86       	std	Y+10, r1	; 0x0a
	packet->to_addr = packet->from_addr;
    161e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1620:	9d 85       	ldd	r25, Y+13	; 0x0d
    1622:	ae 85       	ldd	r26, Y+14	; 0x0e
    1624:	bf 85       	ldd	r27, Y+15	; 0x0f
    1626:	88 8b       	std	Y+16, r24	; 0x10
    1628:	99 8b       	std	Y+17, r25	; 0x11
    162a:	aa 8b       	std	Y+18, r26	; 0x12
    162c:	bb 8b       	std	Y+19, r27	; 0x13
	packet->from_addr = ip_addr;
    162e:	80 91 e2 02 	lds	r24, 0x02E2
    1632:	90 91 e3 02 	lds	r25, 0x02E3
    1636:	a0 91 e4 02 	lds	r26, 0x02E4
    163a:	b0 91 e5 02 	lds	r27, 0x02E5
    163e:	8c 87       	std	Y+12, r24	; 0x0c
    1640:	9d 87       	std	Y+13, r25	; 0x0d
    1642:	ae 87       	std	Y+14, r26	; 0x0e
    1644:	bf 87       	std	Y+15, r27	; 0x0f
	packet->cksum = ip_cksum(0, (void*)packet, sizeof(ip_packet_t));
    1646:	60 e0       	ldi	r22, 0x00	; 0
    1648:	70 e0       	ldi	r23, 0x00	; 0
    164a:	cb 01       	movw	r24, r22
    164c:	ae 01       	movw	r20, r28
    164e:	24 e1       	ldi	r18, 0x14	; 20
    1650:	30 e0       	ldi	r19, 0x00	; 0
    1652:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <ip_cksum>
    1656:	9b 87       	std	Y+11, r25	; 0x0b
    1658:	8a 87       	std	Y+10, r24	; 0x0a

	eth_reply((void*)frame, len);
    165a:	c7 01       	movw	r24, r14
    165c:	b8 01       	movw	r22, r16
    165e:	0e 94 30 0a 	call	0x1460	; 0x1460 <eth_reply>
}
    1662:	df 91       	pop	r29
    1664:	cf 91       	pop	r28
    1666:	1f 91       	pop	r17
    1668:	0f 91       	pop	r16
    166a:	ff 90       	pop	r15
    166c:	ef 90       	pop	r14
    166e:	08 95       	ret

00001670 <icmp_filter>:
void icmp_filter(eth_frame_t *frame, uint16_t len)
{
	ip_packet_t *packet = (void*)frame->data;
	icmp_echo_packet_t *icmp = (void*)packet->data;

	if(len >= sizeof(icmp_echo_packet_t) )
    1670:	68 30       	cpi	r22, 0x08	; 8
    1672:	71 05       	cpc	r23, r1
    1674:	90 f0       	brcs	.+36     	; 0x169a <icmp_filter+0x2a>

// process ICMP packet
void icmp_filter(eth_frame_t *frame, uint16_t len)
{
	ip_packet_t *packet = (void*)frame->data;
	icmp_echo_packet_t *icmp = (void*)packet->data;
    1676:	fc 01       	movw	r30, r24
    1678:	b2 96       	adiw	r30, 0x22	; 34

	if(len >= sizeof(icmp_echo_packet_t) )
	{
		if(icmp->type == ICMP_TYPE_ECHO_RQ)
    167a:	dc 01       	movw	r26, r24
    167c:	92 96       	adiw	r26, 0x22	; 34
    167e:	2c 91       	ld	r18, X
    1680:	92 97       	sbiw	r26, 0x22	; 34
    1682:	28 30       	cpi	r18, 0x08	; 8
    1684:	51 f4       	brne	.+20     	; 0x169a <icmp_filter+0x2a>
		{
			icmp->type = ICMP_TYPE_ECHO_RPLY;
    1686:	92 96       	adiw	r26, 0x22	; 34
    1688:	1c 92       	st	X, r1
			icmp->cksum += 8; // update cksum
    168a:	22 81       	ldd	r18, Z+2	; 0x02
    168c:	33 81       	ldd	r19, Z+3	; 0x03
    168e:	28 5f       	subi	r18, 0xF8	; 248
    1690:	3f 4f       	sbci	r19, 0xFF	; 255
    1692:	33 83       	std	Z+3, r19	; 0x03
    1694:	22 83       	std	Z+2, r18	; 0x02
			ip_reply(frame, len);
    1696:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <ip_reply>
    169a:	08 95       	ret

0000169c <ip_filter>:
	eth_reply((void*)frame, len);
}

// process IP packet
void ip_filter(eth_frame_t *frame, uint16_t len)
{
    169c:	fc 01       	movw	r30, r24
	ip_packet_t *packet = (void*)(frame->data);
    169e:	dc 01       	movw	r26, r24
    16a0:	1e 96       	adiw	r26, 0x0e	; 14
	
	//if(len >= sizeof(ip_packet_t))
	//{
		if( (packet->ver_head_len == 0x45) &&
    16a2:	86 85       	ldd	r24, Z+14	; 0x0e
    16a4:	85 34       	cpi	r24, 0x45	; 69
    16a6:	59 f5       	brne	.+86     	; 0x16fe <ip_filter+0x62>
    16a8:	50 96       	adiw	r26, 0x10	; 16
    16aa:	6d 91       	ld	r22, X+
    16ac:	7d 91       	ld	r23, X+
    16ae:	8d 91       	ld	r24, X+
    16b0:	9c 91       	ld	r25, X
    16b2:	53 97       	sbiw	r26, 0x13	; 19
    16b4:	20 91 e2 02 	lds	r18, 0x02E2
    16b8:	30 91 e3 02 	lds	r19, 0x02E3
    16bc:	40 91 e4 02 	lds	r20, 0x02E4
    16c0:	50 91 e5 02 	lds	r21, 0x02E5
    16c4:	62 17       	cp	r22, r18
    16c6:	73 07       	cpc	r23, r19
    16c8:	84 07       	cpc	r24, r20
    16ca:	95 07       	cpc	r25, r21
    16cc:	c1 f4       	brne	.+48     	; 0x16fe <ip_filter+0x62>
			(packet->to_addr == ip_addr) )
		{
			len = ntohs(packet->total_len) - 
    16ce:	12 96       	adiw	r26, 0x02	; 2
    16d0:	6d 91       	ld	r22, X+
    16d2:	7c 91       	ld	r23, X
    16d4:	13 97       	sbiw	r26, 0x03	; 3
    16d6:	76 27       	eor	r23, r22
    16d8:	67 27       	eor	r22, r23
    16da:	76 27       	eor	r23, r22
    16dc:	64 51       	subi	r22, 0x14	; 20
    16de:	70 40       	sbci	r23, 0x00	; 0
				sizeof(ip_packet_t);

			switch(packet->protocol)
    16e0:	19 96       	adiw	r26, 0x09	; 9
    16e2:	8c 91       	ld	r24, X
    16e4:	19 97       	sbiw	r26, 0x09	; 9
    16e6:	81 30       	cpi	r24, 0x01	; 1
    16e8:	19 f0       	breq	.+6      	; 0x16f0 <ip_filter+0x54>
    16ea:	81 31       	cpi	r24, 0x11	; 17
    16ec:	41 f4       	brne	.+16     	; 0x16fe <ip_filter+0x62>
    16ee:	04 c0       	rjmp	.+8      	; 0x16f8 <ip_filter+0x5c>
			{
#ifdef WITH_ICMP
			case IP_PROTOCOL_ICMP:
				icmp_filter(frame, len);
    16f0:	cf 01       	movw	r24, r30
    16f2:	0e 94 38 0b 	call	0x1670	; 0x1670 <icmp_filter>
				break;
    16f6:	08 95       	ret
#endif
			case IP_PROTOCOL_UDP:
				udp_filter(frame, len);
    16f8:	cf 01       	movw	r24, r30
    16fa:	0e 94 6e 08 	call	0x10dc	; 0x10dc <udp_filter>
    16fe:	08 95       	ret

00001700 <eth_filter>:
		sizeof(eth_frame_t));
}

void eth_filter(eth_frame_t *frame, uint16_t len)
{
	if(len >= sizeof(eth_frame_t))
    1700:	6e 30       	cpi	r22, 0x0E	; 14
    1702:	71 05       	cpc	r23, r1
    1704:	98 f0       	brcs	.+38     	; 0x172c <eth_filter+0x2c>
	{
		switch(frame->type)
    1706:	fc 01       	movw	r30, r24
    1708:	24 85       	ldd	r18, Z+12	; 0x0c
    170a:	35 85       	ldd	r19, Z+13	; 0x0d
    170c:	28 30       	cpi	r18, 0x08	; 8
    170e:	31 05       	cpc	r19, r1
    1710:	49 f0       	breq	.+18     	; 0x1724 <eth_filter+0x24>
    1712:	f6 e0       	ldi	r31, 0x06	; 6
    1714:	28 30       	cpi	r18, 0x08	; 8
    1716:	3f 07       	cpc	r19, r31
    1718:	49 f4       	brne	.+18     	; 0x172c <eth_filter+0x2c>
		{
		case ETH_TYPE_ARP:
			arp_filter(frame, len - sizeof(eth_frame_t));
    171a:	6e 50       	subi	r22, 0x0E	; 14
    171c:	70 40       	sbci	r23, 0x00	; 0
    171e:	0e 94 46 0a 	call	0x148c	; 0x148c <arp_filter>
			break;
    1722:	08 95       	ret
		case ETH_TYPE_IP:
			ip_filter(frame, len - sizeof(eth_frame_t));
    1724:	6e 50       	subi	r22, 0x0E	; 14
    1726:	70 40       	sbci	r23, 0x00	; 0
    1728:	0e 94 4e 0b 	call	0x169c	; 0x169c <ip_filter>
    172c:	08 95       	ret

0000172e <lan_init>:
 * LAN
 */

void lan_init()
{
	enc28j60_init(mac_addr);
    172e:	8c ed       	ldi	r24, 0xDC	; 220
    1730:	92 e0       	ldi	r25, 0x02	; 2
    1732:	0e 94 68 07 	call	0xed0	; 0xed0 <enc28j60_init>
}
    1736:	08 95       	ret

00001738 <lan_poll>:
void lan_poll()
{
	uint16_t len;
	eth_frame_t *frame = (void*)net_buf;
	
	while((len = enc28j60_recv_packet(net_buf, sizeof(net_buf))))
    1738:	04 c0       	rjmp	.+8      	; 0x1742 <lan_poll+0xa>
		eth_filter(frame, len);
    173a:	87 e3       	ldi	r24, 0x37	; 55
    173c:	93 e0       	ldi	r25, 0x03	; 3
    173e:	0e 94 80 0b 	call	0x1700	; 0x1700 <eth_filter>
void lan_poll()
{
	uint16_t len;
	eth_frame_t *frame = (void*)net_buf;
	
	while((len = enc28j60_recv_packet(net_buf, sizeof(net_buf))))
    1742:	87 e3       	ldi	r24, 0x37	; 55
    1744:	93 e0       	ldi	r25, 0x03	; 3
    1746:	60 e0       	ldi	r22, 0x00	; 0
    1748:	72 e0       	ldi	r23, 0x02	; 2
    174a:	0e 94 11 08 	call	0x1022	; 0x1022 <enc28j60_recv_packet>
    174e:	bc 01       	movw	r22, r24
    1750:	00 97       	sbiw	r24, 0x00	; 0
    1752:	99 f7       	brne	.-26     	; 0x173a <lan_poll+0x2>
		eth_filter(frame, len);
}
    1754:	08 95       	ret

00001756 <ntp_request>:
#include "ntp.h"

uint8_t ntp_request(uint32_t srv_ip)
{
    1756:	cf 93       	push	r28
    1758:	df 93       	push	r29
	eth_frame_t *frame = (void*)net_buf;
    175a:	e7 e3       	ldi	r30, 0x37	; 55
    175c:	f3 e0       	ldi	r31, 0x03	; 3
	ip_packet_t *ip = (void*)(frame->data);
	udp_packet_t *udp = (void*)(ip->data);
	ntp_message_t *ntp =(void*)(udp->data);
    175e:	9f 01       	movw	r18, r30
    1760:	26 5d       	subi	r18, 0xD6	; 214
    1762:	3f 4f       	sbci	r19, 0xFF	; 255

	ip->to_addr = srv_ip;
    1764:	66 8f       	std	Z+30, r22	; 0x1e
    1766:	77 8f       	std	Z+31, r23	; 0x1f
    1768:	80 a3       	std	Z+32, r24	; 0x20
    176a:	91 a3       	std	Z+33, r25	; 0x21
	udp->to_port = NTP_SRV_PORT;
    176c:	80 e0       	ldi	r24, 0x00	; 0
    176e:	9b e7       	ldi	r25, 0x7B	; 123
    1770:	95 a3       	std	Z+37, r25	; 0x25
    1772:	84 a3       	std	Z+36, r24	; 0x24
	udp->from_port = NTP_LOCAL_PORT;
    1774:	88 e3       	ldi	r24, 0x38	; 56
    1776:	9c e6       	ldi	r25, 0x6C	; 108
    1778:	90 93 5a 03 	sts	0x035A, r25
    177c:	80 93 59 03 	sts	0x0359, r24

	memset(ntp, 0, sizeof(ntp_message_t));
    1780:	80 e3       	ldi	r24, 0x30	; 48
    1782:	e9 01       	movw	r28, r18
    1784:	19 92       	st	Y+, r1
    1786:	8a 95       	dec	r24
    1788:	e9 f7       	brne	.-6      	; 0x1784 <ntp_request+0x2e>
	ntp->status = 0x08;
    178a:	88 e0       	ldi	r24, 0x08	; 8
    178c:	80 93 61 03 	sts	0x0361, r24

	return udp_send(frame, sizeof(ntp_message_t));
    1790:	cf 01       	movw	r24, r30
    1792:	60 e3       	ldi	r22, 0x30	; 48
    1794:	70 e0       	ldi	r23, 0x00	; 0
    1796:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <udp_send>
}
    179a:	df 91       	pop	r29
    179c:	cf 91       	pop	r28
    179e:	08 95       	ret

000017a0 <ntp_parse_reply>:

uint32_t ntp_parse_reply(void *data, uint16_t len)
{
    17a0:	af 92       	push	r10
    17a2:	bf 92       	push	r11
    17a4:	cf 92       	push	r12
    17a6:	df 92       	push	r13
    17a8:	ef 92       	push	r14
    17aa:	ff 92       	push	r15
    17ac:	0f 93       	push	r16
    17ae:	1f 93       	push	r17
	ntp_message_t *ntp = data;
	uint32_t temp;

	if(len >= sizeof(ntp_message_t))
    17b0:	60 33       	cpi	r22, 0x30	; 48
    17b2:	71 05       	cpc	r23, r1
    17b4:	90 f1       	brcs	.+100    	; 0x181a <ntp_parse_reply+0x7a>
	{
		temp = ntp->xmit_timestamp.seconds;
    17b6:	fc 01       	movw	r30, r24
    17b8:	80 a5       	ldd	r24, Z+40	; 0x28
    17ba:	91 a5       	ldd	r25, Z+41	; 0x29
    17bc:	a2 a5       	ldd	r26, Z+42	; 0x2a
    17be:	b3 a5       	ldd	r27, Z+43	; 0x2b
		return (ntohl(temp) - 2208988800UL);
    17c0:	58 2f       	mov	r21, r24
    17c2:	44 27       	eor	r20, r20
    17c4:	33 27       	eor	r19, r19
    17c6:	22 27       	eor	r18, r18
    17c8:	eb 2e       	mov	r14, r27
    17ca:	ff 24       	eor	r15, r15
    17cc:	00 27       	eor	r16, r16
    17ce:	11 27       	eor	r17, r17
    17d0:	2e 29       	or	r18, r14
    17d2:	3f 29       	or	r19, r15
    17d4:	40 2b       	or	r20, r16
    17d6:	51 2b       	or	r21, r17
    17d8:	e9 2e       	mov	r14, r25
    17da:	fa 2e       	mov	r15, r26
    17dc:	0b 2f       	mov	r16, r27
    17de:	11 27       	eor	r17, r17
    17e0:	a1 2c       	mov	r10, r1
    17e2:	7f ef       	ldi	r23, 0xFF	; 255
    17e4:	b7 2e       	mov	r11, r23
    17e6:	c1 2c       	mov	r12, r1
    17e8:	d1 2c       	mov	r13, r1
    17ea:	ea 20       	and	r14, r10
    17ec:	fb 20       	and	r15, r11
    17ee:	0c 21       	and	r16, r12
    17f0:	1d 21       	and	r17, r13
    17f2:	2e 29       	or	r18, r14
    17f4:	3f 29       	or	r19, r15
    17f6:	40 2b       	or	r20, r16
    17f8:	51 2b       	or	r21, r17
    17fa:	ba 2f       	mov	r27, r26
    17fc:	a9 2f       	mov	r26, r25
    17fe:	98 2f       	mov	r25, r24
    1800:	88 27       	eor	r24, r24
    1802:	80 70       	andi	r24, 0x00	; 0
    1804:	90 70       	andi	r25, 0x00	; 0
    1806:	b0 70       	andi	r27, 0x00	; 0
    1808:	28 2b       	or	r18, r24
    180a:	39 2b       	or	r19, r25
    180c:	4a 2b       	or	r20, r26
    180e:	5b 2b       	or	r21, r27
    1810:	20 58       	subi	r18, 0x80	; 128
    1812:	3e 47       	sbci	r19, 0x7E	; 126
    1814:	4a 4a       	sbci	r20, 0xAA	; 170
    1816:	53 48       	sbci	r21, 0x83	; 131
    1818:	03 c0       	rjmp	.+6      	; 0x1820 <ntp_parse_reply+0x80>
	}
	return 0;
    181a:	20 e0       	ldi	r18, 0x00	; 0
    181c:	30 e0       	ldi	r19, 0x00	; 0
    181e:	a9 01       	movw	r20, r18
}
    1820:	b9 01       	movw	r22, r18
    1822:	ca 01       	movw	r24, r20
    1824:	1f 91       	pop	r17
    1826:	0f 91       	pop	r16
    1828:	ff 90       	pop	r15
    182a:	ef 90       	pop	r14
    182c:	df 90       	pop	r13
    182e:	cf 90       	pop	r12
    1830:	bf 90       	pop	r11
    1832:	af 90       	pop	r10
    1834:	08 95       	ret

00001836 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1836:	e0 91 21 03 	lds	r30, 0x0321
    183a:	f0 91 22 03 	lds	r31, 0x0322
    183e:	80 81       	ld	r24, Z
    1840:	88 23       	and	r24, r24
    1842:	19 f4       	brne	.+6      	; 0x184a <prvResetNextTaskUnblockTime+0x14>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1844:	8f ef       	ldi	r24, 0xFF	; 255
    1846:	9f ef       	ldi	r25, 0xFF	; 255
    1848:	0c c0       	rjmp	.+24     	; 0x1862 <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    184a:	e0 91 21 03 	lds	r30, 0x0321
    184e:	f0 91 22 03 	lds	r31, 0x0322
    1852:	05 80       	ldd	r0, Z+5	; 0x05
    1854:	f6 81       	ldd	r31, Z+6	; 0x06
    1856:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    1858:	06 80       	ldd	r0, Z+6	; 0x06
    185a:	f7 81       	ldd	r31, Z+7	; 0x07
    185c:	e0 2d       	mov	r30, r0
    185e:	82 81       	ldd	r24, Z+2	; 0x02
    1860:	93 81       	ldd	r25, Z+3	; 0x03
    1862:	90 93 ef 02 	sts	0x02EF, r25
    1866:	80 93 ee 02 	sts	0x02EE, r24
    186a:	08 95       	ret

0000186c <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    186c:	cf 92       	push	r12
    186e:	df 92       	push	r13
    1870:	ef 92       	push	r14
    1872:	ff 92       	push	r15
    1874:	0f 93       	push	r16
    1876:	1f 93       	push	r17
    1878:	df 93       	push	r29
    187a:	cf 93       	push	r28
    187c:	0f 92       	push	r0
    187e:	cd b7       	in	r28, 0x3d	; 61
    1880:	de b7       	in	r29, 0x3e	; 62

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1882:	80 91 f9 02 	lds	r24, 0x02F9
    1886:	88 23       	and	r24, r24
    1888:	09 f0       	breq	.+2      	; 0x188c <xTaskIncrementTick+0x20>
    188a:	a3 c0       	rjmp	.+326    	; 0x19d2 <xTaskIncrementTick+0x166>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    188c:	80 91 f6 02 	lds	r24, 0x02F6
    1890:	90 91 f7 02 	lds	r25, 0x02F7
    1894:	01 96       	adiw	r24, 0x01	; 1
    1896:	90 93 f7 02 	sts	0x02F7, r25
    189a:	80 93 f6 02 	sts	0x02F6, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    189e:	00 91 f6 02 	lds	r16, 0x02F6
    18a2:	10 91 f7 02 	lds	r17, 0x02F7

			if( xConstTickCount == ( TickType_t ) 0U )
    18a6:	01 15       	cp	r16, r1
    18a8:	11 05       	cpc	r17, r1
    18aa:	b9 f4       	brne	.+46     	; 0x18da <xTaskIncrementTick+0x6e>
			{
				taskSWITCH_DELAYED_LISTS();
    18ac:	80 91 21 03 	lds	r24, 0x0321
    18b0:	90 91 22 03 	lds	r25, 0x0322
    18b4:	20 91 1f 03 	lds	r18, 0x031F
    18b8:	30 91 20 03 	lds	r19, 0x0320
    18bc:	30 93 22 03 	sts	0x0322, r19
    18c0:	20 93 21 03 	sts	0x0321, r18
    18c4:	90 93 20 03 	sts	0x0320, r25
    18c8:	80 93 1f 03 	sts	0x031F, r24
    18cc:	80 91 f8 02 	lds	r24, 0x02F8
    18d0:	8f 5f       	subi	r24, 0xFF	; 255
    18d2:	80 93 f8 02 	sts	0x02F8, r24
    18d6:	0e 94 1b 0c 	call	0x1836	; 0x1836 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    18da:	80 91 ee 02 	lds	r24, 0x02EE
    18de:	90 91 ef 02 	lds	r25, 0x02EF
    18e2:	08 17       	cp	r16, r24
    18e4:	19 07       	cpc	r17, r25
    18e6:	08 f4       	brcc	.+2      	; 0x18ea <xTaskIncrementTick+0x7e>
    18e8:	5f c0       	rjmp	.+190    	; 0x19a8 <xTaskIncrementTick+0x13c>
    18ea:	40 e0       	ldi	r20, 0x00	; 0
    18ec:	01 c0       	rjmp	.+2      	; 0x18f0 <xTaskIncrementTick+0x84>
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
    18ee:	41 e0       	ldi	r20, 0x01	; 1
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    18f0:	e0 91 21 03 	lds	r30, 0x0321
    18f4:	f0 91 22 03 	lds	r31, 0x0322
    18f8:	80 81       	ld	r24, Z
    18fa:	88 23       	and	r24, r24
    18fc:	19 f4       	brne	.+6      	; 0x1904 <xTaskIncrementTick+0x98>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    18fe:	8f ef       	ldi	r24, 0xFF	; 255
    1900:	9f ef       	ldi	r25, 0xFF	; 255
    1902:	11 c0       	rjmp	.+34     	; 0x1926 <xTaskIncrementTick+0xba>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1904:	e0 91 21 03 	lds	r30, 0x0321
    1908:	f0 91 22 03 	lds	r31, 0x0322
    190c:	05 80       	ldd	r0, Z+5	; 0x05
    190e:	f6 81       	ldd	r31, Z+6	; 0x06
    1910:	e0 2d       	mov	r30, r0
    1912:	c6 80       	ldd	r12, Z+6	; 0x06
    1914:	d7 80       	ldd	r13, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1916:	d6 01       	movw	r26, r12
    1918:	12 96       	adiw	r26, 0x02	; 2
    191a:	8d 91       	ld	r24, X+
    191c:	9c 91       	ld	r25, X
    191e:	13 97       	sbiw	r26, 0x03	; 3

						if( xConstTickCount < xItemValue )
    1920:	08 17       	cp	r16, r24
    1922:	19 07       	cpc	r17, r25
    1924:	28 f4       	brcc	.+10     	; 0x1930 <xTaskIncrementTick+0xc4>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    1926:	90 93 ef 02 	sts	0x02EF, r25
    192a:	80 93 ee 02 	sts	0x02EE, r24
							break;
    192e:	3d c0       	rjmp	.+122    	; 0x19aa <xTaskIncrementTick+0x13e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1930:	82 e0       	ldi	r24, 0x02	; 2
    1932:	e8 2e       	mov	r14, r24
    1934:	f1 2c       	mov	r15, r1
    1936:	ec 0c       	add	r14, r12
    1938:	fd 1c       	adc	r15, r13
    193a:	c7 01       	movw	r24, r14
    193c:	49 83       	std	Y+1, r20	; 0x01
    193e:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1942:	f6 01       	movw	r30, r12
    1944:	84 89       	ldd	r24, Z+20	; 0x14
    1946:	95 89       	ldd	r25, Z+21	; 0x15
    1948:	49 81       	ldd	r20, Y+1	; 0x01
    194a:	00 97       	sbiw	r24, 0x00	; 0
    194c:	29 f0       	breq	.+10     	; 0x1958 <xTaskIncrementTick+0xec>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    194e:	c6 01       	movw	r24, r12
    1950:	0c 96       	adiw	r24, 0x0c	; 12
    1952:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <uxListRemove>
    1956:	49 81       	ldd	r20, Y+1	; 0x01
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    1958:	d6 01       	movw	r26, r12
    195a:	56 96       	adiw	r26, 0x16	; 22
    195c:	8c 91       	ld	r24, X
    195e:	56 97       	sbiw	r26, 0x16	; 22
    1960:	90 91 fa 02 	lds	r25, 0x02FA
    1964:	98 17       	cp	r25, r24
    1966:	10 f4       	brcc	.+4      	; 0x196c <xTaskIncrementTick+0x100>
    1968:	80 93 fa 02 	sts	0x02FA, r24
    196c:	90 e0       	ldi	r25, 0x00	; 0
    196e:	9c 01       	movw	r18, r24
    1970:	b3 e0       	ldi	r27, 0x03	; 3
    1972:	22 0f       	add	r18, r18
    1974:	33 1f       	adc	r19, r19
    1976:	ba 95       	dec	r27
    1978:	e1 f7       	brne	.-8      	; 0x1972 <xTaskIncrementTick+0x106>
    197a:	28 0f       	add	r18, r24
    197c:	39 1f       	adc	r19, r25
    197e:	c9 01       	movw	r24, r18
    1980:	85 50       	subi	r24, 0x05	; 5
    1982:	9d 4f       	sbci	r25, 0xFD	; 253
    1984:	b7 01       	movw	r22, r14
    1986:	49 83       	std	Y+1, r20	; 0x01
    1988:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    198c:	e0 91 f3 02 	lds	r30, 0x02F3
    1990:	f0 91 f4 02 	lds	r31, 0x02F4
    1994:	d6 01       	movw	r26, r12
    1996:	56 96       	adiw	r26, 0x16	; 22
    1998:	9c 91       	ld	r25, X
    199a:	56 97       	sbiw	r26, 0x16	; 22
    199c:	86 89       	ldd	r24, Z+22	; 0x16
    199e:	49 81       	ldd	r20, Y+1	; 0x01
    19a0:	98 17       	cp	r25, r24
    19a2:	08 f0       	brcs	.+2      	; 0x19a6 <xTaskIncrementTick+0x13a>
    19a4:	a4 cf       	rjmp	.-184    	; 0x18ee <xTaskIncrementTick+0x82>
    19a6:	a4 cf       	rjmp	.-184    	; 0x18f0 <xTaskIncrementTick+0x84>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    19a8:	40 e0       	ldi	r20, 0x00	; 0
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    19aa:	e0 91 f3 02 	lds	r30, 0x02F3
    19ae:	f0 91 f4 02 	lds	r31, 0x02F4
    19b2:	86 89       	ldd	r24, Z+22	; 0x16
    19b4:	90 e0       	ldi	r25, 0x00	; 0
    19b6:	fc 01       	movw	r30, r24
    19b8:	a3 e0       	ldi	r26, 0x03	; 3
    19ba:	ee 0f       	add	r30, r30
    19bc:	ff 1f       	adc	r31, r31
    19be:	aa 95       	dec	r26
    19c0:	e1 f7       	brne	.-8      	; 0x19ba <xTaskIncrementTick+0x14e>
    19c2:	e8 0f       	add	r30, r24
    19c4:	f9 1f       	adc	r31, r25
    19c6:	e5 50       	subi	r30, 0x05	; 5
    19c8:	fd 4f       	sbci	r31, 0xFD	; 253
    19ca:	80 81       	ld	r24, Z
    19cc:	82 30       	cpi	r24, 0x02	; 2
    19ce:	40 f4       	brcc	.+16     	; 0x19e0 <xTaskIncrementTick+0x174>
    19d0:	08 c0       	rjmp	.+16     	; 0x19e2 <xTaskIncrementTick+0x176>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    19d2:	80 91 23 03 	lds	r24, 0x0323
    19d6:	8f 5f       	subi	r24, 0xFF	; 255
    19d8:	80 93 23 03 	sts	0x0323, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    19dc:	40 e0       	ldi	r20, 0x00	; 0
    19de:	01 c0       	rjmp	.+2      	; 0x19e2 <xTaskIncrementTick+0x176>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    19e0:	41 e0       	ldi	r20, 0x01	; 1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    19e2:	80 91 f5 02 	lds	r24, 0x02F5
    19e6:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
    19e8:	41 e0       	ldi	r20, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    19ea:	84 2f       	mov	r24, r20
    19ec:	0f 90       	pop	r0
    19ee:	cf 91       	pop	r28
    19f0:	df 91       	pop	r29
    19f2:	1f 91       	pop	r17
    19f4:	0f 91       	pop	r16
    19f6:	ff 90       	pop	r15
    19f8:	ef 90       	pop	r14
    19fa:	df 90       	pop	r13
    19fc:	cf 90       	pop	r12
    19fe:	08 95       	ret

00001a00 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1a00:	80 91 f9 02 	lds	r24, 0x02F9
    1a04:	88 23       	and	r24, r24
    1a06:	21 f0       	breq	.+8      	; 0x1a10 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1a08:	81 e0       	ldi	r24, 0x01	; 1
    1a0a:	80 93 f5 02 	sts	0x02F5, r24
    1a0e:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1a10:	10 92 f5 02 	sts	0x02F5, r1
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    1a14:	05 c0       	rjmp	.+10     	; 0x1a20 <vTaskSwitchContext+0x20>
    1a16:	80 91 fa 02 	lds	r24, 0x02FA
    1a1a:	81 50       	subi	r24, 0x01	; 1
    1a1c:	80 93 fa 02 	sts	0x02FA, r24
    1a20:	80 91 fa 02 	lds	r24, 0x02FA
    1a24:	90 e0       	ldi	r25, 0x00	; 0
    1a26:	fc 01       	movw	r30, r24
    1a28:	73 e0       	ldi	r23, 0x03	; 3
    1a2a:	ee 0f       	add	r30, r30
    1a2c:	ff 1f       	adc	r31, r31
    1a2e:	7a 95       	dec	r23
    1a30:	e1 f7       	brne	.-8      	; 0x1a2a <vTaskSwitchContext+0x2a>
    1a32:	e8 0f       	add	r30, r24
    1a34:	f9 1f       	adc	r31, r25
    1a36:	e5 50       	subi	r30, 0x05	; 5
    1a38:	fd 4f       	sbci	r31, 0xFD	; 253
    1a3a:	80 81       	ld	r24, Z
    1a3c:	88 23       	and	r24, r24
    1a3e:	59 f3       	breq	.-42     	; 0x1a16 <vTaskSwitchContext+0x16>
    1a40:	80 91 fa 02 	lds	r24, 0x02FA
    1a44:	90 e0       	ldi	r25, 0x00	; 0
    1a46:	9c 01       	movw	r18, r24
    1a48:	63 e0       	ldi	r22, 0x03	; 3
    1a4a:	22 0f       	add	r18, r18
    1a4c:	33 1f       	adc	r19, r19
    1a4e:	6a 95       	dec	r22
    1a50:	e1 f7       	brne	.-8      	; 0x1a4a <vTaskSwitchContext+0x4a>
    1a52:	28 0f       	add	r18, r24
    1a54:	39 1f       	adc	r19, r25
    1a56:	f9 01       	movw	r30, r18
    1a58:	e5 50       	subi	r30, 0x05	; 5
    1a5a:	fd 4f       	sbci	r31, 0xFD	; 253
    1a5c:	a1 81       	ldd	r26, Z+1	; 0x01
    1a5e:	b2 81       	ldd	r27, Z+2	; 0x02
    1a60:	12 96       	adiw	r26, 0x02	; 2
    1a62:	0d 90       	ld	r0, X+
    1a64:	bc 91       	ld	r27, X
    1a66:	a0 2d       	mov	r26, r0
    1a68:	b2 83       	std	Z+2, r27	; 0x02
    1a6a:	a1 83       	std	Z+1, r26	; 0x01
    1a6c:	22 50       	subi	r18, 0x02	; 2
    1a6e:	3d 4f       	sbci	r19, 0xFD	; 253
    1a70:	a2 17       	cp	r26, r18
    1a72:	b3 07       	cpc	r27, r19
    1a74:	31 f4       	brne	.+12     	; 0x1a82 <vTaskSwitchContext+0x82>
    1a76:	12 96       	adiw	r26, 0x02	; 2
    1a78:	2d 91       	ld	r18, X+
    1a7a:	3c 91       	ld	r19, X
    1a7c:	13 97       	sbiw	r26, 0x03	; 3
    1a7e:	32 83       	std	Z+2, r19	; 0x02
    1a80:	21 83       	std	Z+1, r18	; 0x01
    1a82:	fc 01       	movw	r30, r24
    1a84:	53 e0       	ldi	r21, 0x03	; 3
    1a86:	ee 0f       	add	r30, r30
    1a88:	ff 1f       	adc	r31, r31
    1a8a:	5a 95       	dec	r21
    1a8c:	e1 f7       	brne	.-8      	; 0x1a86 <vTaskSwitchContext+0x86>
    1a8e:	e8 0f       	add	r30, r24
    1a90:	f9 1f       	adc	r31, r25
    1a92:	e5 50       	subi	r30, 0x05	; 5
    1a94:	fd 4f       	sbci	r31, 0xFD	; 253
    1a96:	01 80       	ldd	r0, Z+1	; 0x01
    1a98:	f2 81       	ldd	r31, Z+2	; 0x02
    1a9a:	e0 2d       	mov	r30, r0
    1a9c:	86 81       	ldd	r24, Z+6	; 0x06
    1a9e:	97 81       	ldd	r25, Z+7	; 0x07
    1aa0:	90 93 f4 02 	sts	0x02F4, r25
    1aa4:	80 93 f3 02 	sts	0x02F3, r24
    1aa8:	08 95       	ret

00001aaa <vPortYieldFromTick>:
	vTaskIncrementTick();
	vTaskSwitchContext();
	portRESTORE_CONTEXT();
*/

	portSAVE_CONTEXT();
    1aaa:	0f 92       	push	r0
    1aac:	0f b6       	in	r0, 0x3f	; 63
    1aae:	f8 94       	cli
    1ab0:	0f 92       	push	r0
    1ab2:	0b b6       	in	r0, 0x3b	; 59
    1ab4:	0f 92       	push	r0
    1ab6:	0c b6       	in	r0, 0x3c	; 60
    1ab8:	0f 92       	push	r0
    1aba:	1f 92       	push	r1
    1abc:	11 24       	eor	r1, r1
    1abe:	2f 92       	push	r2
    1ac0:	3f 92       	push	r3
    1ac2:	4f 92       	push	r4
    1ac4:	5f 92       	push	r5
    1ac6:	6f 92       	push	r6
    1ac8:	7f 92       	push	r7
    1aca:	8f 92       	push	r8
    1acc:	9f 92       	push	r9
    1ace:	af 92       	push	r10
    1ad0:	bf 92       	push	r11
    1ad2:	cf 92       	push	r12
    1ad4:	df 92       	push	r13
    1ad6:	ef 92       	push	r14
    1ad8:	ff 92       	push	r15
    1ada:	0f 93       	push	r16
    1adc:	1f 93       	push	r17
    1ade:	2f 93       	push	r18
    1ae0:	3f 93       	push	r19
    1ae2:	4f 93       	push	r20
    1ae4:	5f 93       	push	r21
    1ae6:	6f 93       	push	r22
    1ae8:	7f 93       	push	r23
    1aea:	8f 93       	push	r24
    1aec:	9f 93       	push	r25
    1aee:	af 93       	push	r26
    1af0:	bf 93       	push	r27
    1af2:	cf 93       	push	r28
    1af4:	df 93       	push	r29
    1af6:	ef 93       	push	r30
    1af8:	ff 93       	push	r31
    1afa:	a0 91 f3 02 	lds	r26, 0x02F3
    1afe:	b0 91 f4 02 	lds	r27, 0x02F4
    1b02:	0d b6       	in	r0, 0x3d	; 61
    1b04:	0d 92       	st	X+, r0
    1b06:	0e b6       	in	r0, 0x3e	; 62
    1b08:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1b0a:	0e 94 36 0c 	call	0x186c	; 0x186c <xTaskIncrementTick>
    1b0e:	88 23       	and	r24, r24
    1b10:	11 f0       	breq	.+4      	; 0x1b16 <vPortYieldFromTick+0x6c>
	{
		vTaskSwitchContext();
    1b12:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1b16:	a0 91 f3 02 	lds	r26, 0x02F3
    1b1a:	b0 91 f4 02 	lds	r27, 0x02F4
    1b1e:	cd 91       	ld	r28, X+
    1b20:	cd bf       	out	0x3d, r28	; 61
    1b22:	dd 91       	ld	r29, X+
    1b24:	de bf       	out	0x3e, r29	; 62
    1b26:	ff 91       	pop	r31
    1b28:	ef 91       	pop	r30
    1b2a:	df 91       	pop	r29
    1b2c:	cf 91       	pop	r28
    1b2e:	bf 91       	pop	r27
    1b30:	af 91       	pop	r26
    1b32:	9f 91       	pop	r25
    1b34:	8f 91       	pop	r24
    1b36:	7f 91       	pop	r23
    1b38:	6f 91       	pop	r22
    1b3a:	5f 91       	pop	r21
    1b3c:	4f 91       	pop	r20
    1b3e:	3f 91       	pop	r19
    1b40:	2f 91       	pop	r18
    1b42:	1f 91       	pop	r17
    1b44:	0f 91       	pop	r16
    1b46:	ff 90       	pop	r15
    1b48:	ef 90       	pop	r14
    1b4a:	df 90       	pop	r13
    1b4c:	cf 90       	pop	r12
    1b4e:	bf 90       	pop	r11
    1b50:	af 90       	pop	r10
    1b52:	9f 90       	pop	r9
    1b54:	8f 90       	pop	r8
    1b56:	7f 90       	pop	r7
    1b58:	6f 90       	pop	r6
    1b5a:	5f 90       	pop	r5
    1b5c:	4f 90       	pop	r4
    1b5e:	3f 90       	pop	r3
    1b60:	2f 90       	pop	r2
    1b62:	1f 90       	pop	r1
    1b64:	0f 90       	pop	r0
    1b66:	0c be       	out	0x3c, r0	; 60
    1b68:	0f 90       	pop	r0
    1b6a:	0b be       	out	0x3b, r0	; 59
    1b6c:	0f 90       	pop	r0
    1b6e:	0f be       	out	0x3f, r0	; 63
    1b70:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1b72:	08 95       	ret

00001b74 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void TIMER_COMPARE_SIG( void ) __attribute__ ( ( signal, naked ) );				//FreeRTOS.org V7.6.0 +   SIG_OUTPUT_COMPARE1A  TIMER_COMPARE_SIG
	void TIMER_COMPARE_SIG( void )
	{
		vPortYieldFromTick();
    1b74:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYieldFromTick>
		asm volatile ( "reti" );
    1b78:	18 95       	reti

00001b7a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1b7a:	cf 93       	push	r28
    1b7c:	df 93       	push	r29
    1b7e:	9c 01       	movw	r18, r24
    1b80:	db 01       	movw	r26, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1b82:	fc 01       	movw	r30, r24
    1b84:	c1 81       	ldd	r28, Z+1	; 0x01
    1b86:	d2 81       	ldd	r29, Z+2	; 0x02

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1b88:	13 96       	adiw	r26, 0x03	; 3
    1b8a:	dc 93       	st	X, r29
    1b8c:	ce 93       	st	-X, r28
    1b8e:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1b90:	8c 81       	ldd	r24, Y+4	; 0x04
    1b92:	9d 81       	ldd	r25, Y+5	; 0x05
    1b94:	15 96       	adiw	r26, 0x05	; 5
    1b96:	9c 93       	st	X, r25
    1b98:	8e 93       	st	-X, r24
    1b9a:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1b9c:	8c 81       	ldd	r24, Y+4	; 0x04
    1b9e:	9d 81       	ldd	r25, Y+5	; 0x05
    1ba0:	fc 01       	movw	r30, r24
    1ba2:	73 83       	std	Z+3, r23	; 0x03
    1ba4:	62 83       	std	Z+2, r22	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1ba6:	7d 83       	std	Y+5, r23	; 0x05
    1ba8:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1baa:	19 96       	adiw	r26, 0x09	; 9
    1bac:	3c 93       	st	X, r19
    1bae:	2e 93       	st	-X, r18
    1bb0:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    1bb2:	f9 01       	movw	r30, r18
    1bb4:	80 81       	ld	r24, Z
    1bb6:	8f 5f       	subi	r24, 0xFF	; 255
    1bb8:	80 83       	st	Z, r24
}
    1bba:	df 91       	pop	r29
    1bbc:	cf 91       	pop	r28
    1bbe:	08 95       	ret

00001bc0 <uxListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1bc0:	cf 93       	push	r28
    1bc2:	df 93       	push	r29
    1bc4:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1bc6:	a0 85       	ldd	r26, Z+8	; 0x08
    1bc8:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1bca:	82 81       	ldd	r24, Z+2	; 0x02
    1bcc:	93 81       	ldd	r25, Z+3	; 0x03
    1bce:	24 81       	ldd	r18, Z+4	; 0x04
    1bd0:	35 81       	ldd	r19, Z+5	; 0x05
    1bd2:	ec 01       	movw	r28, r24
    1bd4:	3d 83       	std	Y+5, r19	; 0x05
    1bd6:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1bd8:	c4 81       	ldd	r28, Z+4	; 0x04
    1bda:	d5 81       	ldd	r29, Z+5	; 0x05
    1bdc:	9b 83       	std	Y+3, r25	; 0x03
    1bde:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1be0:	11 96       	adiw	r26, 0x01	; 1
    1be2:	8d 91       	ld	r24, X+
    1be4:	9c 91       	ld	r25, X
    1be6:	12 97       	sbiw	r26, 0x02	; 2
    1be8:	8e 17       	cp	r24, r30
    1bea:	9f 07       	cpc	r25, r31
    1bec:	21 f4       	brne	.+8      	; 0x1bf6 <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1bee:	12 96       	adiw	r26, 0x02	; 2
    1bf0:	dc 93       	st	X, r29
    1bf2:	ce 93       	st	-X, r28
    1bf4:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1bf6:	11 86       	std	Z+9, r1	; 0x09
    1bf8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1bfa:	8c 91       	ld	r24, X
    1bfc:	81 50       	subi	r24, 0x01	; 1
    1bfe:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1c00:	df 91       	pop	r29
    1c02:	cf 91       	pop	r28
    1c04:	08 95       	ret

00001c06 <InitADCEx>:
		Call it at program startup.

********************************************************************/
void InitADCEx()
{
	SPIInit();
    1c06:	0e 94 43 13 	call	0x2686	; 0x2686 <SPIInit>
}
    1c0a:	08 95       	ret

00001c0c <ReadADCEx>:
		Since the ADCs are 12 bit the return value is between
		0-4095 (Including both)

********************************************************************/
uint16_t ReadADCEx(uint8_t ch)
{
    1c0c:	1f 93       	push	r17
    1c0e:	18 2f       	mov	r17, r24
	uint8_t byte,data_high,data_low;

	byte=0b00000110;

	if(ch>3)
    1c10:	84 30       	cpi	r24, 0x04	; 4
    1c12:	10 f4       	brcc	.+4      	; 0x1c18 <ReadADCEx+0xc>
********************************************************************/
uint16_t ReadADCEx(uint8_t ch)
{
	uint8_t byte,data_high,data_low;

	byte=0b00000110;
    1c14:	86 e0       	ldi	r24, 0x06	; 6
    1c16:	01 c0       	rjmp	.+2      	; 0x1c1a <ReadADCEx+0xe>

	if(ch>3)
		byte|=0b00000001;
    1c18:	87 e0       	ldi	r24, 0x07	; 7

	CS_LOW();
    1c1a:	28 98       	cbi	0x05, 0	; 5
//	_delay_ms(2000);
	
	SPIWrite(byte);
    1c1c:	0e 94 4d 13 	call	0x269a	; 0x269a <SPIWrite>

	byte=ch<<6;

	data_high=SPIWrite(byte);
    1c20:	81 2f       	mov	r24, r17
    1c22:	82 95       	swap	r24
    1c24:	88 0f       	add	r24, r24
    1c26:	88 0f       	add	r24, r24
    1c28:	80 7c       	andi	r24, 0xC0	; 192
    1c2a:	0e 94 4d 13 	call	0x269a	; 0x269a <SPIWrite>
    1c2e:	18 2f       	mov	r17, r24

	data_high&=0b00001111;

	data_low=SPIWrite(0xFF);
    1c30:	8f ef       	ldi	r24, 0xFF	; 255
    1c32:	0e 94 4d 13 	call	0x269a	; 0x269a <SPIWrite>

	CS_HIGH();
    1c36:	28 9a       	sbi	0x05, 0	; 5
//	_delay_ms(2000);
	return ((data_high<<8)|data_low);
    1c38:	51 2f       	mov	r21, r17
    1c3a:	5f 70       	andi	r21, 0x0F	; 15
    1c3c:	40 e0       	ldi	r20, 0x00	; 0
    1c3e:	28 2f       	mov	r18, r24
    1c40:	30 e0       	ldi	r19, 0x00	; 0
    1c42:	24 2b       	or	r18, r20
    1c44:	35 2b       	or	r19, r21
}
    1c46:	c9 01       	movw	r24, r18
    1c48:	1f 91       	pop	r17
    1c4a:	08 95       	ret

00001c4c <InitUART0>:
//UBRRL = 0x6B;
//UBRRH = HI(bauddivider);
//UBRRH = 0x00;

void InitUART0(unsigned int BAUD, char CharacterSize, char StopBits, char Parity, char Mode)
{
    1c4c:	ef 92       	push	r14
    1c4e:	ff 92       	push	r15
    1c50:	0f 93       	push	r16
    1c52:	1f 93       	push	r17
    1c54:	16 2f       	mov	r17, r22
    1c56:	e4 2e       	mov	r14, r20
    1c58:	f2 2e       	mov	r15, r18

//Stop Bits
//	1  -  1-bit
//	2  -  2-bit

UCSR0A = 0;
    1c5a:	10 92 c0 00 	sts	0x00C0, r1
// Bit 1  U2X : Double the USART Transmission Speed 
// Bit 0  MPCM: Multi-processor Communication Mode 



UCSR0B = 0<<RXCIE0|0<<TXCIE0|0<<UDRIE0|0<<RXEN0|1<<TXEN0|0<<RXB80|0<<TXB80;
    1c5e:	28 e0       	ldi	r18, 0x08	; 8
    1c60:	20 93 c1 00 	sts	0x00C1, r18
// Bit 0    UCPOL: Clock Polarity

	
long int UBBR0=0;

switch (Mode) 
    1c64:	01 30       	cpi	r16, 0x01	; 1
    1c66:	b1 f0       	breq	.+44     	; 0x1c94 <InitUART0+0x48>
    1c68:	01 30       	cpi	r16, 0x01	; 1
    1c6a:	30 f0       	brcs	.+12     	; 0x1c78 <InitUART0+0x2c>
    1c6c:	02 30       	cpi	r16, 0x02	; 2
    1c6e:	11 f1       	breq	.+68     	; 0x1cb4 <InitUART0+0x68>
    1c70:	03 30       	cpi	r16, 0x03	; 3
    1c72:	09 f0       	breq	.+2      	; 0x1c76 <InitUART0+0x2a>
    1c74:	50 c0       	rjmp	.+160    	; 0x1d16 <InitUART0+0xca>
    1c76:	37 c0       	rjmp	.+110    	; 0x1ce6 <InitUART0+0x9a>
	{ 
		case 0: UBBR0 = F_CPU/16/BAUD-1; 						UCSR0C &= ~(0<<UMSEL01);	UCSR0C &= ~(0<<UMSEL00);	break;		//	
    1c78:	9c 01       	movw	r18, r24
    1c7a:	40 e0       	ldi	r20, 0x00	; 0
    1c7c:	50 e0       	ldi	r21, 0x00	; 0
    1c7e:	60 eb       	ldi	r22, 0xB0	; 176
    1c80:	71 e7       	ldi	r23, 0x71	; 113
    1c82:	8b e0       	ldi	r24, 0x0B	; 11
    1c84:	90 e0       	ldi	r25, 0x00	; 0
    1c86:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    1c8a:	21 50       	subi	r18, 0x01	; 1
    1c8c:	30 40       	sbci	r19, 0x00	; 0
    1c8e:	40 40       	sbci	r20, 0x00	; 0
    1c90:	50 40       	sbci	r21, 0x00	; 0
    1c92:	22 c0       	rjmp	.+68     	; 0x1cd8 <InitUART0+0x8c>
	  	case 1:	UBBR0 = F_CPU/8/BAUD-1;  						UCSR0C &= ~(0<<UMSEL01);	UCSR0C |= 1<<UMSEL00;		break;		//	
    1c94:	9c 01       	movw	r18, r24
    1c96:	40 e0       	ldi	r20, 0x00	; 0
    1c98:	50 e0       	ldi	r21, 0x00	; 0
    1c9a:	60 e6       	ldi	r22, 0x60	; 96
    1c9c:	73 ee       	ldi	r23, 0xE3	; 227
    1c9e:	86 e1       	ldi	r24, 0x16	; 22
    1ca0:	90 e0       	ldi	r25, 0x00	; 0
    1ca2:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    1ca6:	21 50       	subi	r18, 0x01	; 1
    1ca8:	30 40       	sbci	r19, 0x00	; 0
    1caa:	40 40       	sbci	r20, 0x00	; 0
    1cac:	50 40       	sbci	r21, 0x00	; 0
    1cae:	80 91 c2 00 	lds	r24, 0x00C2
    1cb2:	29 c0       	rjmp	.+82     	; 0x1d06 <InitUART0+0xba>
	  	case 2: UBBR0 = F_CPU/8/BAUD-1; 	UCSR0A |= 1<<U2X0;	UCSR0C &= ~(0<<UMSEL01);	UCSR0C &= ~(0<<UMSEL00);	break;		//	   
    1cb4:	9c 01       	movw	r18, r24
    1cb6:	40 e0       	ldi	r20, 0x00	; 0
    1cb8:	50 e0       	ldi	r21, 0x00	; 0
    1cba:	60 e6       	ldi	r22, 0x60	; 96
    1cbc:	73 ee       	ldi	r23, 0xE3	; 227
    1cbe:	86 e1       	ldi	r24, 0x16	; 22
    1cc0:	90 e0       	ldi	r25, 0x00	; 0
    1cc2:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    1cc6:	21 50       	subi	r18, 0x01	; 1
    1cc8:	30 40       	sbci	r19, 0x00	; 0
    1cca:	40 40       	sbci	r20, 0x00	; 0
    1ccc:	50 40       	sbci	r21, 0x00	; 0
    1cce:	80 91 c0 00 	lds	r24, 0x00C0
    1cd2:	82 60       	ori	r24, 0x02	; 2
    1cd4:	80 93 c0 00 	sts	0x00C0, r24
    1cd8:	80 91 c2 00 	lds	r24, 0x00C2
    1cdc:	80 93 c2 00 	sts	0x00C2, r24
    1ce0:	80 91 c2 00 	lds	r24, 0x00C2
    1ce4:	15 c0       	rjmp	.+42     	; 0x1d10 <InitUART0+0xc4>
	  	case 3: UBBR0 = F_CPU/2/BAUD-1;  						UCSR0C |= 1<<UMSEL01;	 	UCSR0C |= 1<<UMSEL00;		break;		//	SPI
    1ce6:	9c 01       	movw	r18, r24
    1ce8:	40 e0       	ldi	r20, 0x00	; 0
    1cea:	50 e0       	ldi	r21, 0x00	; 0
    1cec:	60 e8       	ldi	r22, 0x80	; 128
    1cee:	7d e8       	ldi	r23, 0x8D	; 141
    1cf0:	8b e5       	ldi	r24, 0x5B	; 91
    1cf2:	90 e0       	ldi	r25, 0x00	; 0
    1cf4:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    1cf8:	21 50       	subi	r18, 0x01	; 1
    1cfa:	30 40       	sbci	r19, 0x00	; 0
    1cfc:	40 40       	sbci	r20, 0x00	; 0
    1cfe:	50 40       	sbci	r21, 0x00	; 0
    1d00:	80 91 c2 00 	lds	r24, 0x00C2
    1d04:	80 68       	ori	r24, 0x80	; 128
    1d06:	80 93 c2 00 	sts	0x00C2, r24
    1d0a:	80 91 c2 00 	lds	r24, 0x00C2
    1d0e:	80 64       	ori	r24, 0x40	; 64
    1d10:	80 93 c2 00 	sts	0x00C2, r24
    1d14:	03 c0       	rjmp	.+6      	; 0x1d1c <InitUART0+0xd0>
// Bit 3    USBS: Stop Bit Select
// Bit 2:1  UCSZ1:0: Character Size
// Bit 0    UCPOL: Clock Polarity

	
long int UBBR0=0;
    1d16:	20 e0       	ldi	r18, 0x00	; 0
    1d18:	30 e0       	ldi	r19, 0x00	; 0
    1d1a:	a9 01       	movw	r20, r18
	  	case 2: UBBR0 = F_CPU/8/BAUD-1; 	UCSR0A |= 1<<U2X0;	UCSR0C &= ~(0<<UMSEL01);	UCSR0C &= ~(0<<UMSEL00);	break;		//	   
	  	case 3: UBBR0 = F_CPU/2/BAUD-1;  						UCSR0C |= 1<<UMSEL01;	 	UCSR0C |= 1<<UMSEL00;		break;		//	SPI
	}
		
 
		UBRR0L = UBBR0&0x00FF;
    1d1c:	20 93 c4 00 	sts	0x00C4, r18
		UBRR0H = (UBBR0>>8)&0x00FF;
    1d20:	23 2f       	mov	r18, r19
    1d22:	34 2f       	mov	r19, r20
    1d24:	45 2f       	mov	r20, r21
    1d26:	55 27       	eor	r21, r21
    1d28:	47 fd       	sbrc	r20, 7
    1d2a:	5a 95       	dec	r21
    1d2c:	20 93 c5 00 	sts	0x00C5, r18


	
switch (Parity) 
    1d30:	8f 2d       	mov	r24, r15
    1d32:	82 30       	cpi	r24, 0x02	; 2
    1d34:	41 f0       	breq	.+16     	; 0x1d46 <InitUART0+0xfa>
    1d36:	83 30       	cpi	r24, 0x03	; 3
    1d38:	79 f0       	breq	.+30     	; 0x1d58 <InitUART0+0x10c>
    1d3a:	ff 20       	and	r15, r15
    1d3c:	91 f4       	brne	.+36     	; 0x1d62 <InitUART0+0x116>
	{ 
		case 0:   UCSR0C &= ~((1<<UPM01)|(1<<UPM00));  	break;  //  
    1d3e:	80 91 c2 00 	lds	r24, 0x00C2
    1d42:	8f 7c       	andi	r24, 0xCF	; 207
    1d44:	0c c0       	rjmp	.+24     	; 0x1d5e <InitUART0+0x112>
		case 1:   break;  										// reserved
	  	case 2:   UCSR0C |= ((1<<UPM01));				UCSR0C &= ~(1<<UPM00);  	break;  //  
    1d46:	80 91 c2 00 	lds	r24, 0x00C2
    1d4a:	80 62       	ori	r24, 0x20	; 32
    1d4c:	80 93 c2 00 	sts	0x00C2, r24
    1d50:	80 91 c2 00 	lds	r24, 0x00C2
    1d54:	8f 7e       	andi	r24, 0xEF	; 239
    1d56:	03 c0       	rjmp	.+6      	; 0x1d5e <InitUART0+0x112>
	  	case 3:   UCSR0C |= ((1<<UPM01)|(1<<UPM00));								break;  //  
    1d58:	80 91 c2 00 	lds	r24, 0x00C2
    1d5c:	80 63       	ori	r24, 0x30	; 48
    1d5e:	80 93 c2 00 	sts	0x00C2, r24
	}

switch (StopBits) 
    1d62:	8e 2d       	mov	r24, r14
    1d64:	81 30       	cpi	r24, 0x01	; 1
    1d66:	19 f0       	breq	.+6      	; 0x1d6e <InitUART0+0x122>
    1d68:	82 30       	cpi	r24, 0x02	; 2
    1d6a:	51 f4       	brne	.+20     	; 0x1d80 <InitUART0+0x134>
    1d6c:	04 c0       	rjmp	.+8      	; 0x1d76 <InitUART0+0x12a>
	{ 
		case 1:   UCSR0C &= ~(1<<USBS0); 		break;  	//    
    1d6e:	80 91 c2 00 	lds	r24, 0x00C2
    1d72:	87 7f       	andi	r24, 0xF7	; 247
    1d74:	03 c0       	rjmp	.+6      	; 0x1d7c <InitUART0+0x130>
	  	case 2:   UCSR0C |= (1<<USBS0);  		break;  	//     
    1d76:	80 91 c2 00 	lds	r24, 0x00C2
    1d7a:	88 60       	ori	r24, 0x08	; 8
    1d7c:	80 93 c2 00 	sts	0x00C2, r24
	}

switch (CharacterSize) 
    1d80:	17 30       	cpi	r17, 0x07	; 7
    1d82:	f1 f0       	breq	.+60     	; 0x1dc0 <InitUART0+0x174>
    1d84:	18 30       	cpi	r17, 0x08	; 8
    1d86:	28 f4       	brcc	.+10     	; 0x1d92 <InitUART0+0x146>
    1d88:	15 30       	cpi	r17, 0x05	; 5
    1d8a:	41 f0       	breq	.+16     	; 0x1d9c <InitUART0+0x150>
    1d8c:	16 30       	cpi	r17, 0x06	; 6
    1d8e:	99 f5       	brne	.+102    	; 0x1df6 <InitUART0+0x1aa>
    1d90:	0e c0       	rjmp	.+28     	; 0x1dae <InitUART0+0x162>
    1d92:	18 30       	cpi	r17, 0x08	; 8
    1d94:	11 f1       	breq	.+68     	; 0x1dda <InitUART0+0x18e>
    1d96:	19 30       	cpi	r17, 0x09	; 9
    1d98:	71 f5       	brne	.+92     	; 0x1df6 <InitUART0+0x1aa>
    1d9a:	23 c0       	rjmp	.+70     	; 0x1de2 <InitUART0+0x196>
	{ 
		case 5:   UCSR0B &= ~(1<<UCSZ02);  											UCSR0C &= ~((1<<UCSZ01)|(1<<UCSZ00));  	break;  // 5  
    1d9c:	80 91 c1 00 	lds	r24, 0x00C1
    1da0:	8b 7f       	andi	r24, 0xFB	; 251
    1da2:	80 93 c1 00 	sts	0x00C1, r24
    1da6:	80 91 c2 00 	lds	r24, 0x00C2
    1daa:	89 7f       	andi	r24, 0xF9	; 249
    1dac:	22 c0       	rjmp	.+68     	; 0x1df2 <InitUART0+0x1a6>
	  	case 6:   UCSR0B &= ~(1<<UCSZ02); 	UCSR0C |= ((1<<UCSZ00)); 				UCSR0C &= ~(0<<UCSZ01);  				break;  // 6  
    1dae:	80 91 c1 00 	lds	r24, 0x00C1
    1db2:	8b 7f       	andi	r24, 0xFB	; 251
    1db4:	80 93 c1 00 	sts	0x00C1, r24
    1db8:	80 91 c2 00 	lds	r24, 0x00C2
    1dbc:	82 60       	ori	r24, 0x02	; 2
    1dbe:	08 c0       	rjmp	.+16     	; 0x1dd0 <InitUART0+0x184>
		case 7:   UCSR0B &= ~(1<<UCSZ02); 	UCSR0C |= ((1<<UCSZ01));				UCSR0C &= ~(0<<UCSZ00);   				break;  // 7  
    1dc0:	80 91 c1 00 	lds	r24, 0x00C1
    1dc4:	8b 7f       	andi	r24, 0xFB	; 251
    1dc6:	80 93 c1 00 	sts	0x00C1, r24
    1dca:	80 91 c2 00 	lds	r24, 0x00C2
    1dce:	84 60       	ori	r24, 0x04	; 4
    1dd0:	80 93 c2 00 	sts	0x00C2, r24
    1dd4:	80 91 c2 00 	lds	r24, 0x00C2
    1dd8:	0c c0       	rjmp	.+24     	; 0x1df2 <InitUART0+0x1a6>
	  	case 8:   UCSR0B &= ~(1<<UCSZ02); 	UCSR0C |= ((1<<UCSZ01)|(1<<UCSZ00));  											break;  // 8  
    1dda:	80 91 c1 00 	lds	r24, 0x00C1
    1dde:	8b 7f       	andi	r24, 0xFB	; 251
    1de0:	03 c0       	rjmp	.+6      	; 0x1de8 <InitUART0+0x19c>
		case 9:   UCSR0B |=   1<<UCSZ02;  	UCSR0C |= ((1<<UCSZ01)|(1<<UCSZ00)); 											break;  // 9  
    1de2:	80 91 c1 00 	lds	r24, 0x00C1
    1de6:	84 60       	ori	r24, 0x04	; 4
    1de8:	80 93 c1 00 	sts	0x00C1, r24
    1dec:	80 91 c2 00 	lds	r24, 0x00C2
    1df0:	86 60       	ori	r24, 0x06	; 6
    1df2:	80 93 c2 00 	sts	0x00C2, r24
	}

	UCSR0C &= ~(1<<UCPOL0);		
    1df6:	80 91 c2 00 	lds	r24, 0x00C2
    1dfa:	8e 7f       	andi	r24, 0xFE	; 254
    1dfc:	80 93 c2 00 	sts	0x00C2, r24
//	UCSR0C |= 	1<<UCPOL0;
}
    1e00:	1f 91       	pop	r17
    1e02:	0f 91       	pop	r16
    1e04:	ff 90       	pop	r15
    1e06:	ef 90       	pop	r14
    1e08:	08 95       	ret

00001e0a <InitUART1>:




void InitUART1(unsigned int BAUD, char CharacterSize, char StopBits, char Parity, char Mode)
{
    1e0a:	ef 92       	push	r14
    1e0c:	ff 92       	push	r15
    1e0e:	0f 93       	push	r16
    1e10:	1f 93       	push	r17
    1e12:	16 2f       	mov	r17, r22
    1e14:	e4 2e       	mov	r14, r20
    1e16:	f2 2e       	mov	r15, r18

//Stop Bits
//	1  -  1-bit
//	2  -  2-bit

UCSR1A = 0;
    1e18:	10 92 c8 00 	sts	0x00C8, r1
// Bit 1  U2X : Double the USART Transmission Speed 
// Bit 0  MPCM: Multi-processor Communication Mode 



UCSR1B = 0<<RXCIE1|0<<TXCIE1|0<<UDRIE1|0<<RXEN1|1<<TXEN1|0<<RXB81|0<<TXB81;
    1e1c:	28 e0       	ldi	r18, 0x08	; 8
    1e1e:	20 93 c9 00 	sts	0x00C9, r18
// Bit 0    UCPOL: Clock Polarity

	
long int UBBR1=0;

switch (Mode) 
    1e22:	01 30       	cpi	r16, 0x01	; 1
    1e24:	b1 f0       	breq	.+44     	; 0x1e52 <InitUART1+0x48>
    1e26:	01 30       	cpi	r16, 0x01	; 1
    1e28:	30 f0       	brcs	.+12     	; 0x1e36 <InitUART1+0x2c>
    1e2a:	02 30       	cpi	r16, 0x02	; 2
    1e2c:	11 f1       	breq	.+68     	; 0x1e72 <InitUART1+0x68>
    1e2e:	03 30       	cpi	r16, 0x03	; 3
    1e30:	09 f0       	breq	.+2      	; 0x1e34 <InitUART1+0x2a>
    1e32:	50 c0       	rjmp	.+160    	; 0x1ed4 <InitUART1+0xca>
    1e34:	37 c0       	rjmp	.+110    	; 0x1ea4 <InitUART1+0x9a>
	{ 
		case 0: UBBR1 = F_CPU/16/BAUD-1; 						UCSR1C &= ~(0<<UMSEL11);	UCSR1C &= ~(0<<UMSEL10);	break;		//	
    1e36:	9c 01       	movw	r18, r24
    1e38:	40 e0       	ldi	r20, 0x00	; 0
    1e3a:	50 e0       	ldi	r21, 0x00	; 0
    1e3c:	60 eb       	ldi	r22, 0xB0	; 176
    1e3e:	71 e7       	ldi	r23, 0x71	; 113
    1e40:	8b e0       	ldi	r24, 0x0B	; 11
    1e42:	90 e0       	ldi	r25, 0x00	; 0
    1e44:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    1e48:	21 50       	subi	r18, 0x01	; 1
    1e4a:	30 40       	sbci	r19, 0x00	; 0
    1e4c:	40 40       	sbci	r20, 0x00	; 0
    1e4e:	50 40       	sbci	r21, 0x00	; 0
    1e50:	22 c0       	rjmp	.+68     	; 0x1e96 <InitUART1+0x8c>
	  	case 1:	UBBR1 = F_CPU/8/BAUD-1;  						UCSR1C &= ~(0<<UMSEL11);	UCSR1C |= 1<<UMSEL10;		break;		//	
    1e52:	9c 01       	movw	r18, r24
    1e54:	40 e0       	ldi	r20, 0x00	; 0
    1e56:	50 e0       	ldi	r21, 0x00	; 0
    1e58:	60 e6       	ldi	r22, 0x60	; 96
    1e5a:	73 ee       	ldi	r23, 0xE3	; 227
    1e5c:	86 e1       	ldi	r24, 0x16	; 22
    1e5e:	90 e0       	ldi	r25, 0x00	; 0
    1e60:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    1e64:	21 50       	subi	r18, 0x01	; 1
    1e66:	30 40       	sbci	r19, 0x00	; 0
    1e68:	40 40       	sbci	r20, 0x00	; 0
    1e6a:	50 40       	sbci	r21, 0x00	; 0
    1e6c:	80 91 ca 00 	lds	r24, 0x00CA
    1e70:	29 c0       	rjmp	.+82     	; 0x1ec4 <InitUART1+0xba>
	  	case 2: UBBR1 = F_CPU/8/BAUD-1; 	UCSR1A |= 1<<U2X1;	UCSR1C &= ~(0<<UMSEL11);	UCSR1C &= ~(0<<UMSEL10);	break;		//	   
    1e72:	9c 01       	movw	r18, r24
    1e74:	40 e0       	ldi	r20, 0x00	; 0
    1e76:	50 e0       	ldi	r21, 0x00	; 0
    1e78:	60 e6       	ldi	r22, 0x60	; 96
    1e7a:	73 ee       	ldi	r23, 0xE3	; 227
    1e7c:	86 e1       	ldi	r24, 0x16	; 22
    1e7e:	90 e0       	ldi	r25, 0x00	; 0
    1e80:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    1e84:	21 50       	subi	r18, 0x01	; 1
    1e86:	30 40       	sbci	r19, 0x00	; 0
    1e88:	40 40       	sbci	r20, 0x00	; 0
    1e8a:	50 40       	sbci	r21, 0x00	; 0
    1e8c:	80 91 c8 00 	lds	r24, 0x00C8
    1e90:	82 60       	ori	r24, 0x02	; 2
    1e92:	80 93 c8 00 	sts	0x00C8, r24
    1e96:	80 91 ca 00 	lds	r24, 0x00CA
    1e9a:	80 93 ca 00 	sts	0x00CA, r24
    1e9e:	80 91 ca 00 	lds	r24, 0x00CA
    1ea2:	15 c0       	rjmp	.+42     	; 0x1ece <InitUART1+0xc4>
	  	case 3: UBBR1 = F_CPU/2/BAUD-1;  						UCSR1C |= 1<<UMSEL11;	 	UCSR1C |= 1<<UMSEL10;		break;		//	SPI
    1ea4:	9c 01       	movw	r18, r24
    1ea6:	40 e0       	ldi	r20, 0x00	; 0
    1ea8:	50 e0       	ldi	r21, 0x00	; 0
    1eaa:	60 e8       	ldi	r22, 0x80	; 128
    1eac:	7d e8       	ldi	r23, 0x8D	; 141
    1eae:	8b e5       	ldi	r24, 0x5B	; 91
    1eb0:	90 e0       	ldi	r25, 0x00	; 0
    1eb2:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    1eb6:	21 50       	subi	r18, 0x01	; 1
    1eb8:	30 40       	sbci	r19, 0x00	; 0
    1eba:	40 40       	sbci	r20, 0x00	; 0
    1ebc:	50 40       	sbci	r21, 0x00	; 0
    1ebe:	80 91 ca 00 	lds	r24, 0x00CA
    1ec2:	80 68       	ori	r24, 0x80	; 128
    1ec4:	80 93 ca 00 	sts	0x00CA, r24
    1ec8:	80 91 ca 00 	lds	r24, 0x00CA
    1ecc:	80 64       	ori	r24, 0x40	; 64
    1ece:	80 93 ca 00 	sts	0x00CA, r24
    1ed2:	03 c0       	rjmp	.+6      	; 0x1eda <InitUART1+0xd0>
// Bit 3    USBS: Stop Bit Select
// Bit 2:1  UCSZ1:0: Character Size
// Bit 0    UCPOL: Clock Polarity

	
long int UBBR1=0;
    1ed4:	20 e0       	ldi	r18, 0x00	; 0
    1ed6:	30 e0       	ldi	r19, 0x00	; 0
    1ed8:	a9 01       	movw	r20, r18
	  	case 2: UBBR1 = F_CPU/8/BAUD-1; 	UCSR1A |= 1<<U2X1;	UCSR1C &= ~(0<<UMSEL11);	UCSR1C &= ~(0<<UMSEL10);	break;		//	   
	  	case 3: UBBR1 = F_CPU/2/BAUD-1;  						UCSR1C |= 1<<UMSEL11;	 	UCSR1C |= 1<<UMSEL10;		break;		//	SPI
	}
		
 
		UBRR1L = UBBR1&0x00FF;
    1eda:	20 93 cc 00 	sts	0x00CC, r18
		UBRR1H = (UBBR1>>8)&0x00FF;
    1ede:	23 2f       	mov	r18, r19
    1ee0:	34 2f       	mov	r19, r20
    1ee2:	45 2f       	mov	r20, r21
    1ee4:	55 27       	eor	r21, r21
    1ee6:	47 fd       	sbrc	r20, 7
    1ee8:	5a 95       	dec	r21
    1eea:	20 93 cd 00 	sts	0x00CD, r18


	
switch (Parity) 
    1eee:	8f 2d       	mov	r24, r15
    1ef0:	82 30       	cpi	r24, 0x02	; 2
    1ef2:	41 f0       	breq	.+16     	; 0x1f04 <InitUART1+0xfa>
    1ef4:	83 30       	cpi	r24, 0x03	; 3
    1ef6:	79 f0       	breq	.+30     	; 0x1f16 <InitUART1+0x10c>
    1ef8:	ff 20       	and	r15, r15
    1efa:	91 f4       	brne	.+36     	; 0x1f20 <InitUART1+0x116>
	{ 
		case 0:   UCSR1C &= ~((1<<UPM11)|(1<<UPM10));  	break;  //  
    1efc:	80 91 ca 00 	lds	r24, 0x00CA
    1f00:	8f 7c       	andi	r24, 0xCF	; 207
    1f02:	0c c0       	rjmp	.+24     	; 0x1f1c <InitUART1+0x112>
		case 1:   break;  										// reserved
	  	case 2:   UCSR1C |= ((1<<UPM11));				UCSR1C &= ~(1<<UPM10);  	break;  //  
    1f04:	80 91 ca 00 	lds	r24, 0x00CA
    1f08:	80 62       	ori	r24, 0x20	; 32
    1f0a:	80 93 ca 00 	sts	0x00CA, r24
    1f0e:	80 91 ca 00 	lds	r24, 0x00CA
    1f12:	8f 7e       	andi	r24, 0xEF	; 239
    1f14:	03 c0       	rjmp	.+6      	; 0x1f1c <InitUART1+0x112>
	  	case 3:   UCSR1C |= ((1<<UPM11)|(1<<UPM10));								break;  //  
    1f16:	80 91 ca 00 	lds	r24, 0x00CA
    1f1a:	80 63       	ori	r24, 0x30	; 48
    1f1c:	80 93 ca 00 	sts	0x00CA, r24
	}

switch (StopBits) 
    1f20:	8e 2d       	mov	r24, r14
    1f22:	81 30       	cpi	r24, 0x01	; 1
    1f24:	19 f0       	breq	.+6      	; 0x1f2c <InitUART1+0x122>
    1f26:	82 30       	cpi	r24, 0x02	; 2
    1f28:	51 f4       	brne	.+20     	; 0x1f3e <InitUART1+0x134>
    1f2a:	04 c0       	rjmp	.+8      	; 0x1f34 <InitUART1+0x12a>
	{ 
		case 1:   UCSR1C &= ~(1<<USBS1); 		break;  	//    
    1f2c:	80 91 ca 00 	lds	r24, 0x00CA
    1f30:	87 7f       	andi	r24, 0xF7	; 247
    1f32:	03 c0       	rjmp	.+6      	; 0x1f3a <InitUART1+0x130>
	  	case 2:   UCSR1C |= (1<<USBS1);  		break;  	//     
    1f34:	80 91 ca 00 	lds	r24, 0x00CA
    1f38:	88 60       	ori	r24, 0x08	; 8
    1f3a:	80 93 ca 00 	sts	0x00CA, r24
	}

switch (CharacterSize) 
    1f3e:	17 30       	cpi	r17, 0x07	; 7
    1f40:	f1 f0       	breq	.+60     	; 0x1f7e <InitUART1+0x174>
    1f42:	18 30       	cpi	r17, 0x08	; 8
    1f44:	28 f4       	brcc	.+10     	; 0x1f50 <InitUART1+0x146>
    1f46:	15 30       	cpi	r17, 0x05	; 5
    1f48:	41 f0       	breq	.+16     	; 0x1f5a <InitUART1+0x150>
    1f4a:	16 30       	cpi	r17, 0x06	; 6
    1f4c:	99 f5       	brne	.+102    	; 0x1fb4 <InitUART1+0x1aa>
    1f4e:	0e c0       	rjmp	.+28     	; 0x1f6c <InitUART1+0x162>
    1f50:	18 30       	cpi	r17, 0x08	; 8
    1f52:	11 f1       	breq	.+68     	; 0x1f98 <InitUART1+0x18e>
    1f54:	19 30       	cpi	r17, 0x09	; 9
    1f56:	71 f5       	brne	.+92     	; 0x1fb4 <InitUART1+0x1aa>
    1f58:	23 c0       	rjmp	.+70     	; 0x1fa0 <InitUART1+0x196>
	{ 
		case 5:   UCSR1B &= ~(1<<UCSZ12);  											UCSR1C &= ~((1<<UCSZ11)|(1<<UCSZ10));  	break;  // 5  
    1f5a:	80 91 c9 00 	lds	r24, 0x00C9
    1f5e:	8b 7f       	andi	r24, 0xFB	; 251
    1f60:	80 93 c9 00 	sts	0x00C9, r24
    1f64:	80 91 ca 00 	lds	r24, 0x00CA
    1f68:	89 7f       	andi	r24, 0xF9	; 249
    1f6a:	22 c0       	rjmp	.+68     	; 0x1fb0 <InitUART1+0x1a6>
	  	case 6:   UCSR1B &= ~(1<<UCSZ12); 	UCSR1C |= ((1<<UCSZ10)); 				UCSR1C &= ~(0<<UCSZ11);  				break;  // 6  
    1f6c:	80 91 c9 00 	lds	r24, 0x00C9
    1f70:	8b 7f       	andi	r24, 0xFB	; 251
    1f72:	80 93 c9 00 	sts	0x00C9, r24
    1f76:	80 91 ca 00 	lds	r24, 0x00CA
    1f7a:	82 60       	ori	r24, 0x02	; 2
    1f7c:	08 c0       	rjmp	.+16     	; 0x1f8e <InitUART1+0x184>
		case 7:   UCSR1B &= ~(1<<UCSZ12); 	UCSR1C |= ((1<<UCSZ11));				UCSR1C &= ~(0<<UCSZ10);   				break;  // 7  
    1f7e:	80 91 c9 00 	lds	r24, 0x00C9
    1f82:	8b 7f       	andi	r24, 0xFB	; 251
    1f84:	80 93 c9 00 	sts	0x00C9, r24
    1f88:	80 91 ca 00 	lds	r24, 0x00CA
    1f8c:	84 60       	ori	r24, 0x04	; 4
    1f8e:	80 93 ca 00 	sts	0x00CA, r24
    1f92:	80 91 ca 00 	lds	r24, 0x00CA
    1f96:	0c c0       	rjmp	.+24     	; 0x1fb0 <InitUART1+0x1a6>
	  	case 8:   UCSR1B &= ~(1<<UCSZ12); 	UCSR1C |= ((1<<UCSZ11)|(1<<UCSZ10));  											break;  // 8  
    1f98:	80 91 c9 00 	lds	r24, 0x00C9
    1f9c:	8b 7f       	andi	r24, 0xFB	; 251
    1f9e:	03 c0       	rjmp	.+6      	; 0x1fa6 <InitUART1+0x19c>
		case 9:   UCSR1B |=   1<<UCSZ12;  	UCSR1C |= ((1<<UCSZ11)|(1<<UCSZ10)); 											break;  // 9  
    1fa0:	80 91 c9 00 	lds	r24, 0x00C9
    1fa4:	84 60       	ori	r24, 0x04	; 4
    1fa6:	80 93 c9 00 	sts	0x00C9, r24
    1faa:	80 91 ca 00 	lds	r24, 0x00CA
    1fae:	86 60       	ori	r24, 0x06	; 6
    1fb0:	80 93 ca 00 	sts	0x00CA, r24
	}

	UCSR1C &= ~(1<<UCPOL1);		
    1fb4:	80 91 ca 00 	lds	r24, 0x00CA
    1fb8:	8e 7f       	andi	r24, 0xFE	; 254
    1fba:	80 93 ca 00 	sts	0x00CA, r24
//	UCSR1C |= 	1<<UCPOL1;
}
    1fbe:	1f 91       	pop	r17
    1fc0:	0f 91       	pop	r16
    1fc2:	ff 90       	pop	r15
    1fc4:	ef 90       	pop	r14
    1fc6:	08 95       	ret

00001fc8 <InitUART2>:



void InitUART2(unsigned int BAUD, char CharacterSize, char StopBits, char Parity, char Mode)
{
    1fc8:	ef 92       	push	r14
    1fca:	ff 92       	push	r15
    1fcc:	0f 93       	push	r16
    1fce:	1f 93       	push	r17
    1fd0:	16 2f       	mov	r17, r22
    1fd2:	e4 2e       	mov	r14, r20
    1fd4:	f2 2e       	mov	r15, r18

//Stop Bits
//	1  -  1-bit
//	2  -  2-bit

UCSR2A = 0;
    1fd6:	10 92 d0 00 	sts	0x00D0, r1
// Bit 1  U2X : Double the USART Transmission Speed 
// Bit 0  MPCM: Multi-processor Communication Mode 



UCSR2B = 0<<RXCIE2|0<<TXCIE2|0<<UDRIE2|0<<RXEN2|1<<TXEN2|0<<RXB82|0<<TXB82;
    1fda:	28 e0       	ldi	r18, 0x08	; 8
    1fdc:	20 93 d1 00 	sts	0x00D1, r18
// Bit 0    UCPOL: Clock Polarity

	
long int UBBR2=0;

switch (Mode) 
    1fe0:	01 30       	cpi	r16, 0x01	; 1
    1fe2:	b1 f0       	breq	.+44     	; 0x2010 <InitUART2+0x48>
    1fe4:	01 30       	cpi	r16, 0x01	; 1
    1fe6:	30 f0       	brcs	.+12     	; 0x1ff4 <InitUART2+0x2c>
    1fe8:	02 30       	cpi	r16, 0x02	; 2
    1fea:	11 f1       	breq	.+68     	; 0x2030 <InitUART2+0x68>
    1fec:	03 30       	cpi	r16, 0x03	; 3
    1fee:	09 f0       	breq	.+2      	; 0x1ff2 <InitUART2+0x2a>
    1ff0:	50 c0       	rjmp	.+160    	; 0x2092 <InitUART2+0xca>
    1ff2:	37 c0       	rjmp	.+110    	; 0x2062 <InitUART2+0x9a>
	{ 
		case 0: UBBR2 = F_CPU/16/BAUD-1; 						UCSR2C &= ~(0<<UMSEL21);	UCSR2C &= ~(0<<UMSEL20);	break;		//	
    1ff4:	9c 01       	movw	r18, r24
    1ff6:	40 e0       	ldi	r20, 0x00	; 0
    1ff8:	50 e0       	ldi	r21, 0x00	; 0
    1ffa:	60 eb       	ldi	r22, 0xB0	; 176
    1ffc:	71 e7       	ldi	r23, 0x71	; 113
    1ffe:	8b e0       	ldi	r24, 0x0B	; 11
    2000:	90 e0       	ldi	r25, 0x00	; 0
    2002:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    2006:	21 50       	subi	r18, 0x01	; 1
    2008:	30 40       	sbci	r19, 0x00	; 0
    200a:	40 40       	sbci	r20, 0x00	; 0
    200c:	50 40       	sbci	r21, 0x00	; 0
    200e:	22 c0       	rjmp	.+68     	; 0x2054 <InitUART2+0x8c>
	  	case 1:	UBBR2 = F_CPU/8/BAUD-1;  						UCSR2C &= ~(0<<UMSEL21);	UCSR2C |= 1<<UMSEL20;		break;		//	
    2010:	9c 01       	movw	r18, r24
    2012:	40 e0       	ldi	r20, 0x00	; 0
    2014:	50 e0       	ldi	r21, 0x00	; 0
    2016:	60 e6       	ldi	r22, 0x60	; 96
    2018:	73 ee       	ldi	r23, 0xE3	; 227
    201a:	86 e1       	ldi	r24, 0x16	; 22
    201c:	90 e0       	ldi	r25, 0x00	; 0
    201e:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    2022:	21 50       	subi	r18, 0x01	; 1
    2024:	30 40       	sbci	r19, 0x00	; 0
    2026:	40 40       	sbci	r20, 0x00	; 0
    2028:	50 40       	sbci	r21, 0x00	; 0
    202a:	80 91 d2 00 	lds	r24, 0x00D2
    202e:	29 c0       	rjmp	.+82     	; 0x2082 <InitUART2+0xba>
	  	case 2: UBBR2 = F_CPU/8/BAUD-1; 	UCSR2A |= 1<<U2X2;	UCSR2C &= ~(0<<UMSEL21);	UCSR2C &= ~(0<<UMSEL20);	break;		//	   
    2030:	9c 01       	movw	r18, r24
    2032:	40 e0       	ldi	r20, 0x00	; 0
    2034:	50 e0       	ldi	r21, 0x00	; 0
    2036:	60 e6       	ldi	r22, 0x60	; 96
    2038:	73 ee       	ldi	r23, 0xE3	; 227
    203a:	86 e1       	ldi	r24, 0x16	; 22
    203c:	90 e0       	ldi	r25, 0x00	; 0
    203e:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    2042:	21 50       	subi	r18, 0x01	; 1
    2044:	30 40       	sbci	r19, 0x00	; 0
    2046:	40 40       	sbci	r20, 0x00	; 0
    2048:	50 40       	sbci	r21, 0x00	; 0
    204a:	80 91 d0 00 	lds	r24, 0x00D0
    204e:	82 60       	ori	r24, 0x02	; 2
    2050:	80 93 d0 00 	sts	0x00D0, r24
    2054:	80 91 d2 00 	lds	r24, 0x00D2
    2058:	80 93 d2 00 	sts	0x00D2, r24
    205c:	80 91 d2 00 	lds	r24, 0x00D2
    2060:	15 c0       	rjmp	.+42     	; 0x208c <InitUART2+0xc4>
	  	case 3: UBBR2 = F_CPU/2/BAUD-1;  						UCSR2C |= 1<<UMSEL21;	 	UCSR2C |= 1<<UMSEL20;		break;		//	SPI
    2062:	9c 01       	movw	r18, r24
    2064:	40 e0       	ldi	r20, 0x00	; 0
    2066:	50 e0       	ldi	r21, 0x00	; 0
    2068:	60 e8       	ldi	r22, 0x80	; 128
    206a:	7d e8       	ldi	r23, 0x8D	; 141
    206c:	8b e5       	ldi	r24, 0x5B	; 91
    206e:	90 e0       	ldi	r25, 0x00	; 0
    2070:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    2074:	21 50       	subi	r18, 0x01	; 1
    2076:	30 40       	sbci	r19, 0x00	; 0
    2078:	40 40       	sbci	r20, 0x00	; 0
    207a:	50 40       	sbci	r21, 0x00	; 0
    207c:	80 91 d2 00 	lds	r24, 0x00D2
    2080:	80 68       	ori	r24, 0x80	; 128
    2082:	80 93 d2 00 	sts	0x00D2, r24
    2086:	80 91 d2 00 	lds	r24, 0x00D2
    208a:	80 64       	ori	r24, 0x40	; 64
    208c:	80 93 d2 00 	sts	0x00D2, r24
    2090:	03 c0       	rjmp	.+6      	; 0x2098 <InitUART2+0xd0>
// Bit 3    USBS: Stop Bit Select
// Bit 2:1  UCSZ1:0: Character Size
// Bit 0    UCPOL: Clock Polarity

	
long int UBBR2=0;
    2092:	20 e0       	ldi	r18, 0x00	; 0
    2094:	30 e0       	ldi	r19, 0x00	; 0
    2096:	a9 01       	movw	r20, r18
	  	case 2: UBBR2 = F_CPU/8/BAUD-1; 	UCSR2A |= 1<<U2X2;	UCSR2C &= ~(0<<UMSEL21);	UCSR2C &= ~(0<<UMSEL20);	break;		//	   
	  	case 3: UBBR2 = F_CPU/2/BAUD-1;  						UCSR2C |= 1<<UMSEL21;	 	UCSR2C |= 1<<UMSEL20;		break;		//	SPI
	}
		
 
		UBRR2L = UBBR2&0x00FF;
    2098:	20 93 d4 00 	sts	0x00D4, r18
		UBRR2H = (UBBR2>>8)&0x00FF;
    209c:	23 2f       	mov	r18, r19
    209e:	34 2f       	mov	r19, r20
    20a0:	45 2f       	mov	r20, r21
    20a2:	55 27       	eor	r21, r21
    20a4:	47 fd       	sbrc	r20, 7
    20a6:	5a 95       	dec	r21
    20a8:	20 93 d5 00 	sts	0x00D5, r18


	
switch (Parity) 
    20ac:	8f 2d       	mov	r24, r15
    20ae:	82 30       	cpi	r24, 0x02	; 2
    20b0:	41 f0       	breq	.+16     	; 0x20c2 <InitUART2+0xfa>
    20b2:	83 30       	cpi	r24, 0x03	; 3
    20b4:	79 f0       	breq	.+30     	; 0x20d4 <InitUART2+0x10c>
    20b6:	ff 20       	and	r15, r15
    20b8:	91 f4       	brne	.+36     	; 0x20de <InitUART2+0x116>
	{ 
		case 0:   UCSR2C &= ~((1<<UPM21)|(1<<UPM20));  	break;  //  
    20ba:	80 91 d2 00 	lds	r24, 0x00D2
    20be:	8f 7c       	andi	r24, 0xCF	; 207
    20c0:	0c c0       	rjmp	.+24     	; 0x20da <InitUART2+0x112>
		case 1:   break;  										// reserved
	  	case 2:   UCSR2C |= ((1<<UPM21));				UCSR2C &= ~(1<<UPM20);  	break;  //  
    20c2:	80 91 d2 00 	lds	r24, 0x00D2
    20c6:	80 62       	ori	r24, 0x20	; 32
    20c8:	80 93 d2 00 	sts	0x00D2, r24
    20cc:	80 91 d2 00 	lds	r24, 0x00D2
    20d0:	8f 7e       	andi	r24, 0xEF	; 239
    20d2:	03 c0       	rjmp	.+6      	; 0x20da <InitUART2+0x112>
	  	case 3:   UCSR2C |= ((1<<UPM21)|(1<<UPM20));								break;  //  
    20d4:	80 91 d2 00 	lds	r24, 0x00D2
    20d8:	80 63       	ori	r24, 0x30	; 48
    20da:	80 93 d2 00 	sts	0x00D2, r24
	}

switch (StopBits) 
    20de:	8e 2d       	mov	r24, r14
    20e0:	81 30       	cpi	r24, 0x01	; 1
    20e2:	19 f0       	breq	.+6      	; 0x20ea <InitUART2+0x122>
    20e4:	82 30       	cpi	r24, 0x02	; 2
    20e6:	51 f4       	brne	.+20     	; 0x20fc <InitUART2+0x134>
    20e8:	04 c0       	rjmp	.+8      	; 0x20f2 <InitUART2+0x12a>
	{ 
		case 1:   UCSR2C &= ~(1<<USBS2); 		break;  	//    
    20ea:	80 91 d2 00 	lds	r24, 0x00D2
    20ee:	87 7f       	andi	r24, 0xF7	; 247
    20f0:	03 c0       	rjmp	.+6      	; 0x20f8 <InitUART2+0x130>
	  	case 2:   UCSR2C |= (1<<USBS2);  		break;  	//     
    20f2:	80 91 d2 00 	lds	r24, 0x00D2
    20f6:	88 60       	ori	r24, 0x08	; 8
    20f8:	80 93 d2 00 	sts	0x00D2, r24
	}

switch (CharacterSize) 
    20fc:	17 30       	cpi	r17, 0x07	; 7
    20fe:	f1 f0       	breq	.+60     	; 0x213c <InitUART2+0x174>
    2100:	18 30       	cpi	r17, 0x08	; 8
    2102:	28 f4       	brcc	.+10     	; 0x210e <InitUART2+0x146>
    2104:	15 30       	cpi	r17, 0x05	; 5
    2106:	41 f0       	breq	.+16     	; 0x2118 <InitUART2+0x150>
    2108:	16 30       	cpi	r17, 0x06	; 6
    210a:	99 f5       	brne	.+102    	; 0x2172 <InitUART2+0x1aa>
    210c:	0e c0       	rjmp	.+28     	; 0x212a <InitUART2+0x162>
    210e:	18 30       	cpi	r17, 0x08	; 8
    2110:	11 f1       	breq	.+68     	; 0x2156 <InitUART2+0x18e>
    2112:	19 30       	cpi	r17, 0x09	; 9
    2114:	71 f5       	brne	.+92     	; 0x2172 <InitUART2+0x1aa>
    2116:	23 c0       	rjmp	.+70     	; 0x215e <InitUART2+0x196>
	{ 
		case 5:   UCSR2B &= ~(1<<UCSZ22);  											UCSR2C &= ~((1<<UCSZ21)|(1<<UCSZ20));  	break;  // 5  
    2118:	80 91 d1 00 	lds	r24, 0x00D1
    211c:	8b 7f       	andi	r24, 0xFB	; 251
    211e:	80 93 d1 00 	sts	0x00D1, r24
    2122:	80 91 d2 00 	lds	r24, 0x00D2
    2126:	89 7f       	andi	r24, 0xF9	; 249
    2128:	22 c0       	rjmp	.+68     	; 0x216e <InitUART2+0x1a6>
	  	case 6:   UCSR2B &= ~(1<<UCSZ22); 	UCSR2C |= ((1<<UCSZ20)); 				UCSR2C &= ~(0<<UCSZ21);  				break;  // 6  
    212a:	80 91 d1 00 	lds	r24, 0x00D1
    212e:	8b 7f       	andi	r24, 0xFB	; 251
    2130:	80 93 d1 00 	sts	0x00D1, r24
    2134:	80 91 d2 00 	lds	r24, 0x00D2
    2138:	82 60       	ori	r24, 0x02	; 2
    213a:	08 c0       	rjmp	.+16     	; 0x214c <InitUART2+0x184>
		case 7:   UCSR2B &= ~(1<<UCSZ22); 	UCSR2C |= ((1<<UCSZ21));				UCSR2C &= ~(0<<UCSZ20);   				break;  // 7  
    213c:	80 91 d1 00 	lds	r24, 0x00D1
    2140:	8b 7f       	andi	r24, 0xFB	; 251
    2142:	80 93 d1 00 	sts	0x00D1, r24
    2146:	80 91 d2 00 	lds	r24, 0x00D2
    214a:	84 60       	ori	r24, 0x04	; 4
    214c:	80 93 d2 00 	sts	0x00D2, r24
    2150:	80 91 d2 00 	lds	r24, 0x00D2
    2154:	0c c0       	rjmp	.+24     	; 0x216e <InitUART2+0x1a6>
	  	case 8:   UCSR2B &= ~(1<<UCSZ22); 	UCSR2C |= ((1<<UCSZ21)|(1<<UCSZ20));  											break;  // 8  
    2156:	80 91 d1 00 	lds	r24, 0x00D1
    215a:	8b 7f       	andi	r24, 0xFB	; 251
    215c:	03 c0       	rjmp	.+6      	; 0x2164 <InitUART2+0x19c>
		case 9:   UCSR2B |=   1<<UCSZ22;  	UCSR2C |= ((1<<UCSZ21)|(1<<UCSZ20)); 											break;  // 9  
    215e:	80 91 d1 00 	lds	r24, 0x00D1
    2162:	84 60       	ori	r24, 0x04	; 4
    2164:	80 93 d1 00 	sts	0x00D1, r24
    2168:	80 91 d2 00 	lds	r24, 0x00D2
    216c:	86 60       	ori	r24, 0x06	; 6
    216e:	80 93 d2 00 	sts	0x00D2, r24
	}

	UCSR2C &= ~(1<<UCPOL2);		
    2172:	80 91 d2 00 	lds	r24, 0x00D2
    2176:	8e 7f       	andi	r24, 0xFE	; 254
    2178:	80 93 d2 00 	sts	0x00D2, r24
//	UCSR2C |= 	1<<UCPOL2;
}
    217c:	1f 91       	pop	r17
    217e:	0f 91       	pop	r16
    2180:	ff 90       	pop	r15
    2182:	ef 90       	pop	r14
    2184:	08 95       	ret

00002186 <InitUART3>:


void InitUART3(unsigned int BAUD, char CharacterSize, char StopBits, char Parity, char Mode)
{
    2186:	ef 92       	push	r14
    2188:	ff 92       	push	r15
    218a:	0f 93       	push	r16
    218c:	1f 93       	push	r17
    218e:	16 2f       	mov	r17, r22
    2190:	e4 2e       	mov	r14, r20
    2192:	f2 2e       	mov	r15, r18

//Stop Bits
//	1  -  1-bit
//	2  -  2-bit

UCSR3A = 0;
    2194:	10 92 30 01 	sts	0x0130, r1
// Bit 1  U2X : Double the USART Transmission Speed 
// Bit 0  MPCM: Multi-processor Communication Mode 



UCSR3B = 0<<RXCIE3|0<<TXCIE3|0<<UDRIE3|0<<RXEN3|1<<TXEN3|0<<RXB83|0<<TXB83;
    2198:	28 e0       	ldi	r18, 0x08	; 8
    219a:	20 93 31 01 	sts	0x0131, r18
// Bit 0    UCPOL: Clock Polarity

	
long int UBBR3=0;

switch (Mode) 
    219e:	01 30       	cpi	r16, 0x01	; 1
    21a0:	b1 f0       	breq	.+44     	; 0x21ce <InitUART3+0x48>
    21a2:	01 30       	cpi	r16, 0x01	; 1
    21a4:	30 f0       	brcs	.+12     	; 0x21b2 <InitUART3+0x2c>
    21a6:	02 30       	cpi	r16, 0x02	; 2
    21a8:	11 f1       	breq	.+68     	; 0x21ee <InitUART3+0x68>
    21aa:	03 30       	cpi	r16, 0x03	; 3
    21ac:	09 f0       	breq	.+2      	; 0x21b0 <InitUART3+0x2a>
    21ae:	50 c0       	rjmp	.+160    	; 0x2250 <__stack+0x51>
    21b0:	37 c0       	rjmp	.+110    	; 0x2220 <__stack+0x21>
	{ 
		case 0: UBBR3 = F_CPU/16/BAUD-1; 						UCSR3C &= ~(0<<UMSEL31);	UCSR3C &= ~(0<<UMSEL30);	break;		//	
    21b2:	9c 01       	movw	r18, r24
    21b4:	40 e0       	ldi	r20, 0x00	; 0
    21b6:	50 e0       	ldi	r21, 0x00	; 0
    21b8:	60 eb       	ldi	r22, 0xB0	; 176
    21ba:	71 e7       	ldi	r23, 0x71	; 113
    21bc:	8b e0       	ldi	r24, 0x0B	; 11
    21be:	90 e0       	ldi	r25, 0x00	; 0
    21c0:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    21c4:	21 50       	subi	r18, 0x01	; 1
    21c6:	30 40       	sbci	r19, 0x00	; 0
    21c8:	40 40       	sbci	r20, 0x00	; 0
    21ca:	50 40       	sbci	r21, 0x00	; 0
    21cc:	22 c0       	rjmp	.+68     	; 0x2212 <__stack+0x13>
	  	case 1:	UBBR3 = F_CPU/8/BAUD-1;  						UCSR3C &= ~(0<<UMSEL31);	UCSR3C |= 1<<UMSEL30;		break;		//	
    21ce:	9c 01       	movw	r18, r24
    21d0:	40 e0       	ldi	r20, 0x00	; 0
    21d2:	50 e0       	ldi	r21, 0x00	; 0
    21d4:	60 e6       	ldi	r22, 0x60	; 96
    21d6:	73 ee       	ldi	r23, 0xE3	; 227
    21d8:	86 e1       	ldi	r24, 0x16	; 22
    21da:	90 e0       	ldi	r25, 0x00	; 0
    21dc:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    21e0:	21 50       	subi	r18, 0x01	; 1
    21e2:	30 40       	sbci	r19, 0x00	; 0
    21e4:	40 40       	sbci	r20, 0x00	; 0
    21e6:	50 40       	sbci	r21, 0x00	; 0
    21e8:	80 91 32 01 	lds	r24, 0x0132
    21ec:	29 c0       	rjmp	.+82     	; 0x2240 <__stack+0x41>
	  	case 2: UBBR3 = F_CPU/8/BAUD-1; 	UCSR3A |= 1<<U2X3;	UCSR3C &= ~(0<<UMSEL31);	UCSR3C &= ~(0<<UMSEL30);	break;		//	   
    21ee:	9c 01       	movw	r18, r24
    21f0:	40 e0       	ldi	r20, 0x00	; 0
    21f2:	50 e0       	ldi	r21, 0x00	; 0
    21f4:	60 e6       	ldi	r22, 0x60	; 96
    21f6:	73 ee       	ldi	r23, 0xE3	; 227
    21f8:	86 e1       	ldi	r24, 0x16	; 22
    21fa:	90 e0       	ldi	r25, 0x00	; 0
    21fc:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    2200:	21 50       	subi	r18, 0x01	; 1
    2202:	30 40       	sbci	r19, 0x00	; 0
    2204:	40 40       	sbci	r20, 0x00	; 0
    2206:	50 40       	sbci	r21, 0x00	; 0
    2208:	80 91 30 01 	lds	r24, 0x0130
    220c:	82 60       	ori	r24, 0x02	; 2
    220e:	80 93 30 01 	sts	0x0130, r24
    2212:	80 91 32 01 	lds	r24, 0x0132
    2216:	80 93 32 01 	sts	0x0132, r24
    221a:	80 91 32 01 	lds	r24, 0x0132
    221e:	15 c0       	rjmp	.+42     	; 0x224a <__stack+0x4b>
	  	case 3: UBBR3 = F_CPU/2/BAUD-1;  						UCSR3C |= 1<<UMSEL31;	 	UCSR3C |= 1<<UMSEL30;		break;		//	SPI
    2220:	9c 01       	movw	r18, r24
    2222:	40 e0       	ldi	r20, 0x00	; 0
    2224:	50 e0       	ldi	r21, 0x00	; 0
    2226:	60 e8       	ldi	r22, 0x80	; 128
    2228:	7d e8       	ldi	r23, 0x8D	; 141
    222a:	8b e5       	ldi	r24, 0x5B	; 91
    222c:	90 e0       	ldi	r25, 0x00	; 0
    222e:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    2232:	21 50       	subi	r18, 0x01	; 1
    2234:	30 40       	sbci	r19, 0x00	; 0
    2236:	40 40       	sbci	r20, 0x00	; 0
    2238:	50 40       	sbci	r21, 0x00	; 0
    223a:	80 91 32 01 	lds	r24, 0x0132
    223e:	80 68       	ori	r24, 0x80	; 128
    2240:	80 93 32 01 	sts	0x0132, r24
    2244:	80 91 32 01 	lds	r24, 0x0132
    2248:	80 64       	ori	r24, 0x40	; 64
    224a:	80 93 32 01 	sts	0x0132, r24
    224e:	03 c0       	rjmp	.+6      	; 0x2256 <__stack+0x57>
// Bit 3    USBS: Stop Bit Select
// Bit 2:1  UCSZ1:0: Character Size
// Bit 0    UCPOL: Clock Polarity

	
long int UBBR3=0;
    2250:	20 e0       	ldi	r18, 0x00	; 0
    2252:	30 e0       	ldi	r19, 0x00	; 0
    2254:	a9 01       	movw	r20, r18
	  	case 2: UBBR3 = F_CPU/8/BAUD-1; 	UCSR3A |= 1<<U2X3;	UCSR3C &= ~(0<<UMSEL31);	UCSR3C &= ~(0<<UMSEL30);	break;		//	   
	  	case 3: UBBR3 = F_CPU/2/BAUD-1;  						UCSR3C |= 1<<UMSEL31;	 	UCSR3C |= 1<<UMSEL30;		break;		//	SPI
	}
		
 
		UBRR3L = UBBR3&0x00FF;
    2256:	20 93 34 01 	sts	0x0134, r18
		UBRR3H = (UBBR3>>8)&0x00FF;
    225a:	23 2f       	mov	r18, r19
    225c:	34 2f       	mov	r19, r20
    225e:	45 2f       	mov	r20, r21
    2260:	55 27       	eor	r21, r21
    2262:	47 fd       	sbrc	r20, 7
    2264:	5a 95       	dec	r21
    2266:	20 93 35 01 	sts	0x0135, r18


	
switch (Parity) 
    226a:	8f 2d       	mov	r24, r15
    226c:	82 30       	cpi	r24, 0x02	; 2
    226e:	41 f0       	breq	.+16     	; 0x2280 <__stack+0x81>
    2270:	83 30       	cpi	r24, 0x03	; 3
    2272:	79 f0       	breq	.+30     	; 0x2292 <__stack+0x93>
    2274:	ff 20       	and	r15, r15
    2276:	91 f4       	brne	.+36     	; 0x229c <__stack+0x9d>
	{ 
		case 0:   UCSR3C &= ~((1<<UPM31)|(1<<UPM30));  	break;  //  
    2278:	80 91 32 01 	lds	r24, 0x0132
    227c:	8f 7c       	andi	r24, 0xCF	; 207
    227e:	0c c0       	rjmp	.+24     	; 0x2298 <__stack+0x99>
		case 1:   break;  										// reserved
	  	case 2:   UCSR3C |= ((1<<UPM31));				UCSR3C &= ~(1<<UPM30);  	break;  //  
    2280:	80 91 32 01 	lds	r24, 0x0132
    2284:	80 62       	ori	r24, 0x20	; 32
    2286:	80 93 32 01 	sts	0x0132, r24
    228a:	80 91 32 01 	lds	r24, 0x0132
    228e:	8f 7e       	andi	r24, 0xEF	; 239
    2290:	03 c0       	rjmp	.+6      	; 0x2298 <__stack+0x99>
	  	case 3:   UCSR3C |= ((1<<UPM31)|(1<<UPM30));								break;  //  
    2292:	80 91 32 01 	lds	r24, 0x0132
    2296:	80 63       	ori	r24, 0x30	; 48
    2298:	80 93 32 01 	sts	0x0132, r24
	}

switch (StopBits) 
    229c:	8e 2d       	mov	r24, r14
    229e:	81 30       	cpi	r24, 0x01	; 1
    22a0:	19 f0       	breq	.+6      	; 0x22a8 <__stack+0xa9>
    22a2:	82 30       	cpi	r24, 0x02	; 2
    22a4:	51 f4       	brne	.+20     	; 0x22ba <__stack+0xbb>
    22a6:	04 c0       	rjmp	.+8      	; 0x22b0 <__stack+0xb1>
	{ 
		case 1:   UCSR3C &= ~(1<<USBS3); 		break;  	//    
    22a8:	80 91 32 01 	lds	r24, 0x0132
    22ac:	87 7f       	andi	r24, 0xF7	; 247
    22ae:	03 c0       	rjmp	.+6      	; 0x22b6 <__stack+0xb7>
	  	case 2:   UCSR3C |= (1<<USBS3);  		break;  	//     
    22b0:	80 91 32 01 	lds	r24, 0x0132
    22b4:	88 60       	ori	r24, 0x08	; 8
    22b6:	80 93 32 01 	sts	0x0132, r24
	}

switch (CharacterSize) 
    22ba:	17 30       	cpi	r17, 0x07	; 7
    22bc:	f1 f0       	breq	.+60     	; 0x22fa <__stack+0xfb>
    22be:	18 30       	cpi	r17, 0x08	; 8
    22c0:	28 f4       	brcc	.+10     	; 0x22cc <__stack+0xcd>
    22c2:	15 30       	cpi	r17, 0x05	; 5
    22c4:	41 f0       	breq	.+16     	; 0x22d6 <__stack+0xd7>
    22c6:	16 30       	cpi	r17, 0x06	; 6
    22c8:	99 f5       	brne	.+102    	; 0x2330 <__stack+0x131>
    22ca:	0e c0       	rjmp	.+28     	; 0x22e8 <__stack+0xe9>
    22cc:	18 30       	cpi	r17, 0x08	; 8
    22ce:	11 f1       	breq	.+68     	; 0x2314 <__stack+0x115>
    22d0:	19 30       	cpi	r17, 0x09	; 9
    22d2:	71 f5       	brne	.+92     	; 0x2330 <__stack+0x131>
    22d4:	23 c0       	rjmp	.+70     	; 0x231c <__stack+0x11d>
	{ 
		case 5:   UCSR3B &= ~(1<<UCSZ32);  											UCSR3C &= ~((1<<UCSZ31)|(1<<UCSZ30));  	break;  // 5  
    22d6:	80 91 31 01 	lds	r24, 0x0131
    22da:	8b 7f       	andi	r24, 0xFB	; 251
    22dc:	80 93 31 01 	sts	0x0131, r24
    22e0:	80 91 32 01 	lds	r24, 0x0132
    22e4:	89 7f       	andi	r24, 0xF9	; 249
    22e6:	22 c0       	rjmp	.+68     	; 0x232c <__stack+0x12d>
	  	case 6:   UCSR3B &= ~(1<<UCSZ32); 	UCSR3C |= ((1<<UCSZ30)); 				UCSR3C &= ~(0<<UCSZ31);  				break;  // 6  
    22e8:	80 91 31 01 	lds	r24, 0x0131
    22ec:	8b 7f       	andi	r24, 0xFB	; 251
    22ee:	80 93 31 01 	sts	0x0131, r24
    22f2:	80 91 32 01 	lds	r24, 0x0132
    22f6:	82 60       	ori	r24, 0x02	; 2
    22f8:	08 c0       	rjmp	.+16     	; 0x230a <__stack+0x10b>
		case 7:   UCSR3B &= ~(1<<UCSZ32); 	UCSR3C |= ((1<<UCSZ31));				UCSR3C &= ~(0<<UCSZ30);   				break;  // 7  
    22fa:	80 91 31 01 	lds	r24, 0x0131
    22fe:	8b 7f       	andi	r24, 0xFB	; 251
    2300:	80 93 31 01 	sts	0x0131, r24
    2304:	80 91 32 01 	lds	r24, 0x0132
    2308:	84 60       	ori	r24, 0x04	; 4
    230a:	80 93 32 01 	sts	0x0132, r24
    230e:	80 91 32 01 	lds	r24, 0x0132
    2312:	0c c0       	rjmp	.+24     	; 0x232c <__stack+0x12d>
	  	case 8:   UCSR3B &= ~(1<<UCSZ32); 	UCSR3C |= ((1<<UCSZ31)|(1<<UCSZ30));  											break;  // 8  
    2314:	80 91 31 01 	lds	r24, 0x0131
    2318:	8b 7f       	andi	r24, 0xFB	; 251
    231a:	03 c0       	rjmp	.+6      	; 0x2322 <__stack+0x123>
		case 9:   UCSR3B |=   1<<UCSZ32;  	UCSR3C |= ((1<<UCSZ31)|(1<<UCSZ30)); 											break;  // 9  
    231c:	80 91 31 01 	lds	r24, 0x0131
    2320:	84 60       	ori	r24, 0x04	; 4
    2322:	80 93 31 01 	sts	0x0131, r24
    2326:	80 91 32 01 	lds	r24, 0x0132
    232a:	86 60       	ori	r24, 0x06	; 6
    232c:	80 93 32 01 	sts	0x0132, r24
	}

	UCSR3C &= ~(1<<UCPOL3);		
    2330:	80 91 32 01 	lds	r24, 0x0132
    2334:	8e 7f       	andi	r24, 0xFE	; 254
    2336:	80 93 32 01 	sts	0x0132, r24
//	UCSR3C |= 	1<<UCPOL3;
}
    233a:	1f 91       	pop	r17
    233c:	0f 91       	pop	r16
    233e:	ff 90       	pop	r15
    2340:	ef 90       	pop	r14
    2342:	08 95       	ret

00002344 <SendToUart0>:



void SendToUart0(unsigned char Data)
{
	UDR0 = Data;
    2344:	80 93 c6 00 	sts	0x00C6, r24
	
	while(!( UCSR0A & (1<<UDRE0)));
    2348:	80 91 c0 00 	lds	r24, 0x00C0
    234c:	85 ff       	sbrs	r24, 5
    234e:	fc cf       	rjmp	.-8      	; 0x2348 <SendToUart0+0x4>
} 
    2350:	08 95       	ret

00002352 <SendToUart1>:

void SendToUart1(unsigned char Data)
{
	UDR1 = Data;
    2352:	80 93 ce 00 	sts	0x00CE, r24
	
	while(!( UCSR1A & (1<<UDRE1)));
    2356:	80 91 c8 00 	lds	r24, 0x00C8
    235a:	85 ff       	sbrs	r24, 5
    235c:	fc cf       	rjmp	.-8      	; 0x2356 <SendToUart1+0x4>
}
    235e:	08 95       	ret

00002360 <SendToUart2>:

void SendToUart2(unsigned char Data)
{
	UDR2 = Data;
    2360:	80 93 d6 00 	sts	0x00D6, r24
	
	while(!( UCSR2A & (1<<UDRE2)));
    2364:	80 91 d0 00 	lds	r24, 0x00D0
    2368:	85 ff       	sbrs	r24, 5
    236a:	fc cf       	rjmp	.-8      	; 0x2364 <SendToUart2+0x4>
}  
    236c:	08 95       	ret

0000236e <SendToUart3>:

void SendToUart3(unsigned char Data)
{
	UDR3 = Data;
    236e:	80 93 36 01 	sts	0x0136, r24
	
	while(!( UCSR3A & (1<<UDRE3)));
    2372:	80 91 30 01 	lds	r24, 0x0130
    2376:	85 ff       	sbrs	r24, 5
    2378:	fc cf       	rjmp	.-8      	; 0x2372 <SendToUart3+0x4>
} 
    237a:	08 95       	ret

0000237c <transmitStringToUart>:
	
	return(data);
}

void transmitStringToUart(uint8_t uart_numb, unsigned char* string)
{
    237c:	ef 92       	push	r14
    237e:	ff 92       	push	r15
    2380:	cf 93       	push	r28
    2382:	df 93       	push	r29
  switch(uart_numb) {
    2384:	81 30       	cpi	r24, 0x01	; 1
    2386:	69 f0       	breq	.+26     	; 0x23a2 <transmitStringToUart+0x26>
    2388:	81 30       	cpi	r24, 0x01	; 1
    238a:	28 f0       	brcs	.+10     	; 0x2396 <transmitStringToUart+0x1a>
    238c:	82 30       	cpi	r24, 0x02	; 2
    238e:	79 f0       	breq	.+30     	; 0x23ae <transmitStringToUart+0x32>
    2390:	83 30       	cpi	r24, 0x03	; 3
    2392:	c9 f4       	brne	.+50     	; 0x23c6 <transmitStringToUart+0x4a>
    2394:	12 c0       	rjmp	.+36     	; 0x23ba <transmitStringToUart+0x3e>
    2396:	e6 2e       	mov	r14, r22
    2398:	e7 01       	movw	r28, r14
    239a:	7e 01       	movw	r14, r28
    239c:	f7 2e       	mov	r15, r23
    239e:	e7 01       	movw	r28, r14
    23a0:	1a c0       	rjmp	.+52     	; 0x23d6 <transmitStringToUart+0x5a>
    23a2:	e6 2e       	mov	r14, r22
    23a4:	e7 01       	movw	r28, r14
    23a6:	7e 01       	movw	r14, r28
    23a8:	f7 2e       	mov	r15, r23
    23aa:	e7 01       	movw	r28, r14
    23ac:	1b c0       	rjmp	.+54     	; 0x23e4 <transmitStringToUart+0x68>
    23ae:	e6 2e       	mov	r14, r22
    23b0:	e7 01       	movw	r28, r14
    23b2:	7e 01       	movw	r14, r28
    23b4:	f7 2e       	mov	r15, r23
    23b6:	e7 01       	movw	r28, r14
    23b8:	1c c0       	rjmp	.+56     	; 0x23f2 <transmitStringToUart+0x76>
    23ba:	e6 2e       	mov	r14, r22
    23bc:	e7 01       	movw	r28, r14
    23be:	7e 01       	movw	r14, r28
    23c0:	f7 2e       	mov	r15, r23
    23c2:	e7 01       	movw	r28, r14
    23c4:	1d c0       	rjmp	.+58     	; 0x2400 <transmitStringToUart+0x84>
    23c6:	e6 2e       	mov	r14, r22
    23c8:	e7 01       	movw	r28, r14
    23ca:	7e 01       	movw	r14, r28
    23cc:	f7 2e       	mov	r15, r23
    23ce:	e7 01       	movw	r28, r14
    23d0:	1e c0       	rjmp	.+60     	; 0x240e <transmitStringToUart+0x92>
  case 0:  while (*string) SendToUart0(*string++);
    23d2:	0e 94 a2 11 	call	0x2344	; 0x2344 <SendToUart0>
    23d6:	be 01       	movw	r22, r28
    23d8:	89 91       	ld	r24, Y+
    23da:	88 23       	and	r24, r24
    23dc:	d1 f7       	brne	.-12     	; 0x23d2 <transmitStringToUart+0x56>
    23de:	e1 cf       	rjmp	.-62     	; 0x23a2 <transmitStringToUart+0x26>
  case 1:  while (*string) SendToUart1(*string++);
    23e0:	0e 94 a9 11 	call	0x2352	; 0x2352 <SendToUart1>
    23e4:	be 01       	movw	r22, r28
    23e6:	89 91       	ld	r24, Y+
    23e8:	88 23       	and	r24, r24
    23ea:	d1 f7       	brne	.-12     	; 0x23e0 <transmitStringToUart+0x64>
    23ec:	e0 cf       	rjmp	.-64     	; 0x23ae <transmitStringToUart+0x32>
  case 2:  while (*string) SendToUart2(*string++);
    23ee:	0e 94 b0 11 	call	0x2360	; 0x2360 <SendToUart2>
    23f2:	be 01       	movw	r22, r28
    23f4:	89 91       	ld	r24, Y+
    23f6:	88 23       	and	r24, r24
    23f8:	d1 f7       	brne	.-12     	; 0x23ee <transmitStringToUart+0x72>
    23fa:	df cf       	rjmp	.-66     	; 0x23ba <transmitStringToUart+0x3e>
  case 3:  while (*string) SendToUart3(*string++);
    23fc:	0e 94 b7 11 	call	0x236e	; 0x236e <SendToUart3>
    2400:	be 01       	movw	r22, r28
    2402:	89 91       	ld	r24, Y+
    2404:	88 23       	and	r24, r24
    2406:	d1 f7       	brne	.-12     	; 0x23fc <transmitStringToUart+0x80>
    2408:	de cf       	rjmp	.-68     	; 0x23c6 <transmitStringToUart+0x4a>
  default: while (*string) SendToUart0(*string++);
    240a:	0e 94 a2 11 	call	0x2344	; 0x2344 <SendToUart0>
    240e:	89 91       	ld	r24, Y+
    2410:	88 23       	and	r24, r24
    2412:	d9 f7       	brne	.-10     	; 0x240a <transmitStringToUart+0x8e>
 }
}
    2414:	df 91       	pop	r29
    2416:	cf 91       	pop	r28
    2418:	ff 90       	pop	r15
    241a:	ef 90       	pop	r14
    241c:	08 95       	ret

0000241e <vHd44780NibbleWrite>:

#define nop()		asm("nop")

void vHd44780NibbleWrite(uint8_t nibble)
{
	high(E);
    241e:	12 9a       	sbi	0x02, 2	; 2
	HD44780_PORT &= ~HD44780_DB_MASK;
    2420:	92 b1       	in	r25, 0x02	; 2
    2422:	97 78       	andi	r25, 0x87	; 135
    2424:	92 b9       	out	0x02, r25	; 2
	HD44780_PORT |= (nibble&0xf)<<HD44780_DB;
    2426:	22 b1       	in	r18, 0x02	; 2
    2428:	90 e0       	ldi	r25, 0x00	; 0
    242a:	8f 70       	andi	r24, 0x0F	; 15
    242c:	90 70       	andi	r25, 0x00	; 0
    242e:	33 e0       	ldi	r19, 0x03	; 3
    2430:	88 0f       	add	r24, r24
    2432:	99 1f       	adc	r25, r25
    2434:	3a 95       	dec	r19
    2436:	e1 f7       	brne	.-8      	; 0x2430 <vHd44780NibbleWrite+0x12>
    2438:	28 2b       	or	r18, r24
    243a:	22 b9       	out	0x02, r18	; 2
	...
	nop(); nop();
	nop(); nop();
	low(E);
    2444:	12 98       	cbi	0x02, 2	; 2
}
    2446:	08 95       	ret

00002448 <ucHd44780NibbleRead>:

uint8_t ucHd44780NibbleRead()
{
	uint8_t nib;

	high(E);
    2448:	12 9a       	sbi	0x02, 2	; 2
	HD44780_PORT &= ~HD44780_DB_MASK;
    244a:	82 b1       	in	r24, 0x02	; 2
    244c:	87 78       	andi	r24, 0x87	; 135
    244e:	82 b9       	out	0x02, r24	; 2
	...
	nop(); nop();
	nop(); nop();
	nib = (HD44780_PIN>>HD44780_DB)&0xf;
    2458:	80 b1       	in	r24, 0x00	; 0
	low(E);
    245a:	12 98       	cbi	0x02, 2	; 2

	high(E);
	HD44780_PORT &= ~HD44780_DB_MASK;
	nop(); nop();
	nop(); nop();
	nib = (HD44780_PIN>>HD44780_DB)&0xf;
    245c:	86 95       	lsr	r24
    245e:	86 95       	lsr	r24
    2460:	86 95       	lsr	r24
	low(E);
	return nib;
}
    2462:	8f 70       	andi	r24, 0x0F	; 15
    2464:	08 95       	ret

00002466 <ucHd44780BusyRead>:

uint8_t ucHd44780BusyRead()
{
    2466:	1f 93       	push	r17
	uint8_t byte;

	high(RW);
    2468:	11 9a       	sbi	0x02, 1	; 2
	HD44780_DDR &= ~HD44780_DB_MASK;
    246a:	81 b1       	in	r24, 0x01	; 1
    246c:	87 78       	andi	r24, 0x87	; 135
    246e:	81 b9       	out	0x01, r24	; 1
	byte = (ucHd44780NibbleRead()<<4)|
    2470:	0e 94 24 12 	call	0x2448	; 0x2448 <ucHd44780NibbleRead>
    2474:	18 2f       	mov	r17, r24
		ucHd44780NibbleRead();
    2476:	0e 94 24 12 	call	0x2448	; 0x2448 <ucHd44780NibbleRead>
	low(RW);
    247a:	11 98       	cbi	0x02, 1	; 2
	HD44780_DDR |= HD44780_DB_MASK;
    247c:	91 b1       	in	r25, 0x01	; 1
    247e:	98 67       	ori	r25, 0x78	; 120
    2480:	91 b9       	out	0x01, r25	; 1
{
	uint8_t byte;

	high(RW);
	HD44780_DDR &= ~HD44780_DB_MASK;
	byte = (ucHd44780NibbleRead()<<4)|
    2482:	12 95       	swap	r17
    2484:	10 7f       	andi	r17, 0xF0	; 240
    2486:	18 2b       	or	r17, r24
		ucHd44780NibbleRead();
	low(RW);
	HD44780_DDR |= HD44780_DB_MASK;
	return byte&0x80;
}
    2488:	81 2f       	mov	r24, r17
    248a:	80 78       	andi	r24, 0x80	; 128
    248c:	1f 91       	pop	r17
    248e:	08 95       	ret

00002490 <vHd44780Cmd>:

void vHd44780Cmd(uint8_t byte)
{
    2490:	1f 93       	push	r17
    2492:	18 2f       	mov	r17, r24
	while(ucHd44780BusyRead())
    2494:	0e 94 33 12 	call	0x2466	; 0x2466 <ucHd44780BusyRead>
    2498:	88 23       	and	r24, r24
    249a:	e1 f7       	brne	.-8      	; 0x2494 <vHd44780Cmd+0x4>
		;

	vHd44780NibbleWrite(byte>>4);
    249c:	81 2f       	mov	r24, r17
    249e:	82 95       	swap	r24
    24a0:	8f 70       	andi	r24, 0x0F	; 15
    24a2:	0e 94 0f 12 	call	0x241e	; 0x241e <vHd44780NibbleWrite>
	vHd44780NibbleWrite(byte);
    24a6:	81 2f       	mov	r24, r17
    24a8:	0e 94 0f 12 	call	0x241e	; 0x241e <vHd44780NibbleWrite>
}
    24ac:	1f 91       	pop	r17
    24ae:	08 95       	ret

000024b0 <vHd44780DataWrite>:
	HD44780_DDR |= HD44780_DB_MASK;
	return byte;
}

void vHd44780DataWrite(uint8_t byte)
{
    24b0:	1f 93       	push	r17
    24b2:	18 2f       	mov	r17, r24
	while(ucHd44780BusyRead())
    24b4:	0e 94 33 12 	call	0x2466	; 0x2466 <ucHd44780BusyRead>
    24b8:	88 23       	and	r24, r24
    24ba:	e1 f7       	brne	.-8      	; 0x24b4 <vHd44780DataWrite+0x4>
		;

	high(RS);
    24bc:	10 9a       	sbi	0x02, 0	; 2
	vHd44780NibbleWrite(byte>>4);
    24be:	81 2f       	mov	r24, r17
    24c0:	82 95       	swap	r24
    24c2:	8f 70       	andi	r24, 0x0F	; 15
    24c4:	0e 94 0f 12 	call	0x241e	; 0x241e <vHd44780NibbleWrite>
	vHd44780NibbleWrite(byte);
    24c8:	81 2f       	mov	r24, r17
    24ca:	0e 94 0f 12 	call	0x241e	; 0x241e <vHd44780NibbleWrite>
	low(RS);
    24ce:	10 98       	cbi	0x02, 0	; 2
}
    24d0:	1f 91       	pop	r17
    24d2:	08 95       	ret

000024d4 <vHd44780Init>:

void vHd44780Init()
{
	HD44780_DDR |= HD44780_DB_MASK|(1<<HD44780_RS)|
    24d4:	81 b1       	in	r24, 0x01	; 1
    24d6:	8f 67       	ori	r24, 0x7F	; 127
    24d8:	81 b9       	out	0x01, r24	; 1
		(1<<HD44780_RW)|(1<<HD44780_E);
	
	vHd44780NibbleWrite(3);
    24da:	83 e0       	ldi	r24, 0x03	; 3
    24dc:	0e 94 0f 12 	call	0x241e	; 0x241e <vHd44780NibbleWrite>
    24e0:	87 e9       	ldi	r24, 0x97	; 151
    24e2:	9a e3       	ldi	r25, 0x3A	; 58
    24e4:	01 97       	sbiw	r24, 0x01	; 1
    24e6:	f1 f7       	brne	.-4      	; 0x24e4 <vHd44780Init+0x10>
    24e8:	00 c0       	rjmp	.+0      	; 0x24ea <vHd44780Init+0x16>
    24ea:	00 00       	nop
	_delay_ms(5);
	vHd44780NibbleWrite(3);
    24ec:	83 e0       	ldi	r24, 0x03	; 3
    24ee:	0e 94 0f 12 	call	0x241e	; 0x241e <vHd44780NibbleWrite>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    24f2:	8f ed       	ldi	r24, 0xDF	; 223
    24f4:	91 e0       	ldi	r25, 0x01	; 1
    24f6:	01 97       	sbiw	r24, 0x01	; 1
    24f8:	f1 f7       	brne	.-4      	; 0x24f6 <vHd44780Init+0x22>
    24fa:	00 c0       	rjmp	.+0      	; 0x24fc <vHd44780Init+0x28>
    24fc:	00 00       	nop
	_delay_us(160);
	vHd44780NibbleWrite(3);
    24fe:	83 e0       	ldi	r24, 0x03	; 3
    2500:	0e 94 0f 12 	call	0x241e	; 0x241e <vHd44780NibbleWrite>
    2504:	8f ed       	ldi	r24, 0xDF	; 223
    2506:	91 e0       	ldi	r25, 0x01	; 1
    2508:	01 97       	sbiw	r24, 0x01	; 1
    250a:	f1 f7       	brne	.-4      	; 0x2508 <vHd44780Init+0x34>
    250c:	00 c0       	rjmp	.+0      	; 0x250e <vHd44780Init+0x3a>
    250e:	00 00       	nop
	_delay_us(160);
	vHd44780NibbleWrite(2);
    2510:	82 e0       	ldi	r24, 0x02	; 2
    2512:	0e 94 0f 12 	call	0x241e	; 0x241e <vHd44780NibbleWrite>
}
    2516:	08 95       	ret

00002518 <vHd44780PutString>:

void vHd44780PutString(char *str)
{
    2518:	ef 92       	push	r14
    251a:	ff 92       	push	r15
    251c:	cf 93       	push	r28
    251e:	df 93       	push	r29
    2520:	e8 2e       	mov	r14, r24
    2522:	e7 01       	movw	r28, r14
    2524:	7e 01       	movw	r14, r28
    2526:	f9 2e       	mov	r15, r25
    2528:	e7 01       	movw	r28, r14
	while(*str)
    252a:	02 c0       	rjmp	.+4      	; 0x2530 <vHd44780PutString+0x18>
		vHd44780DataWrite(*(str++));
    252c:	0e 94 58 12 	call	0x24b0	; 0x24b0 <vHd44780DataWrite>
	vHd44780NibbleWrite(2);
}

void vHd44780PutString(char *str)
{
	while(*str)
    2530:	89 91       	ld	r24, Y+
    2532:	88 23       	and	r24, r24
    2534:	d9 f7       	brne	.-10     	; 0x252c <vHd44780PutString+0x14>
		vHd44780DataWrite(*(str++));
}
    2536:	df 91       	pop	r29
    2538:	cf 91       	pop	r28
    253a:	ff 90       	pop	r15
    253c:	ef 90       	pop	r14
    253e:	08 95       	ret

00002540 <vLcdBusyLoop>:
	//This function waits till lcd is BUSY

	uint8_t busy,status=0x00,temp;

	//Change Port to input type because we are reading data
	LCD_DATA_DDR&=(~(0x0f<<LCD_DATA_POS));
    2540:	81 b1       	in	r24, 0x01	; 1
    2542:	87 78       	andi	r24, 0x87	; 135
    2544:	81 b9       	out	0x01, r24	; 1

	//change LCD mode
	LcdSet_RW();		//Read mode
    2546:	11 9a       	sbi	0x02, 1	; 2
	LcdClear_RS();		//Read status
    2548:	10 98       	cbi	0x02, 0	; 2
    254a:	82 e0       	ldi	r24, 0x02	; 2
    254c:	8a 95       	dec	r24
    254e:	f1 f7       	brne	.-4      	; 0x254c <vLcdBusyLoop+0xc>

	
	do
	{

		LcdSet_E();
    2550:	12 9a       	sbi	0x02, 2	; 2
    2552:	92 e0       	ldi	r25, 0x02	; 2
    2554:	9a 95       	dec	r25
    2556:	f1 f7       	brne	.-4      	; 0x2554 <vLcdBusyLoop+0x14>

		//Wait tDA for data to become available
		_delay_us(0.5);

		status=(LCD_DATA_PIN>>LCD_DATA_POS);
    2558:	80 b1       	in	r24, 0x00	; 0
    255a:	86 95       	lsr	r24
    255c:	86 95       	lsr	r24
    255e:	86 95       	lsr	r24
		status=status<<4;
    2560:	82 95       	swap	r24
    2562:	80 7f       	andi	r24, 0xF0	; 240
    2564:	92 e0       	ldi	r25, 0x02	; 2
    2566:	9a 95       	dec	r25
    2568:	f1 f7       	brne	.-4      	; 0x2566 <vLcdBusyLoop+0x26>

		_delay_us(0.5);

		//Pull E low
		LcdClear_E();
    256a:	12 98       	cbi	0x02, 2	; 2
    256c:	94 e0       	ldi	r25, 0x04	; 4
    256e:	9a 95       	dec	r25
    2570:	f1 f7       	brne	.-4      	; 0x256e <vLcdBusyLoop+0x2e>
		_delay_us(1);	//tEL

		LcdSet_E();
    2572:	12 9a       	sbi	0x02, 2	; 2
    2574:	92 e0       	ldi	r25, 0x02	; 2
    2576:	9a 95       	dec	r25
    2578:	f1 f7       	brne	.-4      	; 0x2576 <vLcdBusyLoop+0x36>
		_delay_us(0.5);

		temp=(LCD_DATA_PIN>>LCD_DATA_POS);
    257a:	90 b1       	in	r25, 0x00	; 0
    257c:	92 e0       	ldi	r25, 0x02	; 2
    257e:	9a 95       	dec	r25
    2580:	f1 f7       	brne	.-4      	; 0x257e <vLcdBusyLoop+0x3e>
		status=status|temp;

		busy=status & 0b10000000;

		_delay_us(0.5);
		LcdClear_E();
    2582:	12 98       	cbi	0x02, 2	; 2
    2584:	94 e0       	ldi	r25, 0x04	; 4
    2586:	9a 95       	dec	r25
    2588:	f1 f7       	brne	.-4      	; 0x2586 <vLcdBusyLoop+0x46>
		_delay_us(1);	//tEL
	}while(busy);
    258a:	87 fd       	sbrc	r24, 7
    258c:	e1 cf       	rjmp	.-62     	; 0x2550 <vLcdBusyLoop+0x10>

	LcdClear_RW();		//write mode
    258e:	11 98       	cbi	0x02, 1	; 2
	//Change Port to output
	LCD_DATA_DDR|=(0x0F<<LCD_DATA_POS);
    2590:	81 b1       	in	r24, 0x01	; 1
    2592:	88 67       	ori	r24, 0x78	; 120
    2594:	81 b9       	out	0x01, r24	; 1

}
    2596:	08 95       	ret

00002598 <vLcdByte>:
//NOTE: THIS FUNCTION RETURS ONLY WHEN LCD HAS PROCESSED THE COMMAND

uint8_t hn,ln;			//Nibbles
uint8_t temp;

hn=c>>4;
    2598:	98 2f       	mov	r25, r24
    259a:	92 95       	swap	r25
    259c:	9f 70       	andi	r25, 0x0F	; 15
ln=(c & 0x0F);
    259e:	8f 70       	andi	r24, 0x0F	; 15

if(isdata==0)
    25a0:	66 23       	and	r22, r22
    25a2:	11 f4       	brne	.+4      	; 0x25a8 <vLcdByte+0x10>
	LcdClear_RS();
    25a4:	10 98       	cbi	0x02, 0	; 2
    25a6:	01 c0       	rjmp	.+2      	; 0x25aa <vLcdByte+0x12>
else
	LcdSet_RS();
    25a8:	10 9a       	sbi	0x02, 0	; 2
    25aa:	22 e0       	ldi	r18, 0x02	; 2
    25ac:	2a 95       	dec	r18
    25ae:	f1 f7       	brne	.-4      	; 0x25ac <vLcdByte+0x14>

_delay_us(0.500);		//tAS

LcdSet_E();
    25b0:	12 9a       	sbi	0x02, 2	; 2

//Send high nibble

temp=(LcdDataPort & (~(0X0F<<LCD_DATA_POS)))|((hn<<LCD_DATA_POS));
    25b2:	22 b1       	in	r18, 0x02	; 2
    25b4:	99 0f       	add	r25, r25
    25b6:	99 0f       	add	r25, r25
    25b8:	99 0f       	add	r25, r25
    25ba:	27 78       	andi	r18, 0x87	; 135
    25bc:	92 2b       	or	r25, r18
LcdDataPort=temp;
    25be:	92 b9       	out	0x02, r25	; 2
    25c0:	94 e0       	ldi	r25, 0x04	; 4
    25c2:	9a 95       	dec	r25
    25c4:	f1 f7       	brne	.-4      	; 0x25c2 <vLcdByte+0x2a>

_delay_us(1);			//tEH

//Now data lines are stable pull E low for transmission

LcdClear_E();
    25c6:	12 98       	cbi	0x02, 2	; 2
    25c8:	24 e0       	ldi	r18, 0x04	; 4
    25ca:	2a 95       	dec	r18
    25cc:	f1 f7       	brne	.-4      	; 0x25ca <vLcdByte+0x32>

_delay_us(1);

//Send the lower nibble
LcdSet_E();
    25ce:	12 9a       	sbi	0x02, 2	; 2

temp=(LcdDataPort & (~(0X0F<<LCD_DATA_POS)))|((ln<<LCD_DATA_POS));
    25d0:	92 b1       	in	r25, 0x02	; 2
    25d2:	88 0f       	add	r24, r24
    25d4:	88 0f       	add	r24, r24
    25d6:	88 0f       	add	r24, r24
    25d8:	97 78       	andi	r25, 0x87	; 135
    25da:	89 2b       	or	r24, r25

LcdDataPort=temp;
    25dc:	82 b9       	out	0x02, r24	; 2
    25de:	84 e0       	ldi	r24, 0x04	; 4
    25e0:	8a 95       	dec	r24
    25e2:	f1 f7       	brne	.-4      	; 0x25e0 <vLcdByte+0x48>

_delay_us(1);			//tEH

//SEND

LcdClear_E();
    25e4:	12 98       	cbi	0x02, 2	; 2
    25e6:	94 e0       	ldi	r25, 0x04	; 4
    25e8:	9a 95       	dec	r25
    25ea:	f1 f7       	brne	.-4      	; 0x25e8 <vLcdByte+0x50>

_delay_us(1);			//tEL

vLcdBusyLoop();
    25ec:	0e 94 a0 12 	call	0x2540	; 0x2540 <vLcdBusyLoop>
}
    25f0:	08 95       	ret

000025f2 <vLcdInit>:
	LCD_DATA_DDR|=(0x0F<<LCD_DATA_POS);

}

void vLcdInit(uint8_t style)
{
    25f2:	df 93       	push	r29
    25f4:	cf 93       	push	r28
    25f6:	0f 92       	push	r0
    25f8:	cd b7       	in	r28, 0x3d	; 61
    25fa:	de b7       	in	r29, 0x3e	; 62
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    25fc:	2f e3       	ldi	r18, 0x3F	; 63
    25fe:	39 e1       	ldi	r19, 0x19	; 25
    2600:	41 e0       	ldi	r20, 0x01	; 1
    2602:	21 50       	subi	r18, 0x01	; 1
    2604:	30 40       	sbci	r19, 0x00	; 0
    2606:	40 40       	sbci	r20, 0x00	; 0
    2608:	e1 f7       	brne	.-8      	; 0x2602 <vLcdInit+0x10>
    260a:	00 c0       	rjmp	.+0      	; 0x260c <vLcdInit+0x1a>
    260c:	00 00       	nop
	
	//After power on Wait for LCD to Initialize
	_delay_ms(30);
	
	//Set IO Ports
	LCD_DATA_DDR|=(0x0F<<LCD_DATA_POS);
    260e:	91 b1       	in	r25, 0x01	; 1
    2610:	98 67       	ori	r25, 0x78	; 120
    2612:	91 b9       	out	0x01, r25	; 1
	LCD_E_DDR|=(1<<LCD_E_POS);
    2614:	0a 9a       	sbi	0x01, 2	; 1
	LCD_RS_DDR|=(1<<LCD_RS_POS);
    2616:	08 9a       	sbi	0x01, 0	; 1
	LCD_RW_DDR|=(1<<LCD_RW_POS);
    2618:	09 9a       	sbi	0x01, 1	; 1

	LcdDataPort&=(~(0x0F<<LCD_DATA_POS));
    261a:	92 b1       	in	r25, 0x02	; 2
    261c:	97 78       	andi	r25, 0x87	; 135
    261e:	92 b9       	out	0x02, r25	; 2
	LcdClear_E();
    2620:	12 98       	cbi	0x02, 2	; 2
	LcdClear_RW();
    2622:	11 98       	cbi	0x02, 1	; 2
	LcdClear_RS();
    2624:	10 98       	cbi	0x02, 0	; 2
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2626:	00 c0       	rjmp	.+0      	; 0x2628 <vLcdInit+0x36>
    2628:	00 c0       	rjmp	.+0      	; 0x262a <vLcdInit+0x38>

	//Set 4-bit mode
	_delay_us(0.3);	//tAS

	LcdSet_E();
    262a:	12 9a       	sbi	0x02, 2	; 2
	LcdDataPort|=((0b00000010)<<LCD_DATA_POS); //[B] To transfer 0b00100000 i was using LCD_DATA_PORT|=0b00100000
    262c:	14 9a       	sbi	0x02, 4	; 2
    262e:	34 e0       	ldi	r19, 0x04	; 4
    2630:	3a 95       	dec	r19
    2632:	f1 f7       	brne	.-4      	; 0x2630 <vLcdInit+0x3e>
	_delay_us(1);
	LcdClear_E();
    2634:	12 98       	cbi	0x02, 2	; 2
    2636:	44 e0       	ldi	r20, 0x04	; 4
    2638:	4a 95       	dec	r20
    263a:	f1 f7       	brne	.-4      	; 0x2638 <vLcdInit+0x46>
	_delay_us(1);
	
	//Wait for LCD to execute the Functionset Command
	vLcdBusyLoop();                                    //[B] Forgot this delay
    263c:	89 83       	std	Y+1, r24	; 0x01
    263e:	0e 94 a0 12 	call	0x2540	; 0x2540 <vLcdBusyLoop>

	//Now the LCD is in 4-bit mode

	vLcdCmd(0b00001100|style);	//Display On
    2642:	89 81       	ldd	r24, Y+1	; 0x01
    2644:	8c 60       	ori	r24, 0x0C	; 12
    2646:	60 e0       	ldi	r22, 0x00	; 0
    2648:	0e 94 cc 12 	call	0x2598	; 0x2598 <vLcdByte>
	vLcdCmd(0b00101000);			//function set 4-bit,2 line 5x7 dot format
    264c:	88 e2       	ldi	r24, 0x28	; 40
    264e:	60 e0       	ldi	r22, 0x00	; 0
    2650:	0e 94 cc 12 	call	0x2598	; 0x2598 <vLcdByte>
}
    2654:	0f 90       	pop	r0
    2656:	cf 91       	pop	r28
    2658:	df 91       	pop	r29
    265a:	08 95       	ret

0000265c <vLcdGotoXY>:
}


void vLcdGotoXY(uint8_t x,uint8_t y)
{
 if(x<40)
    265c:	88 32       	cpi	r24, 0x28	; 40
    265e:	30 f4       	brcc	.+12     	; 0x266c <vLcdGotoXY+0x10>
 {
  if(y) x|=0b01000000;
    2660:	61 11       	cpse	r22, r1
    2662:	80 64       	ori	r24, 0x40	; 64
  x|=0b10000000;
  vLcdCmd(x);
    2664:	80 68       	ori	r24, 0x80	; 128
    2666:	60 e0       	ldi	r22, 0x00	; 0
    2668:	0e 94 cc 12 	call	0x2598	; 0x2598 <vLcdByte>
    266c:	08 95       	ret

0000266e <I2CInit>:
//--------------------------------- ---------------------------------//
//    TWI
void I2CInit(void)
{
	//  TWI  
	TWBR = 2;
    266e:	82 e0       	ldi	r24, 0x02	; 2
    2670:	80 93 b8 00 	sts	0x00B8, r24
	TWSR = (1 << TWPS1)|(1 << TWPS0); //   64
    2674:	83 e0       	ldi	r24, 0x03	; 3
    2676:	80 93 b9 00 	sts	0x00B9, r24
	TWCR |= (1 << TWEN); //   TWI
    267a:	ec eb       	ldi	r30, 0xBC	; 188
    267c:	f0 e0       	ldi	r31, 0x00	; 0
    267e:	80 81       	ld	r24, Z
    2680:	84 60       	ori	r24, 0x04	; 4
    2682:	80 83       	st	Z, r24
}
    2684:	08 95       	ret

00002686 <SPIInit>:

********************************************************************/
void SPIInit()
{
	//Set up SPI I/O Ports
	SPI_DDR|=((1<<MOSI_POS)|(1<<SCK_POS)|(1<<SS_POS));
    2686:	84 b1       	in	r24, 0x04	; 4
    2688:	87 60       	ori	r24, 0x07	; 7
    268a:	84 b9       	out	0x04, r24	; 4
	
	SPI_PORT|=(1<<SS_POS);
    268c:	28 9a       	sbi	0x05, 0	; 5

	//Chip Select PIN is initialize as HIGH i.e. Idle
	//CS PIN is always Active Low (inverted)
	CS_DDR|=(1<<CS_POS);
    268e:	20 9a       	sbi	0x04, 0	; 4
	CS_HIGH();
    2690:	28 9a       	sbi	0x05, 0	; 5
	*Above two implies SPI MODE0
	*SCK Freq = FCPU/16 i.e. 1MHz

	*/

	SPCR|=(1<<SPE)|(1<<MSTR)|(1<<SPR0);
    2692:	8c b5       	in	r24, 0x2c	; 44
    2694:	81 65       	ori	r24, 0x51	; 81
    2696:	8c bd       	out	0x2c, r24	; 44
}
    2698:	08 95       	ret

0000269a <SPIWrite>:

********************************************************************/
uint8_t SPIWrite(uint8_t data)
{
	/* Start transmission */
	SPDR = data;
    269a:	8e bd       	out	0x2e, r24	; 46
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    269c:	0d b4       	in	r0, 0x2d	; 45
    269e:	07 fe       	sbrs	r0, 7
    26a0:	fd cf       	rjmp	.-6      	; 0x269c <SPIWrite+0x2>

	return (SPDR);
    26a2:	8e b5       	in	r24, 0x2e	; 46
}
    26a4:	08 95       	ret

000026a6 <SPIPINON>:

}

void SPIPINON(void)
{
	DDR_SPI |= (1<<DD_MOSI)|(1<<DD_SCK);				// pin out
    26a6:	84 b1       	in	r24, 0x04	; 4
    26a8:	86 60       	ori	r24, 0x06	; 6
    26aa:	84 b9       	out	0x04, r24	; 4
	DDR_SPI &= ~(1<<DD_MISO);							// pin in
    26ac:	23 98       	cbi	0x04, 3	; 4
}
    26ae:	08 95       	ret

000026b0 <SPION>:
	SPCR &= ~(1<<SPIE);	
}

void SPION(void)
{
	SPCR |= 1<<SPE;				// SPI on
    26b0:	8c b5       	in	r24, 0x2c	; 44
    26b2:	80 64       	ori	r24, 0x40	; 64
    26b4:	8c bd       	out	0x2c, r24	; 44
}
    26b6:	08 95       	ret

000026b8 <SlaveSPISelectOFF>:
	PORT_SPI &= ~(1<<DD_SS);
}

void SlaveSPISelectOFF(void)
{
	PORT_SPI |= 1<<DD_SS;
    26b8:	2c 9a       	sbi	0x05, 4	; 5
}
    26ba:	08 95       	ret

000026bc <InitSPI>:
#include "spils020.h"
#include <avr/io.h>

void InitSPI(char Mode, char Setings, char DivFrequency, char Direction)
{
    26bc:	ff 92       	push	r15
    26be:	0f 93       	push	r16
    26c0:	1f 93       	push	r17
    26c2:	df 93       	push	r29
    26c4:	cf 93       	push	r28
    26c6:	0f 92       	push	r0
    26c8:	cd b7       	in	r28, 0x3d	; 61
    26ca:	de b7       	in	r29, 0x3e	; 62
    26cc:	16 2f       	mov	r17, r22
    26ce:	04 2f       	mov	r16, r20
    26d0:	f2 2e       	mov	r15, r18

 	SPIPINON();
    26d2:	89 83       	std	Y+1, r24	; 0x01
    26d4:	0e 94 53 13 	call	0x26a6	; 0x26a6 <SPIPINON>

//Direction
//	0  -  MSB of the data word is transmitted first
//	1  -  LSB of the data word is transmitted first

	SPCR = 0x00;
    26d8:	1c bc       	out	0x2c, r1	; 44
	SPSR = 0x00;
    26da:	1d bc       	out	0x2d, r1	; 45
// Bit 4  MSTR: Master/Slave Select 
// Bit 3  CPOL: Clock Polarity 
// Bit 2  CPHA: Clock Phase 
// Bits 1, 0  SPR1, SPR0: SPI Clock Rate Select 1 and 0 

	SPSR = 1<<SPIF|0<<WCOL|0<<SPI2X;
    26dc:	90 e8       	ldi	r25, 0x80	; 128
    26de:	9d bd       	out	0x2d, r25	; 45
// Bit 6  WCOL: Write COLlision flag 
// Bit 5..1  Res: Reserved Bits 
// Bit 0  SPI2X: Double SPI Speed Bit 


switch (Mode) 
    26e0:	89 81       	ldd	r24, Y+1	; 0x01
    26e2:	88 23       	and	r24, r24
    26e4:	19 f0       	breq	.+6      	; 0x26ec <InitSPI+0x30>
    26e6:	81 30       	cpi	r24, 0x01	; 1
    26e8:	61 f4       	brne	.+24     	; 0x2702 <InitSPI+0x46>
    26ea:	07 c0       	rjmp	.+14     	; 0x26fa <InitSPI+0x3e>
	{ 
		case 0:  SPCR |= 1<<MSTR;			DDR_SPI |= 1<<DD_SS; 	SlaveSPISelectOFF();break;		//Master
    26ec:	8c b5       	in	r24, 0x2c	; 44
    26ee:	80 61       	ori	r24, 0x10	; 16
    26f0:	8c bd       	out	0x2c, r24	; 44
    26f2:	24 9a       	sbi	0x04, 4	; 4
    26f4:	0e 94 5c 13 	call	0x26b8	; 0x26b8 <SlaveSPISelectOFF>
    26f8:	04 c0       	rjmp	.+8      	; 0x2702 <InitSPI+0x46>
	  	case 1:	 SPCR &= ~(1<<MSTR);		DDR_SPI &= ~(1<<DD_SS);						break;		//Slave
    26fa:	8c b5       	in	r24, 0x2c	; 44
    26fc:	8f 7e       	andi	r24, 0xEF	; 239
    26fe:	8c bd       	out	0x2c, r24	; 44
    2700:	24 98       	cbi	0x04, 4	; 4
	}

switch (Setings) 
    2702:	11 30       	cpi	r17, 0x01	; 1
    2704:	51 f0       	breq	.+20     	; 0x271a <InitSPI+0x5e>
    2706:	11 30       	cpi	r17, 0x01	; 1
    2708:	28 f0       	brcs	.+10     	; 0x2714 <InitSPI+0x58>
    270a:	12 30       	cpi	r17, 0x02	; 2
    270c:	61 f0       	breq	.+24     	; 0x2726 <InitSPI+0x6a>
    270e:	13 30       	cpi	r17, 0x03	; 3
    2710:	99 f4       	brne	.+38     	; 0x2738 <InitSPI+0x7c>
    2712:	0f c0       	rjmp	.+30     	; 0x2732 <InitSPI+0x76>
	{ 
		case 0:	 SPCR &= ~((1<<CPOL)|(1<<CPHA));  					break;  
    2714:	8c b5       	in	r24, 0x2c	; 44
    2716:	83 7f       	andi	r24, 0xF3	; 243
    2718:	0e c0       	rjmp	.+28     	; 0x2736 <InitSPI+0x7a>
	  	case 1:  SPCR &= ~(1<<CPOL); 			SPCR |= 1<<CPHA;	break;  
    271a:	8c b5       	in	r24, 0x2c	; 44
    271c:	87 7f       	andi	r24, 0xF7	; 247
    271e:	8c bd       	out	0x2c, r24	; 44
    2720:	8c b5       	in	r24, 0x2c	; 44
    2722:	84 60       	ori	r24, 0x04	; 4
    2724:	08 c0       	rjmp	.+16     	; 0x2736 <InitSPI+0x7a>
	  	case 2:  SPCR &= ~(1<<CPHA); 			SPCR |= 1<<CPOL;	break;  
    2726:	8c b5       	in	r24, 0x2c	; 44
    2728:	8b 7f       	andi	r24, 0xFB	; 251
    272a:	8c bd       	out	0x2c, r24	; 44
    272c:	8c b5       	in	r24, 0x2c	; 44
    272e:	88 60       	ori	r24, 0x08	; 8
    2730:	02 c0       	rjmp	.+4      	; 0x2736 <InitSPI+0x7a>
	  	case 3:  SPCR |=  (1<<CPOL)|(1<<CPHA); 						break;  
    2732:	8c b5       	in	r24, 0x2c	; 44
    2734:	8c 60       	ori	r24, 0x0C	; 12
    2736:	8c bd       	out	0x2c, r24	; 44
	}

switch (DivFrequency) 
    2738:	03 30       	cpi	r16, 0x03	; 3
    273a:	c9 f0       	breq	.+50     	; 0x276e <InitSPI+0xb2>
    273c:	04 30       	cpi	r16, 0x04	; 4
    273e:	28 f4       	brcc	.+10     	; 0x274a <InitSPI+0x8e>
    2740:	01 30       	cpi	r16, 0x01	; 1
    2742:	79 f0       	breq	.+30     	; 0x2762 <InitSPI+0xa6>
    2744:	02 30       	cpi	r16, 0x02	; 2
    2746:	80 f4       	brcc	.+32     	; 0x2768 <InitSPI+0xac>
    2748:	09 c0       	rjmp	.+18     	; 0x275c <InitSPI+0xa0>
    274a:	05 30       	cpi	r16, 0x05	; 5
    274c:	c9 f0       	breq	.+50     	; 0x2780 <InitSPI+0xc4>
    274e:	05 30       	cpi	r16, 0x05	; 5
    2750:	88 f0       	brcs	.+34     	; 0x2774 <InitSPI+0xb8>
    2752:	06 30       	cpi	r16, 0x06	; 6
    2754:	f1 f0       	breq	.+60     	; 0x2792 <InitSPI+0xd6>
    2756:	07 30       	cpi	r16, 0x07	; 7
    2758:	59 f5       	brne	.+86     	; 0x27b0 <InitSPI+0xf4>
    275a:	24 c0       	rjmp	.+72     	; 0x27a4 <InitSPI+0xe8>
	{ 
		case 0:	 SPSR &= ~(1<<SPI2X);  			SPCR &= ~((1<<SPR1)|(1<<SPR0));							break;  
    275c:	8d b5       	in	r24, 0x2d	; 45
    275e:	8e 7f       	andi	r24, 0xFE	; 254
    2760:	0b c0       	rjmp	.+22     	; 0x2778 <InitSPI+0xbc>
	  	case 1:	 SPSR &= ~(1<<SPI2X);  			SPCR &= ~(1<<SPR1); 			SPCR |= 1<<SPR0;		break; 
    2762:	8d b5       	in	r24, 0x2d	; 45
    2764:	8e 7f       	andi	r24, 0xFE	; 254
    2766:	0e c0       	rjmp	.+28     	; 0x2784 <InitSPI+0xc8>
	  	case 2:  SPSR &= ~(1<<SPI2X);  			SPCR &= ~(1<<SPR0); 			SPCR |= 1<<SPR1;		break; 
    2768:	8d b5       	in	r24, 0x2d	; 45
    276a:	8e 7f       	andi	r24, 0xFE	; 254
    276c:	14 c0       	rjmp	.+40     	; 0x2796 <InitSPI+0xda>
	  	case 3:  SPSR &= ~(1<<SPI2X);  			SPCR |= (1<<SPR1)|(1<<SPR0);							break; 
    276e:	8d b5       	in	r24, 0x2d	; 45
    2770:	8e 7f       	andi	r24, 0xFE	; 254
    2772:	1a c0       	rjmp	.+52     	; 0x27a8 <InitSPI+0xec>
		case 4:	 SPSR |= 1<<SPI2X;  			SPCR &= ~((1<<SPR1)|(1<<SPR0));							break;  
    2774:	8d b5       	in	r24, 0x2d	; 45
    2776:	81 60       	ori	r24, 0x01	; 1
    2778:	8d bd       	out	0x2d, r24	; 45
    277a:	8c b5       	in	r24, 0x2c	; 44
    277c:	8c 7f       	andi	r24, 0xFC	; 252
    277e:	17 c0       	rjmp	.+46     	; 0x27ae <InitSPI+0xf2>
	  	case 5:	 SPSR |= 1<<SPI2X;  			SPCR &= ~(1<<SPR1); 			SPCR |= 1<<SPR0;		break; 
    2780:	8d b5       	in	r24, 0x2d	; 45
    2782:	81 60       	ori	r24, 0x01	; 1
    2784:	8d bd       	out	0x2d, r24	; 45
    2786:	8c b5       	in	r24, 0x2c	; 44
    2788:	8d 7f       	andi	r24, 0xFD	; 253
    278a:	8c bd       	out	0x2c, r24	; 44
    278c:	8c b5       	in	r24, 0x2c	; 44
    278e:	81 60       	ori	r24, 0x01	; 1
    2790:	0e c0       	rjmp	.+28     	; 0x27ae <InitSPI+0xf2>
	  	case 6:  SPSR |= 1<<SPI2X;  			SPCR &= ~(1<<SPR0); 			SPCR |= 1<<SPR1;		break; 
    2792:	8d b5       	in	r24, 0x2d	; 45
    2794:	81 60       	ori	r24, 0x01	; 1
    2796:	8d bd       	out	0x2d, r24	; 45
    2798:	8c b5       	in	r24, 0x2c	; 44
    279a:	8e 7f       	andi	r24, 0xFE	; 254
    279c:	8c bd       	out	0x2c, r24	; 44
    279e:	8c b5       	in	r24, 0x2c	; 44
    27a0:	82 60       	ori	r24, 0x02	; 2
    27a2:	05 c0       	rjmp	.+10     	; 0x27ae <InitSPI+0xf2>
	  	case 7:  SPSR |= 1<<SPI2X;  			SPCR |= (1<<SPR1)|(1<<SPR0);							break;
    27a4:	8d b5       	in	r24, 0x2d	; 45
    27a6:	81 60       	ori	r24, 0x01	; 1
    27a8:	8d bd       	out	0x2d, r24	; 45
    27aa:	8c b5       	in	r24, 0x2c	; 44
    27ac:	83 60       	ori	r24, 0x03	; 3
    27ae:	8c bd       	out	0x2c, r24	; 44
	}

switch (Direction) 
    27b0:	ff 20       	and	r15, r15
    27b2:	21 f0       	breq	.+8      	; 0x27bc <InitSPI+0x100>
    27b4:	8f 2d       	mov	r24, r15
    27b6:	81 30       	cpi	r24, 0x01	; 1
    27b8:	39 f4       	brne	.+14     	; 0x27c8 <InitSPI+0x10c>
    27ba:	03 c0       	rjmp	.+6      	; 0x27c2 <InitSPI+0x106>
	{ 
		case 0:  SPCR &= ~(1<<DORD);	break;		// MSB first
    27bc:	8c b5       	in	r24, 0x2c	; 44
    27be:	8f 7d       	andi	r24, 0xDF	; 223
    27c0:	02 c0       	rjmp	.+4      	; 0x27c6 <InitSPI+0x10a>
	  	case 1:	 SPCR |= 1<<DORD;		break;		// LSB first
    27c2:	8c b5       	in	r24, 0x2c	; 44
    27c4:	80 62       	ori	r24, 0x20	; 32
    27c6:	8c bd       	out	0x2c, r24	; 44
	}

	SPION();
    27c8:	0e 94 58 13 	call	0x26b0	; 0x26b0 <SPION>

}
    27cc:	0f 90       	pop	r0
    27ce:	cf 91       	pop	r28
    27d0:	df 91       	pop	r29
    27d2:	1f 91       	pop	r17
    27d4:	0f 91       	pop	r16
    27d6:	ff 90       	pop	r15
    27d8:	08 95       	ret

000027da <vLs020WriteCmd8>:
//------------------------------------------------------------------------------------------------------
//   8 
void vLs020WriteCmd8(char cmd8)									//   (8)
{

  	LS020_PORT_RS |= (1<<LS020_RS);								// Set RS
    27da:	2f 9a       	sbi	0x05, 7	; 5
  	LS020_PORT_CS &= ~(1<<LS020_CS); 							// select LCD											
    27dc:	2d 98       	cbi	0x05, 5	; 5
  	SPDR = cmd8;
    27de:	8e bd       	out	0x2e, r24	; 46
  	while ( !(SPSR & (1 << SPIF)));
    27e0:	0d b4       	in	r0, 0x2d	; 45
    27e2:	07 fe       	sbrs	r0, 7
    27e4:	fd cf       	rjmp	.-6      	; 0x27e0 <vLs020WriteCmd8+0x6>
  	LS020_PORT_CS |= (1<<LS020_CS); 							// deselect LCD
    27e6:	2d 9a       	sbi	0x05, 5	; 5

}
    27e8:	08 95       	ret

000027ea <vLs020WriteCmd16>:

//------------------------------------------------------------------------------------------------------
//   16 
void vLs020WriteCmd16(uint16_t  cmd16)								//   (16)
{
    27ea:	1f 93       	push	r17
    27ec:	18 2f       	mov	r17, r24
  	vLs020WriteCmd8((cmd16 >> 8) & 0xFF);
    27ee:	89 2f       	mov	r24, r25
    27f0:	0e 94 ed 13 	call	0x27da	; 0x27da <vLs020WriteCmd8>
  	vLs020WriteCmd8(cmd16 & 0xFF);
    27f4:	81 2f       	mov	r24, r17
    27f6:	0e 94 ed 13 	call	0x27da	; 0x27da <vLs020WriteCmd8>
}
    27fa:	1f 91       	pop	r17
    27fc:	08 95       	ret

000027fe <vLs020Mode8bit.clone.0>:
//  8- 
// 0 -   RGB
// 1 -   RGB
void vLs020Mode8bit(char BGR) 									// BGR = 0 - disabled, BGR = 1 - enabled.
{
  	vLs020WriteCmd16(0xEF90);
    27fe:	80 e9       	ldi	r24, 0x90	; 144
    2800:	9f ee       	ldi	r25, 0xEF	; 239
    2802:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
	vLs020WriteCmd16(0xE800 + (BGR&0x01)*0x40);
    2806:	80 e0       	ldi	r24, 0x00	; 0
    2808:	98 ee       	ldi	r25, 0xE8	; 232
    280a:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
}
    280e:	08 95       	ret

00002810 <vLs020WriteData8>:
//------------------------------------------------------------------------------------------------------
//   8 
void vLs020WriteData8(char data8)									//  
{

	LS020_PORT_RS &= ~(1<<LS020_RS); 							// Clear RS
    2810:	2f 98       	cbi	0x05, 7	; 5
	LS020_PORT_CS &= ~(1<<LS020_CS); 							// select LCD 
    2812:	2d 98       	cbi	0x05, 5	; 5
  	SPDR = data8;
    2814:	8e bd       	out	0x2e, r24	; 46
  	while ( !(SPSR & (1 << SPIF)));
    2816:	0d b4       	in	r0, 0x2d	; 45
    2818:	07 fe       	sbrs	r0, 7
    281a:	fd cf       	rjmp	.-6      	; 0x2816 <vLs020WriteData8+0x6>
	LS020_PORT_CS |= (1<<LS020_CS); 							// deselect LCD 
    281c:	2d 9a       	sbi	0x05, 5	; 5

}
    281e:	08 95       	ret

00002820 <vLs020WriteData16>:

//------------------------------------------------------------------------------------------------------
//   16 
void vLs020WriteData16(uint16_t data16)
{
    2820:	1f 93       	push	r17
    2822:	18 2f       	mov	r17, r24
 	vLs020WriteData8((data16>>8) & 0xFF);
    2824:	89 2f       	mov	r24, r25
    2826:	0e 94 08 14 	call	0x2810	; 0x2810 <vLs020WriteData8>
	vLs020WriteData8(data16 & 0xFF);
    282a:	81 2f       	mov	r24, r17
    282c:	0e 94 08 14 	call	0x2810	; 0x2810 <vLs020WriteData8>
}
    2830:	1f 91       	pop	r17
    2832:	08 95       	ret

00002834 <vLs020Init>:


//------------------------------------------------------------------------------------------------------
//  
void vLs020Init(void)										// 
{
    2834:	cf 93       	push	r28
    2836:	df 93       	push	r29
  	LS020_DDR_RS  |= 1<<LS020_RS;
    2838:	27 9a       	sbi	0x04, 7	; 4
  	LS020_DDR_RST |= 1<<LS020_RST;
    283a:	26 9a       	sbi	0x04, 6	; 4
	LS020_DDR_CS  |= 1<<LS020_CS;
    283c:	25 9a       	sbi	0x04, 5	; 4

  	LS020_PORT_RS  |= 1<<LS020_RS;
    283e:	2f 9a       	sbi	0x05, 7	; 5
  	LS020_PORT_RST |= 1<<LS020_RST;
    2840:	2e 9a       	sbi	0x05, 6	; 5
	LS020_PORT_CS  |= 1<<LS020_CS;
    2842:	2d 9a       	sbi	0x05, 5	; 5
			
	LS020_PORT_RST &= ~(1<<LS020_RST); 							// Pull RST pin down
    2844:	2e 98       	cbi	0x05, 6	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2846:	8f e2       	ldi	r24, 0x2F	; 47
    2848:	95 e7       	ldi	r25, 0x75	; 117
    284a:	01 97       	sbiw	r24, 0x01	; 1
    284c:	f1 f7       	brne	.-4      	; 0x284a <vLs020Init+0x16>
    284e:	00 c0       	rjmp	.+0      	; 0x2850 <vLs020Init+0x1c>
    2850:	00 00       	nop
//  PORTB &= ~(1<<RST); 										// Pull RST pin down
  	_delay_ms(10);

  	LS020_PORT_RST |= (1<<LS020_RST); 							// Release RST pin
    2852:	2e 9a       	sbi	0x05, 6	; 5
    2854:	c0 e0       	ldi	r28, 0x00	; 0
    2856:	d0 e0       	ldi	r29, 0x00	; 0

  	for (unsigned char i=0; i<24; i++)
    	vLs020WriteCmd8(pgm_read_byte(init_array_0+i));
    2858:	fe 01       	movw	r30, r28
    285a:	ec 5d       	subi	r30, 0xDC	; 220
    285c:	f3 4f       	sbci	r31, 0xF3	; 243
    285e:	84 91       	lpm	r24, Z+
    2860:	0e 94 ed 13 	call	0x27da	; 0x27da <vLs020WriteCmd8>
    2864:	21 96       	adiw	r28, 0x01	; 1
//  PORTB &= ~(1<<RST); 										// Pull RST pin down
  	_delay_ms(10);

  	LS020_PORT_RST |= (1<<LS020_RST); 							// Release RST pin

  	for (unsigned char i=0; i<24; i++)
    2866:	c8 31       	cpi	r28, 0x18	; 24
    2868:	d1 05       	cpc	r29, r1
    286a:	b1 f7       	brne	.-20     	; 0x2858 <vLs020Init+0x24>
    286c:	87 e0       	ldi	r24, 0x07	; 7
    286e:	92 e5       	ldi	r25, 0x52	; 82
    2870:	01 97       	sbiw	r24, 0x01	; 1
    2872:	f1 f7       	brne	.-4      	; 0x2870 <vLs020Init+0x3c>
    2874:	00 c0       	rjmp	.+0      	; 0x2876 <vLs020Init+0x42>
    2876:	00 00       	nop
    2878:	c0 e0       	ldi	r28, 0x00	; 0
    287a:	d0 e0       	ldi	r29, 0x00	; 0
    	vLs020WriteCmd8(pgm_read_byte(init_array_0+i));
  	_delay_ms(7);
  	for (unsigned char i=0; i<46; i++)
    	vLs020WriteCmd8(pgm_read_byte(init_array_1+i));
    287c:	fe 01       	movw	r30, r28
    287e:	e4 5c       	subi	r30, 0xC4	; 196
    2880:	f3 4f       	sbci	r31, 0xF3	; 243
    2882:	84 91       	lpm	r24, Z+
    2884:	0e 94 ed 13 	call	0x27da	; 0x27da <vLs020WriteCmd8>
    2888:	21 96       	adiw	r28, 0x01	; 1
  	LS020_PORT_RST |= (1<<LS020_RST); 							// Release RST pin

  	for (unsigned char i=0; i<24; i++)
    	vLs020WriteCmd8(pgm_read_byte(init_array_0+i));
  	_delay_ms(7);
  	for (unsigned char i=0; i<46; i++)
    288a:	ce 32       	cpi	r28, 0x2E	; 46
    288c:	d1 05       	cpc	r29, r1
    288e:	b1 f7       	brne	.-20     	; 0x287c <vLs020Init+0x48>
    	vLs020WriteCmd8(pgm_read_byte(init_array_1+i));
}
    2890:	df 91       	pop	r29
    2892:	cf 91       	pop	r28
    2894:	08 95       	ret

00002896 <vLs020Mode8bit>:
//------------------------------------------------------------------------------------------------------
//  8- 
// 0 -   RGB
// 1 -   RGB
void vLs020Mode8bit(char BGR) 									// BGR = 0 - disabled, BGR = 1 - enabled.
{
    2896:	1f 93       	push	r17
    2898:	18 2f       	mov	r17, r24
  	vLs020WriteCmd16(0xEF90);
    289a:	80 e9       	ldi	r24, 0x90	; 144
    289c:	9f ee       	ldi	r25, 0xEF	; 239
    289e:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
	vLs020WriteCmd16(0xE800 + (BGR&0x01)*0x40);
    28a2:	81 2f       	mov	r24, r17
    28a4:	90 e0       	ldi	r25, 0x00	; 0
    28a6:	81 70       	andi	r24, 0x01	; 1
    28a8:	90 70       	andi	r25, 0x00	; 0
    28aa:	80 56       	subi	r24, 0x60	; 96
    28ac:	9c 4f       	sbci	r25, 0xFC	; 252
    28ae:	26 e0       	ldi	r18, 0x06	; 6
    28b0:	88 0f       	add	r24, r24
    28b2:	99 1f       	adc	r25, r25
    28b4:	2a 95       	dec	r18
    28b6:	e1 f7       	brne	.-8      	; 0x28b0 <vLs020Mode8bit+0x1a>
    28b8:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
}
    28bc:	1f 91       	pop	r17
    28be:	08 95       	ret

000028c0 <vLs020Mode16bit>:

//  16- 
void vLs020Mode16bit(void)										//  16 
{
  	vLs020WriteCmd16(0xEF90);
    28c0:	80 e9       	ldi	r24, 0x90	; 144
    28c2:	9f ee       	ldi	r25, 0xEF	; 239
    28c4:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
	vLs020WriteCmd16(0xE80F);
    28c8:	8f e0       	ldi	r24, 0x0F	; 15
    28ca:	98 ee       	ldi	r25, 0xE8	; 232
    28cc:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
}
    28d0:	08 95       	ret

000028d2 <vLs020SetDirection>:
// Direction = 0 -  
//   ,   
// Direction = 1 -  
//   ,   
void vLs020SetDirection(char Direction)								
{
    28d2:	1f 93       	push	r17
    28d4:	18 2f       	mov	r17, r24
	vLs020WriteCmd16(0xEF90);
    28d6:	80 e9       	ldi	r24, 0x90	; 144
    28d8:	9f ee       	ldi	r25, 0xEF	; 239
    28da:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
	vLs020WriteCmd16(0x0500 + Direction*0x0004);
    28de:	81 2f       	mov	r24, r17
    28e0:	90 e0       	ldi	r25, 0x00	; 0
    28e2:	80 5c       	subi	r24, 0xC0	; 192
    28e4:	9e 4f       	sbci	r25, 0xFE	; 254
    28e6:	88 0f       	add	r24, r24
    28e8:	99 1f       	adc	r25, r25
    28ea:	88 0f       	add	r24, r24
    28ec:	99 1f       	adc	r25, r25
    28ee:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
}
    28f2:	1f 91       	pop	r17
    28f4:	08 95       	ret

000028f6 <vLs020SetWindow>:
//------------------------------------------------------------------------------------------------------
//    
// x1,y1 -   
// x2,y2 -   
void vLs020SetWindow(char x1, char y1, char x2,char y2, char Direction)
{	
    28f6:	0f 93       	push	r16
    28f8:	1f 93       	push	r17
    28fa:	df 93       	push	r29
    28fc:	cf 93       	push	r28
    28fe:	00 d0       	rcall	.+0      	; 0x2900 <vLs020SetWindow+0xa>
    2900:	cd b7       	in	r28, 0x3d	; 61
    2902:	de b7       	in	r29, 0x3e	; 62
    2904:	18 2f       	mov	r17, r24
    2906:	80 2f       	mov	r24, r16
	vLs020SetDirection(Direction);
    2908:	2b 83       	std	Y+3, r18	; 0x03
    290a:	49 83       	std	Y+1, r20	; 0x01
    290c:	6a 83       	std	Y+2, r22	; 0x02
    290e:	0e 94 69 14 	call	0x28d2	; 0x28d2 <vLs020SetDirection>
  	vLs020WriteCmd16(0x0A00 + x1);
    2912:	81 2f       	mov	r24, r17
    2914:	90 e0       	ldi	r25, 0x00	; 0
    2916:	80 50       	subi	r24, 0x00	; 0
    2918:	96 4f       	sbci	r25, 0xF6	; 246
    291a:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
  	vLs020WriteCmd16(0x0B00 + x2);
    291e:	49 81       	ldd	r20, Y+1	; 0x01
    2920:	84 2f       	mov	r24, r20
    2922:	90 e0       	ldi	r25, 0x00	; 0
    2924:	80 50       	subi	r24, 0x00	; 0
    2926:	95 4f       	sbci	r25, 0xF5	; 245
    2928:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
  	vLs020WriteCmd16(0x0800 + y1);
    292c:	6a 81       	ldd	r22, Y+2	; 0x02
    292e:	86 2f       	mov	r24, r22
    2930:	90 e0       	ldi	r25, 0x00	; 0
    2932:	80 50       	subi	r24, 0x00	; 0
    2934:	98 4f       	sbci	r25, 0xF8	; 248
    2936:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
  	vLs020WriteCmd16(0x0900 + y2);
    293a:	2b 81       	ldd	r18, Y+3	; 0x03
    293c:	82 2f       	mov	r24, r18
    293e:	90 e0       	ldi	r25, 0x00	; 0
    2940:	80 50       	subi	r24, 0x00	; 0
    2942:	97 4f       	sbci	r25, 0xF7	; 247
    2944:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
}
    2948:	0f 90       	pop	r0
    294a:	0f 90       	pop	r0
    294c:	0f 90       	pop	r0
    294e:	cf 91       	pop	r28
    2950:	df 91       	pop	r29
    2952:	1f 91       	pop	r17
    2954:	0f 91       	pop	r16
    2956:	08 95       	ret

00002958 <vLs020LineVertical>:
//      1 -  , 2 -  , 
//  -     , 
// color - 
// bits_color - -   (8  16)
void vLs020LineVertical(char y1, char y2, char x, int color, char bits_color)
{
    2958:	af 92       	push	r10
    295a:	bf 92       	push	r11
    295c:	cf 92       	push	r12
    295e:	df 92       	push	r13
    2960:	ef 92       	push	r14
    2962:	ff 92       	push	r15
    2964:	0f 93       	push	r16
    2966:	1f 93       	push	r17
    2968:	df 93       	push	r29
    296a:	cf 93       	push	r28
    296c:	0f 92       	push	r0
    296e:	cd b7       	in	r28, 0x3d	; 61
    2970:	de b7       	in	r29, 0x3e	; 62
    2972:	f8 2e       	mov	r15, r24
    2974:	e6 2e       	mov	r14, r22
    2976:	12 2f       	mov	r17, r18
    2978:	d3 2e       	mov	r13, r19
    297a:	90 2f       	mov	r25, r16
	uint8_t color8,i;
	vLs020SetWindow(x, y1, x, y2, 1);
    297c:	84 2f       	mov	r24, r20
    297e:	6f 2d       	mov	r22, r15
    2980:	2e 2d       	mov	r18, r14
    2982:	01 e0       	ldi	r16, 0x01	; 1
    2984:	99 83       	std	Y+1, r25	; 0x01
    2986:	0e 94 7b 14 	call	0x28f6	; 0x28f6 <vLs020SetWindow>

	switch (bits_color)	
    298a:	99 81       	ldd	r25, Y+1	; 0x01
    298c:	98 30       	cpi	r25, 0x08	; 8
    298e:	19 f0       	breq	.+6      	; 0x2996 <vLs020LineVertical+0x3e>
    2990:	90 31       	cpi	r25, 0x10	; 16
    2992:	29 f5       	brne	.+74     	; 0x29de <vLs020LineVertical+0x86>
    2994:	12 c0       	rjmp	.+36     	; 0x29ba <vLs020LineVertical+0x62>
		{
		case 8:  
				vLs020Mode8bit(0);
    2996:	0e 94 ff 13 	call	0x27fe	; 0x27fe <vLs020Mode8bit.clone.0>
				color8 = color & 0x00FF;  	
				for( i = 0; i < (y2 - y1) + 1; i++)
    299a:	00 e0       	ldi	r16, 0x00	; 0
    299c:	ce 2c       	mov	r12, r14
    299e:	dd 24       	eor	r13, r13
    29a0:	cf 18       	sub	r12, r15
    29a2:	d1 08       	sbc	r13, r1
    29a4:	04 c0       	rjmp	.+8      	; 0x29ae <vLs020LineVertical+0x56>
					vLs020WriteData8(color8);
    29a6:	81 2f       	mov	r24, r17
    29a8:	0e 94 08 14 	call	0x2810	; 0x2810 <vLs020WriteData8>
	switch (bits_color)	
		{
		case 8:  
				vLs020Mode8bit(0);
				color8 = color & 0x00FF;  	
				for( i = 0; i < (y2 - y1) + 1; i++)
    29ac:	0f 5f       	subi	r16, 0xFF	; 255
    29ae:	80 2f       	mov	r24, r16
    29b0:	90 e0       	ldi	r25, 0x00	; 0
    29b2:	c8 16       	cp	r12, r24
    29b4:	d9 06       	cpc	r13, r25
    29b6:	bc f7       	brge	.-18     	; 0x29a6 <vLs020LineVertical+0x4e>
    29b8:	12 c0       	rjmp	.+36     	; 0x29de <vLs020LineVertical+0x86>
					vLs020WriteData8(color8);
				break;

		case 16: 
				vLs020Mode16bit(); 	
    29ba:	0e 94 60 14 	call	0x28c0	; 0x28c0 <vLs020Mode16bit>
				for( i = 0; i < (y2 - y1) + 1; i++)
    29be:	00 e0       	ldi	r16, 0x00	; 0
    29c0:	ae 2c       	mov	r10, r14
    29c2:	bb 24       	eor	r11, r11
    29c4:	af 18       	sub	r10, r15
    29c6:	b1 08       	sbc	r11, r1
    29c8:	05 c0       	rjmp	.+10     	; 0x29d4 <vLs020LineVertical+0x7c>
					vLs020WriteData16(color);
    29ca:	81 2f       	mov	r24, r17
    29cc:	9d 2d       	mov	r25, r13
    29ce:	0e 94 10 14 	call	0x2820	; 0x2820 <vLs020WriteData16>
					vLs020WriteData8(color8);
				break;

		case 16: 
				vLs020Mode16bit(); 	
				for( i = 0; i < (y2 - y1) + 1; i++)
    29d2:	0f 5f       	subi	r16, 0xFF	; 255
    29d4:	80 2f       	mov	r24, r16
    29d6:	90 e0       	ldi	r25, 0x00	; 0
    29d8:	a8 16       	cp	r10, r24
    29da:	b9 06       	cpc	r11, r25
    29dc:	b4 f7       	brge	.-20     	; 0x29ca <vLs020LineVertical+0x72>
					vLs020WriteData16(color);
				break;
		}

}
    29de:	0f 90       	pop	r0
    29e0:	cf 91       	pop	r28
    29e2:	df 91       	pop	r29
    29e4:	1f 91       	pop	r17
    29e6:	0f 91       	pop	r16
    29e8:	ff 90       	pop	r15
    29ea:	ef 90       	pop	r14
    29ec:	df 90       	pop	r13
    29ee:	cf 90       	pop	r12
    29f0:	bf 90       	pop	r11
    29f2:	af 90       	pop	r10
    29f4:	08 95       	ret

000029f6 <vLs020LineHorizontal>:
//      x1 -  , x2 -  , 
// y -     y, 
// color - 
// bits_color - -   (8  16)
void vLs020LineHorizontal(char x1, char x2, char y, int color, char bits_color)
{
    29f6:	af 92       	push	r10
    29f8:	bf 92       	push	r11
    29fa:	cf 92       	push	r12
    29fc:	df 92       	push	r13
    29fe:	ef 92       	push	r14
    2a00:	ff 92       	push	r15
    2a02:	0f 93       	push	r16
    2a04:	1f 93       	push	r17
    2a06:	df 93       	push	r29
    2a08:	cf 93       	push	r28
    2a0a:	0f 92       	push	r0
    2a0c:	cd b7       	in	r28, 0x3d	; 61
    2a0e:	de b7       	in	r29, 0x3e	; 62
    2a10:	f8 2e       	mov	r15, r24
    2a12:	e6 2e       	mov	r14, r22
    2a14:	54 2f       	mov	r21, r20
    2a16:	12 2f       	mov	r17, r18
    2a18:	d3 2e       	mov	r13, r19
    2a1a:	90 2f       	mov	r25, r16
	uint8_t color8,i;
	vLs020SetWindow(x1, y, x2, y, 0);
    2a1c:	64 2f       	mov	r22, r20
    2a1e:	4e 2d       	mov	r20, r14
    2a20:	25 2f       	mov	r18, r21
    2a22:	00 e0       	ldi	r16, 0x00	; 0
    2a24:	99 83       	std	Y+1, r25	; 0x01
    2a26:	0e 94 7b 14 	call	0x28f6	; 0x28f6 <vLs020SetWindow>
	
	switch (bits_color)	
    2a2a:	99 81       	ldd	r25, Y+1	; 0x01
    2a2c:	98 30       	cpi	r25, 0x08	; 8
    2a2e:	19 f0       	breq	.+6      	; 0x2a36 <vLs020LineHorizontal+0x40>
    2a30:	90 31       	cpi	r25, 0x10	; 16
    2a32:	29 f5       	brne	.+74     	; 0x2a7e <vLs020LineHorizontal+0x88>
    2a34:	12 c0       	rjmp	.+36     	; 0x2a5a <vLs020LineHorizontal+0x64>
		{
		case 8:  
				vLs020Mode8bit(0); 
    2a36:	0e 94 ff 13 	call	0x27fe	; 0x27fe <vLs020Mode8bit.clone.0>
				color8 = color & 0x00FF; 	
				for( i=0; i<(x2-x1) + 1; i++)
    2a3a:	00 e0       	ldi	r16, 0x00	; 0
    2a3c:	ce 2c       	mov	r12, r14
    2a3e:	dd 24       	eor	r13, r13
    2a40:	cf 18       	sub	r12, r15
    2a42:	d1 08       	sbc	r13, r1
    2a44:	04 c0       	rjmp	.+8      	; 0x2a4e <vLs020LineHorizontal+0x58>
					vLs020WriteData8(color8);
    2a46:	81 2f       	mov	r24, r17
    2a48:	0e 94 08 14 	call	0x2810	; 0x2810 <vLs020WriteData8>
	switch (bits_color)	
		{
		case 8:  
				vLs020Mode8bit(0); 
				color8 = color & 0x00FF; 	
				for( i=0; i<(x2-x1) + 1; i++)
    2a4c:	0f 5f       	subi	r16, 0xFF	; 255
    2a4e:	80 2f       	mov	r24, r16
    2a50:	90 e0       	ldi	r25, 0x00	; 0
    2a52:	c8 16       	cp	r12, r24
    2a54:	d9 06       	cpc	r13, r25
    2a56:	bc f7       	brge	.-18     	; 0x2a46 <vLs020LineHorizontal+0x50>
    2a58:	12 c0       	rjmp	.+36     	; 0x2a7e <vLs020LineHorizontal+0x88>
					vLs020WriteData8(color8);
			break;
		
		case 16: 
				vLs020Mode16bit(); 	
    2a5a:	0e 94 60 14 	call	0x28c0	; 0x28c0 <vLs020Mode16bit>
				for( i=0; i<(x2-x1)+1; i++)
    2a5e:	00 e0       	ldi	r16, 0x00	; 0
    2a60:	ae 2c       	mov	r10, r14
    2a62:	bb 24       	eor	r11, r11
    2a64:	af 18       	sub	r10, r15
    2a66:	b1 08       	sbc	r11, r1
    2a68:	05 c0       	rjmp	.+10     	; 0x2a74 <vLs020LineHorizontal+0x7e>
					vLs020WriteData16(color);
    2a6a:	81 2f       	mov	r24, r17
    2a6c:	9d 2d       	mov	r25, r13
    2a6e:	0e 94 10 14 	call	0x2820	; 0x2820 <vLs020WriteData16>
					vLs020WriteData8(color8);
			break;
		
		case 16: 
				vLs020Mode16bit(); 	
				for( i=0; i<(x2-x1)+1; i++)
    2a72:	0f 5f       	subi	r16, 0xFF	; 255
    2a74:	80 2f       	mov	r24, r16
    2a76:	90 e0       	ldi	r25, 0x00	; 0
    2a78:	a8 16       	cp	r10, r24
    2a7a:	b9 06       	cpc	r11, r25
    2a7c:	b4 f7       	brge	.-20     	; 0x2a6a <vLs020LineHorizontal+0x74>
					vLs020WriteData16(color);
			break;
		}
	 
}
    2a7e:	0f 90       	pop	r0
    2a80:	cf 91       	pop	r28
    2a82:	df 91       	pop	r29
    2a84:	1f 91       	pop	r17
    2a86:	0f 91       	pop	r16
    2a88:	ff 90       	pop	r15
    2a8a:	ef 90       	pop	r14
    2a8c:	df 90       	pop	r13
    2a8e:	cf 90       	pop	r12
    2a90:	bf 90       	pop	r11
    2a92:	af 90       	pop	r10
    2a94:	08 95       	ret

00002a96 <vLs020DrawSquare>:
//------------------------------------------------------------------------------------------------------
//  ()     
// color - 
// bits_color - -   (8  16)
void vLs020DrawSquare(char x1, char y1, char x2, char y2, int color, char bits_color) 
{
    2a96:	bf 92       	push	r11
    2a98:	cf 92       	push	r12
    2a9a:	df 92       	push	r13
    2a9c:	ef 92       	push	r14
    2a9e:	ff 92       	push	r15
    2aa0:	0f 93       	push	r16
    2aa2:	1f 93       	push	r17
    2aa4:	cf 93       	push	r28
    2aa6:	df 93       	push	r29
    2aa8:	d8 2e       	mov	r13, r24
    2aaa:	f6 2e       	mov	r15, r22
    2aac:	b4 2e       	mov	r11, r20
    2aae:	c2 2e       	mov	r12, r18
    2ab0:	e8 01       	movw	r28, r16

	vLs020LineHorizontal(x1, x2, y1, color, bits_color);
    2ab2:	64 2f       	mov	r22, r20
    2ab4:	4f 2d       	mov	r20, r15
    2ab6:	98 01       	movw	r18, r16
    2ab8:	0e 2d       	mov	r16, r14
    2aba:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <vLs020LineHorizontal>
	vLs020LineHorizontal(x1, x2, y2, color, bits_color);
    2abe:	8d 2d       	mov	r24, r13
    2ac0:	6b 2d       	mov	r22, r11
    2ac2:	4c 2d       	mov	r20, r12
    2ac4:	9e 01       	movw	r18, r28
    2ac6:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <vLs020LineHorizontal>
	vLs020LineVertical(y1, y2, x1, color, bits_color);
    2aca:	8f 2d       	mov	r24, r15
    2acc:	6c 2d       	mov	r22, r12
    2ace:	4d 2d       	mov	r20, r13
    2ad0:	9e 01       	movw	r18, r28
    2ad2:	0e 94 ac 14 	call	0x2958	; 0x2958 <vLs020LineVertical>
	vLs020LineVertical(y1, y2, x2, color, bits_color);
    2ad6:	8f 2d       	mov	r24, r15
    2ad8:	6c 2d       	mov	r22, r12
    2ada:	4b 2d       	mov	r20, r11
    2adc:	9e 01       	movw	r18, r28
    2ade:	0e 94 ac 14 	call	0x2958	; 0x2958 <vLs020LineVertical>
}
    2ae2:	df 91       	pop	r29
    2ae4:	cf 91       	pop	r28
    2ae6:	1f 91       	pop	r17
    2ae8:	0f 91       	pop	r16
    2aea:	ff 90       	pop	r15
    2aec:	ef 90       	pop	r14
    2aee:	df 90       	pop	r13
    2af0:	cf 90       	pop	r12
    2af2:	bf 90       	pop	r11
    2af4:	08 95       	ret

00002af6 <vLs020Rotation>:
// 7 - mirror image, +90 degree 		- 	  90     
//											   (  x1y1)
//											    

void vLs020Rotation(char x, char y, char CHARH, char CHARW, char mode)
{
    2af6:	af 92       	push	r10
    2af8:	bf 92       	push	r11
    2afa:	cf 92       	push	r12
    2afc:	df 92       	push	r13
    2afe:	ef 92       	push	r14
    2b00:	ff 92       	push	r15
    2b02:	0f 93       	push	r16
    2b04:	1f 93       	push	r17
    2b06:	df 93       	push	r29
    2b08:	cf 93       	push	r28
    2b0a:	0f 92       	push	r0
    2b0c:	0f 92       	push	r0
    2b0e:	cd b7       	in	r28, 0x3d	; 61
    2b10:	de b7       	in	r29, 0x3e	; 62
    2b12:	d8 2e       	mov	r13, r24
    2b14:	c4 2e       	mov	r12, r20
    2b16:	e2 2e       	mov	r14, r18
	
	vLs020WriteCmd16(0xEF80);
    2b18:	80 e8       	ldi	r24, 0x80	; 128
    2b1a:	9f ee       	ldi	r25, 0xEF	; 239
    2b1c:	0a 83       	std	Y+2, r16	; 0x02
    2b1e:	69 83       	std	Y+1, r22	; 0x01
    2b20:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
	vLs020WriteCmd16(0x1800 + mode);
    2b24:	2a 81       	ldd	r18, Y+2	; 0x02
    2b26:	82 2f       	mov	r24, r18
    2b28:	90 e0       	ldi	r25, 0x00	; 0
    2b2a:	80 50       	subi	r24, 0x00	; 0
    2b2c:	98 4e       	sbci	r25, 0xE8	; 232
    2b2e:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>

	switch(mode)
    2b32:	2a 81       	ldd	r18, Y+2	; 0x02
    2b34:	69 81       	ldd	r22, Y+1	; 0x01
    2b36:	23 30       	cpi	r18, 0x03	; 3
    2b38:	09 f4       	brne	.+2      	; 0x2b3c <vLs020Rotation+0x46>
    2b3a:	64 c0       	rjmp	.+200    	; 0x2c04 <vLs020Rotation+0x10e>
    2b3c:	24 30       	cpi	r18, 0x04	; 4
    2b3e:	60 f4       	brcc	.+24     	; 0x2b58 <vLs020Rotation+0x62>
    2b40:	21 30       	cpi	r18, 0x01	; 1
    2b42:	71 f1       	breq	.+92     	; 0x2ba0 <vLs020Rotation+0xaa>
    2b44:	06 2f       	mov	r16, r22
    2b46:	10 e0       	ldi	r17, 0x00	; 0
    2b48:	ff 24       	eor	r15, r15
    2b4a:	ad 2c       	mov	r10, r13
    2b4c:	bb 24       	eor	r11, r11
    2b4e:	dd 24       	eor	r13, r13
    2b50:	22 30       	cpi	r18, 0x02	; 2
    2b52:	08 f0       	brcs	.+2      	; 0x2b56 <vLs020Rotation+0x60>
    2b54:	40 c0       	rjmp	.+128    	; 0x2bd6 <vLs020Rotation+0xe0>
    2b56:	0d c0       	rjmp	.+26     	; 0x2b72 <vLs020Rotation+0x7c>
    2b58:	25 30       	cpi	r18, 0x05	; 5
    2b5a:	09 f4       	brne	.+2      	; 0x2b5e <vLs020Rotation+0x68>
    2b5c:	7b c0       	rjmp	.+246    	; 0x2c54 <vLs020Rotation+0x15e>
    2b5e:	25 30       	cpi	r18, 0x05	; 5
    2b60:	08 f4       	brcc	.+2      	; 0x2b64 <vLs020Rotation+0x6e>
    2b62:	6b c0       	rjmp	.+214    	; 0x2c3a <vLs020Rotation+0x144>
    2b64:	26 30       	cpi	r18, 0x06	; 6
    2b66:	09 f4       	brne	.+2      	; 0x2b6a <vLs020Rotation+0x74>
    2b68:	90 c0       	rjmp	.+288    	; 0x2c8a <vLs020Rotation+0x194>
    2b6a:	27 30       	cpi	r18, 0x07	; 7
    2b6c:	09 f0       	breq	.+2      	; 0x2b70 <vLs020Rotation+0x7a>
    2b6e:	a9 c0       	rjmp	.+338    	; 0x2cc2 <vLs020Rotation+0x1cc>
    2b70:	8c c0       	rjmp	.+280    	; 0x2c8a <vLs020Rotation+0x194>
		{
		case  0:	
//				 	vLs020WriteCmd16(0x1800);
					vLs020WriteCmd16(ASX + y);
    2b72:	c8 01       	movw	r24, r16
    2b74:	80 50       	subi	r24, 0x00	; 0
    2b76:	9e 4e       	sbci	r25, 0xEE	; 238
    2b78:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEX + y + (CHARW - 1));
    2b7c:	c8 01       	movw	r24, r16
    2b7e:	81 50       	subi	r24, 0x01	; 1
    2b80:	9b 4e       	sbci	r25, 0xEB	; 235
    2b82:	8e 0d       	add	r24, r14
    2b84:	9f 1d       	adc	r25, r15
    2b86:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(ASY + x);
    2b8a:	c5 01       	movw	r24, r10
    2b8c:	80 50       	subi	r24, 0x00	; 0
    2b8e:	9d 4e       	sbci	r25, 0xED	; 237
    2b90:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEY + x + (CHARH - 1));
    2b94:	c5 01       	movw	r24, r10
    2b96:	81 50       	subi	r24, 0x01	; 1
    2b98:	9a 4e       	sbci	r25, 0xEA	; 234
    2b9a:	8c 0d       	add	r24, r12
    2b9c:	9d 1d       	adc	r25, r13
    2b9e:	8f c0       	rjmp	.+286    	; 0x2cbe <vLs020Rotation+0x1c8>
					break;
	
		case  1:	
//				 	vLs020WriteCmd16(0x1801);
					vLs020WriteCmd16(ASX + y);
    2ba0:	06 2f       	mov	r16, r22
    2ba2:	10 e0       	ldi	r17, 0x00	; 0
    2ba4:	c8 01       	movw	r24, r16
    2ba6:	80 50       	subi	r24, 0x00	; 0
    2ba8:	9e 4e       	sbci	r25, 0xEE	; 238
    2baa:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEX + y - (CHARW - 1));
    2bae:	0f 5f       	subi	r16, 0xFF	; 255
    2bb0:	1a 4e       	sbci	r17, 0xEA	; 234
    2bb2:	c8 01       	movw	r24, r16
    2bb4:	8e 19       	sub	r24, r14
    2bb6:	91 09       	sbc	r25, r1
    2bb8:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(ASY + x);
    2bbc:	0d 2d       	mov	r16, r13
    2bbe:	10 e0       	ldi	r17, 0x00	; 0
    2bc0:	c8 01       	movw	r24, r16
    2bc2:	80 50       	subi	r24, 0x00	; 0
    2bc4:	9d 4e       	sbci	r25, 0xED	; 237
    2bc6:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEY + x + (CHARH - 1));
    2bca:	c8 01       	movw	r24, r16
    2bcc:	81 50       	subi	r24, 0x01	; 1
    2bce:	9a 4e       	sbci	r25, 0xEA	; 234
    2bd0:	8c 0d       	add	r24, r12
    2bd2:	91 1d       	adc	r25, r1
    2bd4:	74 c0       	rjmp	.+232    	; 0x2cbe <vLs020Rotation+0x1c8>
					break;
		
		case  2:	
//				 	vLs020WriteCmd16(0x1802);
					vLs020WriteCmd16(ASX + y);
    2bd6:	c8 01       	movw	r24, r16
    2bd8:	80 50       	subi	r24, 0x00	; 0
    2bda:	9e 4e       	sbci	r25, 0xEE	; 238
    2bdc:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEX + y + (CHARW - 1));
    2be0:	c8 01       	movw	r24, r16
    2be2:	81 50       	subi	r24, 0x01	; 1
    2be4:	9b 4e       	sbci	r25, 0xEB	; 235
    2be6:	8e 0d       	add	r24, r14
    2be8:	9f 1d       	adc	r25, r15
    2bea:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(ASY + x);
    2bee:	c5 01       	movw	r24, r10
    2bf0:	80 50       	subi	r24, 0x00	; 0
    2bf2:	9d 4e       	sbci	r25, 0xED	; 237
    2bf4:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEY + x - (CHARH - 1));
    2bf8:	c5 01       	movw	r24, r10
    2bfa:	8f 5f       	subi	r24, 0xFF	; 255
    2bfc:	99 4e       	sbci	r25, 0xE9	; 233
    2bfe:	8c 19       	sub	r24, r12
    2c00:	9d 09       	sbc	r25, r13
    2c02:	5d c0       	rjmp	.+186    	; 0x2cbe <vLs020Rotation+0x1c8>
					break;
		
		case  3:	
//				 	vLs020WriteCmd16(0x1803);
					vLs020WriteCmd16(ASX + y);
    2c04:	06 2f       	mov	r16, r22
    2c06:	10 e0       	ldi	r17, 0x00	; 0
    2c08:	c8 01       	movw	r24, r16
    2c0a:	80 50       	subi	r24, 0x00	; 0
    2c0c:	9e 4e       	sbci	r25, 0xEE	; 238
    2c0e:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEX + y - (CHARW - 1));
    2c12:	0f 5f       	subi	r16, 0xFF	; 255
    2c14:	1a 4e       	sbci	r17, 0xEA	; 234
    2c16:	c8 01       	movw	r24, r16
    2c18:	8e 19       	sub	r24, r14
    2c1a:	91 09       	sbc	r25, r1
    2c1c:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(ASY + x);
    2c20:	0d 2d       	mov	r16, r13
    2c22:	10 e0       	ldi	r17, 0x00	; 0
    2c24:	c8 01       	movw	r24, r16
    2c26:	80 50       	subi	r24, 0x00	; 0
    2c28:	9d 4e       	sbci	r25, 0xED	; 237
    2c2a:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEY + x - (CHARH - 1));
    2c2e:	c8 01       	movw	r24, r16
    2c30:	8f 5f       	subi	r24, 0xFF	; 255
    2c32:	99 4e       	sbci	r25, 0xE9	; 233
    2c34:	8c 19       	sub	r24, r12
    2c36:	91 09       	sbc	r25, r1
    2c38:	42 c0       	rjmp	.+132    	; 0x2cbe <vLs020Rotation+0x1c8>
					break;
		
		case  4:	
//				 	vLs020WriteCmd16(0x1804);
					vLs020WriteCmd16(ASX + y);
    2c3a:	06 2f       	mov	r16, r22
    2c3c:	10 e0       	ldi	r17, 0x00	; 0
    2c3e:	c8 01       	movw	r24, r16
    2c40:	80 50       	subi	r24, 0x00	; 0
    2c42:	9e 4e       	sbci	r25, 0xEE	; 238
    2c44:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEX + y + (CHARH - 1));
    2c48:	01 50       	subi	r16, 0x01	; 1
    2c4a:	1b 4e       	sbci	r17, 0xEB	; 235
    2c4c:	c8 01       	movw	r24, r16
    2c4e:	8c 0d       	add	r24, r12
    2c50:	91 1d       	adc	r25, r1
    2c52:	0c c0       	rjmp	.+24     	; 0x2c6c <vLs020Rotation+0x176>
					vLs020WriteCmd16(AEY + x + (CHARW - 1));
					break;
		
		case  5:	
//					vLs020WriteCmd16(0x1805);
					vLs020WriteCmd16(ASX + y);
    2c54:	06 2f       	mov	r16, r22
    2c56:	10 e0       	ldi	r17, 0x00	; 0
    2c58:	c8 01       	movw	r24, r16
    2c5a:	80 50       	subi	r24, 0x00	; 0
    2c5c:	9e 4e       	sbci	r25, 0xEE	; 238
    2c5e:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEX + y - (CHARH - 1));
    2c62:	0f 5f       	subi	r16, 0xFF	; 255
    2c64:	1a 4e       	sbci	r17, 0xEA	; 234
    2c66:	c8 01       	movw	r24, r16
    2c68:	8c 19       	sub	r24, r12
    2c6a:	91 09       	sbc	r25, r1
    2c6c:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(ASY + x);
    2c70:	0d 2d       	mov	r16, r13
    2c72:	10 e0       	ldi	r17, 0x00	; 0
    2c74:	c8 01       	movw	r24, r16
    2c76:	80 50       	subi	r24, 0x00	; 0
    2c78:	9d 4e       	sbci	r25, 0xED	; 237
    2c7a:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEY + x + (CHARW - 1));
    2c7e:	c8 01       	movw	r24, r16
    2c80:	81 50       	subi	r24, 0x01	; 1
    2c82:	9a 4e       	sbci	r25, 0xEA	; 234
    2c84:	8e 0d       	add	r24, r14
    2c86:	91 1d       	adc	r25, r1
    2c88:	1a c0       	rjmp	.+52     	; 0x2cbe <vLs020Rotation+0x1c8>
					vLs020WriteCmd16(AEY + x - (CHARW - 1));
					break;
		
		case  7:	
//					vLs020WriteCmd16(0x1807);
					vLs020WriteCmd16(ASX + y);
    2c8a:	06 2f       	mov	r16, r22
    2c8c:	10 e0       	ldi	r17, 0x00	; 0
    2c8e:	c8 01       	movw	r24, r16
    2c90:	80 50       	subi	r24, 0x00	; 0
    2c92:	9e 4e       	sbci	r25, 0xEE	; 238
    2c94:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEX + y - (CHARH - 1));
    2c98:	0f 5f       	subi	r16, 0xFF	; 255
    2c9a:	1a 4e       	sbci	r17, 0xEA	; 234
    2c9c:	c8 01       	movw	r24, r16
    2c9e:	8c 19       	sub	r24, r12
    2ca0:	91 09       	sbc	r25, r1
    2ca2:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(ASY + x);
    2ca6:	0d 2d       	mov	r16, r13
    2ca8:	10 e0       	ldi	r17, 0x00	; 0
    2caa:	c8 01       	movw	r24, r16
    2cac:	80 50       	subi	r24, 0x00	; 0
    2cae:	9d 4e       	sbci	r25, 0xED	; 237
    2cb0:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEY + x - (CHARW - 1));
    2cb4:	c8 01       	movw	r24, r16
    2cb6:	8f 5f       	subi	r24, 0xFF	; 255
    2cb8:	99 4e       	sbci	r25, 0xE9	; 233
    2cba:	8e 19       	sub	r24, r14
    2cbc:	91 09       	sbc	r25, r1
    2cbe:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					break;
		}
}
    2cc2:	0f 90       	pop	r0
    2cc4:	0f 90       	pop	r0
    2cc6:	cf 91       	pop	r28
    2cc8:	df 91       	pop	r29
    2cca:	1f 91       	pop	r17
    2ccc:	0f 91       	pop	r16
    2cce:	ff 90       	pop	r15
    2cd0:	ef 90       	pop	r14
    2cd2:	df 90       	pop	r13
    2cd4:	cf 90       	pop	r12
    2cd6:	bf 90       	pop	r11
    2cd8:	af 90       	pop	r10
    2cda:	08 95       	ret

00002cdc <vLs020ZeroRotation>:


void vLs020ZeroRotation(void)
{
	vLs020WriteCmd16(0xEF80);
    2cdc:	80 e8       	ldi	r24, 0x80	; 128
    2cde:	9f ee       	ldi	r25, 0xEF	; 239
    2ce0:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
	vLs020WriteCmd16(0x1800);
    2ce4:	80 e0       	ldi	r24, 0x00	; 0
    2ce6:	98 e1       	ldi	r25, 0x18	; 24
    2ce8:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
	vLs020WriteCmd16(ASX);
    2cec:	80 e0       	ldi	r24, 0x00	; 0
    2cee:	92 e1       	ldi	r25, 0x12	; 18
    2cf0:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
	vLs020WriteCmd16(AEX);
    2cf4:	80 e0       	ldi	r24, 0x00	; 0
    2cf6:	95 e1       	ldi	r25, 0x15	; 21
    2cf8:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
	vLs020WriteCmd16(ASY);
    2cfc:	80 e0       	ldi	r24, 0x00	; 0
    2cfe:	93 e1       	ldi	r25, 0x13	; 19
    2d00:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
	vLs020WriteCmd16(AEY);
    2d04:	80 e0       	ldi	r24, 0x00	; 0
    2d06:	96 e1       	ldi	r25, 0x16	; 22
    2d08:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
}
    2d0c:	08 95       	ret

00002d0e <vLs020Rotation_2>:


void vLs020Rotation_2(char x, char y, char CHARH, char CHARW, char mode)
{
    2d0e:	af 92       	push	r10
    2d10:	bf 92       	push	r11
    2d12:	cf 92       	push	r12
    2d14:	df 92       	push	r13
    2d16:	ef 92       	push	r14
    2d18:	ff 92       	push	r15
    2d1a:	0f 93       	push	r16
    2d1c:	1f 93       	push	r17
    2d1e:	df 93       	push	r29
    2d20:	cf 93       	push	r28
    2d22:	0f 92       	push	r0
    2d24:	0f 92       	push	r0
    2d26:	cd b7       	in	r28, 0x3d	; 61
    2d28:	de b7       	in	r29, 0x3e	; 62
    2d2a:	d8 2e       	mov	r13, r24
    2d2c:	c4 2e       	mov	r12, r20
    2d2e:	e2 2e       	mov	r14, r18
	
	vLs020WriteCmd16(0xEF80);
    2d30:	80 e8       	ldi	r24, 0x80	; 128
    2d32:	9f ee       	ldi	r25, 0xEF	; 239
    2d34:	0a 83       	std	Y+2, r16	; 0x02
    2d36:	69 83       	std	Y+1, r22	; 0x01
    2d38:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
	vLs020WriteCmd16(0x1800 + mode);
    2d3c:	2a 81       	ldd	r18, Y+2	; 0x02
    2d3e:	82 2f       	mov	r24, r18
    2d40:	90 e0       	ldi	r25, 0x00	; 0
    2d42:	80 50       	subi	r24, 0x00	; 0
    2d44:	98 4e       	sbci	r25, 0xE8	; 232
    2d46:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>

	switch(mode)
    2d4a:	2a 81       	ldd	r18, Y+2	; 0x02
    2d4c:	69 81       	ldd	r22, Y+1	; 0x01
    2d4e:	23 30       	cpi	r18, 0x03	; 3
    2d50:	09 f4       	brne	.+2      	; 0x2d54 <vLs020Rotation_2+0x46>
    2d52:	64 c0       	rjmp	.+200    	; 0x2e1c <vLs020Rotation_2+0x10e>
    2d54:	24 30       	cpi	r18, 0x04	; 4
    2d56:	60 f4       	brcc	.+24     	; 0x2d70 <vLs020Rotation_2+0x62>
    2d58:	21 30       	cpi	r18, 0x01	; 1
    2d5a:	71 f1       	breq	.+92     	; 0x2db8 <vLs020Rotation_2+0xaa>
    2d5c:	06 2f       	mov	r16, r22
    2d5e:	10 e0       	ldi	r17, 0x00	; 0
    2d60:	ff 24       	eor	r15, r15
    2d62:	ad 2c       	mov	r10, r13
    2d64:	bb 24       	eor	r11, r11
    2d66:	dd 24       	eor	r13, r13
    2d68:	22 30       	cpi	r18, 0x02	; 2
    2d6a:	08 f0       	brcs	.+2      	; 0x2d6e <vLs020Rotation_2+0x60>
    2d6c:	40 c0       	rjmp	.+128    	; 0x2dee <vLs020Rotation_2+0xe0>
    2d6e:	0d c0       	rjmp	.+26     	; 0x2d8a <vLs020Rotation_2+0x7c>
    2d70:	25 30       	cpi	r18, 0x05	; 5
    2d72:	09 f4       	brne	.+2      	; 0x2d76 <vLs020Rotation_2+0x68>
    2d74:	7b c0       	rjmp	.+246    	; 0x2e6c <vLs020Rotation_2+0x15e>
    2d76:	25 30       	cpi	r18, 0x05	; 5
    2d78:	08 f4       	brcc	.+2      	; 0x2d7c <vLs020Rotation_2+0x6e>
    2d7a:	6b c0       	rjmp	.+214    	; 0x2e52 <vLs020Rotation_2+0x144>
    2d7c:	26 30       	cpi	r18, 0x06	; 6
    2d7e:	09 f4       	brne	.+2      	; 0x2d82 <vLs020Rotation_2+0x74>
    2d80:	90 c0       	rjmp	.+288    	; 0x2ea2 <vLs020Rotation_2+0x194>
    2d82:	27 30       	cpi	r18, 0x07	; 7
    2d84:	09 f0       	breq	.+2      	; 0x2d88 <vLs020Rotation_2+0x7a>
    2d86:	a9 c0       	rjmp	.+338    	; 0x2eda <vLs020Rotation_2+0x1cc>
    2d88:	8c c0       	rjmp	.+280    	; 0x2ea2 <vLs020Rotation_2+0x194>
		{
		case  0:	
					vLs020WriteCmd16(ASX + y);
    2d8a:	c8 01       	movw	r24, r16
    2d8c:	80 50       	subi	r24, 0x00	; 0
    2d8e:	9e 4e       	sbci	r25, 0xEE	; 238
    2d90:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEX + y + (CHARW - 1));
    2d94:	c8 01       	movw	r24, r16
    2d96:	81 50       	subi	r24, 0x01	; 1
    2d98:	9b 4e       	sbci	r25, 0xEB	; 235
    2d9a:	8e 0d       	add	r24, r14
    2d9c:	9f 1d       	adc	r25, r15
    2d9e:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(ASY + x);
    2da2:	c5 01       	movw	r24, r10
    2da4:	80 50       	subi	r24, 0x00	; 0
    2da6:	9d 4e       	sbci	r25, 0xED	; 237
    2da8:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEY + x + (CHARH - 1));
    2dac:	c5 01       	movw	r24, r10
    2dae:	81 50       	subi	r24, 0x01	; 1
    2db0:	9a 4e       	sbci	r25, 0xEA	; 234
    2db2:	8c 0d       	add	r24, r12
    2db4:	9d 1d       	adc	r25, r13
    2db6:	8f c0       	rjmp	.+286    	; 0x2ed6 <vLs020Rotation_2+0x1c8>
					break;
	
		case  1:	

					vLs020WriteCmd16(ASX + y);
    2db8:	06 2f       	mov	r16, r22
    2dba:	10 e0       	ldi	r17, 0x00	; 0
    2dbc:	c8 01       	movw	r24, r16
    2dbe:	80 50       	subi	r24, 0x00	; 0
    2dc0:	9e 4e       	sbci	r25, 0xEE	; 238
    2dc2:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
//					vLs020WriteCmd16(AEX + y - (CHARW - 1));
					vLs020WriteCmd16(AEX + y + (CHARW - 1));
    2dc6:	01 50       	subi	r16, 0x01	; 1
    2dc8:	1b 4e       	sbci	r17, 0xEB	; 235
    2dca:	c8 01       	movw	r24, r16
    2dcc:	8e 0d       	add	r24, r14
    2dce:	91 1d       	adc	r25, r1
    2dd0:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(ASY + x);
    2dd4:	0d 2d       	mov	r16, r13
    2dd6:	10 e0       	ldi	r17, 0x00	; 0
    2dd8:	c8 01       	movw	r24, r16
    2dda:	80 50       	subi	r24, 0x00	; 0
    2ddc:	9d 4e       	sbci	r25, 0xED	; 237
    2dde:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEY + x + (CHARH - 1));
    2de2:	c8 01       	movw	r24, r16
    2de4:	81 50       	subi	r24, 0x01	; 1
    2de6:	9a 4e       	sbci	r25, 0xEA	; 234
    2de8:	8c 0d       	add	r24, r12
    2dea:	91 1d       	adc	r25, r1
    2dec:	74 c0       	rjmp	.+232    	; 0x2ed6 <vLs020Rotation_2+0x1c8>
					break;
		
		case  2:	

					vLs020WriteCmd16(ASX + y);
    2dee:	c8 01       	movw	r24, r16
    2df0:	80 50       	subi	r24, 0x00	; 0
    2df2:	9e 4e       	sbci	r25, 0xEE	; 238
    2df4:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEX + y + (CHARW - 1));
    2df8:	c8 01       	movw	r24, r16
    2dfa:	81 50       	subi	r24, 0x01	; 1
    2dfc:	9b 4e       	sbci	r25, 0xEB	; 235
    2dfe:	8e 0d       	add	r24, r14
    2e00:	9f 1d       	adc	r25, r15
    2e02:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(ASY + x);
    2e06:	c5 01       	movw	r24, r10
    2e08:	80 50       	subi	r24, 0x00	; 0
    2e0a:	9d 4e       	sbci	r25, 0xED	; 237
    2e0c:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEY + x - (CHARH - 1));
    2e10:	c5 01       	movw	r24, r10
    2e12:	8f 5f       	subi	r24, 0xFF	; 255
    2e14:	99 4e       	sbci	r25, 0xE9	; 233
    2e16:	8c 19       	sub	r24, r12
    2e18:	9d 09       	sbc	r25, r13
    2e1a:	5d c0       	rjmp	.+186    	; 0x2ed6 <vLs020Rotation_2+0x1c8>
					break;
		
		case  3:	

					vLs020WriteCmd16(ASX + y);
    2e1c:	06 2f       	mov	r16, r22
    2e1e:	10 e0       	ldi	r17, 0x00	; 0
    2e20:	c8 01       	movw	r24, r16
    2e22:	80 50       	subi	r24, 0x00	; 0
    2e24:	9e 4e       	sbci	r25, 0xEE	; 238
    2e26:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEX + y - (CHARW - 1));
    2e2a:	0f 5f       	subi	r16, 0xFF	; 255
    2e2c:	1a 4e       	sbci	r17, 0xEA	; 234
    2e2e:	c8 01       	movw	r24, r16
    2e30:	8e 19       	sub	r24, r14
    2e32:	91 09       	sbc	r25, r1
    2e34:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(ASY + x);
    2e38:	0d 2d       	mov	r16, r13
    2e3a:	10 e0       	ldi	r17, 0x00	; 0
    2e3c:	c8 01       	movw	r24, r16
    2e3e:	80 50       	subi	r24, 0x00	; 0
    2e40:	9d 4e       	sbci	r25, 0xED	; 237
    2e42:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEY + x - (CHARH - 1));
    2e46:	c8 01       	movw	r24, r16
    2e48:	8f 5f       	subi	r24, 0xFF	; 255
    2e4a:	99 4e       	sbci	r25, 0xE9	; 233
    2e4c:	8c 19       	sub	r24, r12
    2e4e:	91 09       	sbc	r25, r1
    2e50:	42 c0       	rjmp	.+132    	; 0x2ed6 <vLs020Rotation_2+0x1c8>
					break;
		
		case  4:	

					vLs020WriteCmd16(ASX + y);
    2e52:	06 2f       	mov	r16, r22
    2e54:	10 e0       	ldi	r17, 0x00	; 0
    2e56:	c8 01       	movw	r24, r16
    2e58:	80 50       	subi	r24, 0x00	; 0
    2e5a:	9e 4e       	sbci	r25, 0xEE	; 238
    2e5c:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEX + y + (CHARH - 1));
    2e60:	01 50       	subi	r16, 0x01	; 1
    2e62:	1b 4e       	sbci	r17, 0xEB	; 235
    2e64:	c8 01       	movw	r24, r16
    2e66:	8c 0d       	add	r24, r12
    2e68:	91 1d       	adc	r25, r1
    2e6a:	0c c0       	rjmp	.+24     	; 0x2e84 <vLs020Rotation_2+0x176>
					vLs020WriteCmd16(ASY + x);
					vLs020WriteCmd16(AEY + x + (CHARW - 1));
					break;
		
		case  5:	
					vLs020WriteCmd16(ASX + y);
    2e6c:	06 2f       	mov	r16, r22
    2e6e:	10 e0       	ldi	r17, 0x00	; 0
    2e70:	c8 01       	movw	r24, r16
    2e72:	80 50       	subi	r24, 0x00	; 0
    2e74:	9e 4e       	sbci	r25, 0xEE	; 238
    2e76:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEX + y - (CHARH - 1));
    2e7a:	0f 5f       	subi	r16, 0xFF	; 255
    2e7c:	1a 4e       	sbci	r17, 0xEA	; 234
    2e7e:	c8 01       	movw	r24, r16
    2e80:	8c 19       	sub	r24, r12
    2e82:	91 09       	sbc	r25, r1
    2e84:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(ASY + x);
    2e88:	0d 2d       	mov	r16, r13
    2e8a:	10 e0       	ldi	r17, 0x00	; 0
    2e8c:	c8 01       	movw	r24, r16
    2e8e:	80 50       	subi	r24, 0x00	; 0
    2e90:	9d 4e       	sbci	r25, 0xED	; 237
    2e92:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEY + x + (CHARW - 1));
    2e96:	c8 01       	movw	r24, r16
    2e98:	81 50       	subi	r24, 0x01	; 1
    2e9a:	9a 4e       	sbci	r25, 0xEA	; 234
    2e9c:	8e 0d       	add	r24, r14
    2e9e:	91 1d       	adc	r25, r1
    2ea0:	1a c0       	rjmp	.+52     	; 0x2ed6 <vLs020Rotation_2+0x1c8>
					vLs020WriteCmd16(ASY + x);
					vLs020WriteCmd16(AEY + x - (CHARW - 1));
					break;
		
		case  7:	
					vLs020WriteCmd16(ASX + y);
    2ea2:	06 2f       	mov	r16, r22
    2ea4:	10 e0       	ldi	r17, 0x00	; 0
    2ea6:	c8 01       	movw	r24, r16
    2ea8:	80 50       	subi	r24, 0x00	; 0
    2eaa:	9e 4e       	sbci	r25, 0xEE	; 238
    2eac:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEX + y - (CHARH - 1));
    2eb0:	0f 5f       	subi	r16, 0xFF	; 255
    2eb2:	1a 4e       	sbci	r17, 0xEA	; 234
    2eb4:	c8 01       	movw	r24, r16
    2eb6:	8c 19       	sub	r24, r12
    2eb8:	91 09       	sbc	r25, r1
    2eba:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(ASY + x);
    2ebe:	0d 2d       	mov	r16, r13
    2ec0:	10 e0       	ldi	r17, 0x00	; 0
    2ec2:	c8 01       	movw	r24, r16
    2ec4:	80 50       	subi	r24, 0x00	; 0
    2ec6:	9d 4e       	sbci	r25, 0xED	; 237
    2ec8:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					vLs020WriteCmd16(AEY + x - (CHARW - 1));
    2ecc:	c8 01       	movw	r24, r16
    2ece:	8f 5f       	subi	r24, 0xFF	; 255
    2ed0:	99 4e       	sbci	r25, 0xE9	; 233
    2ed2:	8e 19       	sub	r24, r14
    2ed4:	91 09       	sbc	r25, r1
    2ed6:	0e 94 f5 13 	call	0x27ea	; 0x27ea <vLs020WriteCmd16>
					break;
		}
}
    2eda:	0f 90       	pop	r0
    2edc:	0f 90       	pop	r0
    2ede:	cf 91       	pop	r28
    2ee0:	df 91       	pop	r29
    2ee2:	1f 91       	pop	r17
    2ee4:	0f 91       	pop	r16
    2ee6:	ff 90       	pop	r15
    2ee8:	ef 90       	pop	r14
    2eea:	df 90       	pop	r13
    2eec:	cf 90       	pop	r12
    2eee:	bf 90       	pop	r11
    2ef0:	af 90       	pop	r10
    2ef2:	08 95       	ret

00002ef4 <vLs020PutChar8x14>:
// rot = 0 -   

#if (Include8x14Font == 1)

void vLs020PutChar8x14(char x, char y, char symbol, int color, int bkcolor, char bits_color, char rot)
{
    2ef4:	9f 92       	push	r9
    2ef6:	af 92       	push	r10
    2ef8:	bf 92       	push	r11
    2efa:	cf 92       	push	r12
    2efc:	df 92       	push	r13
    2efe:	ef 92       	push	r14
    2f00:	ff 92       	push	r15
    2f02:	0f 93       	push	r16
    2f04:	1f 93       	push	r17
    2f06:	cf 93       	push	r28
    2f08:	df 93       	push	r29
    2f0a:	f4 2e       	mov	r15, r20
    2f0c:	b2 2e       	mov	r11, r18
    2f0e:	a3 2e       	mov	r10, r19
    2f10:	d0 2e       	mov	r13, r16
    2f12:	0c 2d       	mov	r16, r12
  	uint8_t h,ch,p,mask, color8,bkcolor8 ;

	vLs020Rotation(x, y, 14, 8, rot);
    2f14:	4e e0       	ldi	r20, 0x0E	; 14
    2f16:	28 e0       	ldi	r18, 0x08	; 8
    2f18:	0e 94 7b 15 	call	0x2af6	; 0x2af6 <vLs020Rotation>

//#define CHAR_H 14
//#define CHAR_W 8


	switch (bits_color)	
    2f1c:	2e 2d       	mov	r18, r14
    2f1e:	28 30       	cpi	r18, 0x08	; 8
    2f20:	21 f0       	breq	.+8      	; 0x2f2a <vLs020PutChar8x14+0x36>
    2f22:	20 31       	cpi	r18, 0x10	; 16
    2f24:	09 f0       	breq	.+2      	; 0x2f28 <vLs020PutChar8x14+0x34>
    2f26:	4f c0       	rjmp	.+158    	; 0x2fc6 <vLs020PutChar8x14+0xd2>
    2f28:	25 c0       	rjmp	.+74     	; 0x2f74 <vLs020PutChar8x14+0x80>
		{
		case 8:
			{	
			vLs020Mode8bit(0);
    2f2a:	0e 94 ff 13 	call	0x27fe	; 0x27fe <vLs020Mode8bit.clone.0>
			bkcolor8 = bkcolor & 0x00FF;

  			for (h = 0; h < CHAR_H; h++)									// every column of the character
  				{

       			ch = (pgm_read_byte(font8x14 + 14*(symbol - 32) + h));
    2f2e:	0e e0       	ldi	r16, 0x0E	; 14
    2f30:	8f 2d       	mov	r24, r15
    2f32:	80 9f       	mul	r24, r16
    2f34:	80 01       	movw	r16, r0
    2f36:	11 24       	eor	r1, r1
    2f38:	e8 01       	movw	r28, r16
    2f3a:	c0 5c       	subi	r28, 0xC0	; 192
    2f3c:	d1 40       	sbci	r29, 0x01	; 1
// rot = 1 -  
// rot = 0 -   

#if (Include8x14Font == 1)

void vLs020PutChar8x14(char x, char y, char symbol, int color, int bkcolor, char bits_color, char rot)
    2f3e:	02 5b       	subi	r16, 0xB2	; 178
    2f40:	11 40       	sbci	r17, 0x01	; 1
			bkcolor8 = bkcolor & 0x00FF;

  			for (h = 0; h < CHAR_H; h++)									// every column of the character
  				{

       			ch = (pgm_read_byte(font8x14 + 14*(symbol - 32) + h));
    2f42:	fe 01       	movw	r30, r28
    2f44:	ec 51       	subi	r30, 0x1C	; 28
    2f46:	f9 4f       	sbci	r31, 0xF9	; 249
    2f48:	c4 90       	lpm	r12, Z+
    2f4a:	98 e0       	ldi	r25, 0x08	; 8
    2f4c:	e9 2e       	mov	r14, r25
				mask = 0x80;
    2f4e:	80 e8       	ldi	r24, 0x80	; 128
    2f50:	f8 2e       	mov	r15, r24
        		
				for (p = 0; p < CHAR_W; p++)  								// write the pixels
        			{
          			if (ch & mask)
    2f52:	8f 2d       	mov	r24, r15
    2f54:	8c 21       	and	r24, r12
    2f56:	11 f0       	breq	.+4      	; 0x2f5c <vLs020PutChar8x14+0x68>
            			vLs020WriteData8(color8);                
    2f58:	8b 2d       	mov	r24, r11
    2f5a:	01 c0       	rjmp	.+2      	; 0x2f5e <vLs020PutChar8x14+0x6a>
          			else
            			vLs020WriteData8(bkcolor8);
    2f5c:	8d 2d       	mov	r24, r13
    2f5e:	0e 94 08 14 	call	0x2810	; 0x2810 <vLs020WriteData8>
    2f62:	ea 94       	dec	r14
  				{

       			ch = (pgm_read_byte(font8x14 + 14*(symbol - 32) + h));
				mask = 0x80;
        		
				for (p = 0; p < CHAR_W; p++)  								// write the pixels
    2f64:	11 f0       	breq	.+4      	; 0x2f6a <vLs020PutChar8x14+0x76>
          			if (ch & mask)
            			vLs020WriteData8(color8);                
          			else
            			vLs020WriteData8(bkcolor8);
					
					mask = mask/2;
    2f66:	f6 94       	lsr	r15
    2f68:	f4 cf       	rjmp	.-24     	; 0x2f52 <vLs020PutChar8x14+0x5e>
    2f6a:	21 96       	adiw	r28, 0x01	; 1
			{	
			vLs020Mode8bit(0);
			color8 = color & 0x00FF;
			bkcolor8 = bkcolor & 0x00FF;

  			for (h = 0; h < CHAR_H; h++)									// every column of the character
    2f6c:	c0 17       	cp	r28, r16
    2f6e:	d1 07       	cpc	r29, r17
    2f70:	41 f7       	brne	.-48     	; 0x2f42 <vLs020PutChar8x14+0x4e>
    2f72:	29 c0       	rjmp	.+82     	; 0x2fc6 <vLs020PutChar8x14+0xd2>
			}
			break;
	
		case 16:
			{
			vLs020Mode16bit();
    2f74:	0e 94 60 14 	call	0x28c0	; 0x28c0 <vLs020Mode16bit>
  			for (h = 0; h < CHAR_H; h++)									// every column of the character
  				{

       			ch = (pgm_read_byte(font8x14 + 14*(symbol - 32) + h));
    2f78:	8e e0       	ldi	r24, 0x0E	; 14
    2f7a:	2f 2d       	mov	r18, r15
    2f7c:	28 9f       	mul	r18, r24
    2f7e:	c0 01       	movw	r24, r0
    2f80:	11 24       	eor	r1, r1
    2f82:	ec 01       	movw	r28, r24
    2f84:	c0 5c       	subi	r28, 0xC0	; 192
    2f86:	d1 40       	sbci	r29, 0x01	; 1
// rot = 1 -  
// rot = 0 -   

#if (Include8x14Font == 1)

void vLs020PutChar8x14(char x, char y, char symbol, int color, int bkcolor, char bits_color, char rot)
    2f88:	be e4       	ldi	r27, 0x4E	; 78
    2f8a:	eb 2e       	mov	r14, r27
    2f8c:	be ef       	ldi	r27, 0xFE	; 254
    2f8e:	fb 2e       	mov	r15, r27
    2f90:	e8 0e       	add	r14, r24
    2f92:	f9 1e       	adc	r15, r25
			{
			vLs020Mode16bit();
  			for (h = 0; h < CHAR_H; h++)									// every column of the character
  				{

       			ch = (pgm_read_byte(font8x14 + 14*(symbol - 32) + h));
    2f94:	fe 01       	movw	r30, r28
    2f96:	ec 51       	subi	r30, 0x1C	; 28
    2f98:	f9 4f       	sbci	r31, 0xF9	; 249
    2f9a:	94 90       	lpm	r9, Z+
    2f9c:	a8 e0       	ldi	r26, 0x08	; 8
    2f9e:	ca 2e       	mov	r12, r26
				mask = 0x80;
    2fa0:	00 e8       	ldi	r16, 0x80	; 128
        		for (p = 0; p < CHAR_W; p++)  								// write the pixels
        			{
          			if (ch & mask)
    2fa2:	80 2f       	mov	r24, r16
    2fa4:	89 21       	and	r24, r9
    2fa6:	19 f0       	breq	.+6      	; 0x2fae <vLs020PutChar8x14+0xba>
            			vLs020WriteData16(color);                
    2fa8:	8b 2d       	mov	r24, r11
    2faa:	9a 2d       	mov	r25, r10
    2fac:	02 c0       	rjmp	.+4      	; 0x2fb2 <vLs020PutChar8x14+0xbe>
          			else
            			vLs020WriteData16(bkcolor);
    2fae:	8d 2d       	mov	r24, r13
    2fb0:	91 2f       	mov	r25, r17
    2fb2:	0e 94 10 14 	call	0x2820	; 0x2820 <vLs020WriteData16>
    2fb6:	ca 94       	dec	r12
  			for (h = 0; h < CHAR_H; h++)									// every column of the character
  				{

       			ch = (pgm_read_byte(font8x14 + 14*(symbol - 32) + h));
				mask = 0x80;
        		for (p = 0; p < CHAR_W; p++)  								// write the pixels
    2fb8:	11 f0       	breq	.+4      	; 0x2fbe <vLs020PutChar8x14+0xca>
          			if (ch & mask)
            			vLs020WriteData16(color);                
          			else
            			vLs020WriteData16(bkcolor);
          			
					mask = mask/2;
    2fba:	06 95       	lsr	r16
    2fbc:	f2 cf       	rjmp	.-28     	; 0x2fa2 <vLs020PutChar8x14+0xae>
    2fbe:	21 96       	adiw	r28, 0x01	; 1
			break;
	
		case 16:
			{
			vLs020Mode16bit();
  			for (h = 0; h < CHAR_H; h++)									// every column of the character
    2fc0:	ce 15       	cp	r28, r14
    2fc2:	df 05       	cpc	r29, r15
    2fc4:	39 f7       	brne	.-50     	; 0x2f94 <vLs020PutChar8x14+0xa0>
				}
			}
			break;
		} 

	vLs020Mode8bit(0);
    2fc6:	0e 94 ff 13 	call	0x27fe	; 0x27fe <vLs020Mode8bit.clone.0>
	vLs020ZeroRotation();
    2fca:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <vLs020ZeroRotation>
}
    2fce:	df 91       	pop	r29
    2fd0:	cf 91       	pop	r28
    2fd2:	1f 91       	pop	r17
    2fd4:	0f 91       	pop	r16
    2fd6:	ff 90       	pop	r15
    2fd8:	ef 90       	pop	r14
    2fda:	df 90       	pop	r13
    2fdc:	cf 90       	pop	r12
    2fde:	bf 90       	pop	r11
    2fe0:	af 90       	pop	r10
    2fe2:	9f 90       	pop	r9
    2fe4:	08 95       	ret

00002fe6 <vLs020PutChar6x8>:
// bkcolor -  

#if (Include6x8Font == 1)

void vLs020PutChar6x8(char x, char y, char symbol, int color, int bkcolor, char bits_color, char rot)
{	
    2fe6:	6f 92       	push	r6
    2fe8:	7f 92       	push	r7
    2fea:	8f 92       	push	r8
    2fec:	9f 92       	push	r9
    2fee:	af 92       	push	r10
    2ff0:	bf 92       	push	r11
    2ff2:	cf 92       	push	r12
    2ff4:	df 92       	push	r13
    2ff6:	ef 92       	push	r14
    2ff8:	ff 92       	push	r15
    2ffa:	0f 93       	push	r16
    2ffc:	1f 93       	push	r17
    2ffe:	cf 93       	push	r28
    3000:	df 93       	push	r29
    3002:	a4 2e       	mov	r10, r20
    3004:	39 01       	movw	r6, r18
    3006:	f0 2e       	mov	r15, r16
    3008:	0c 2d       	mov	r16, r12
	uint8_t color8,bkcolor8 ;

	if (rot < 4) rot = rot + 4; 
    300a:	04 30       	cpi	r16, 0x04	; 4
    300c:	10 f4       	brcc	.+4      	; 0x3012 <vLs020PutChar6x8+0x2c>
    300e:	0c 5f       	subi	r16, 0xFC	; 252
    3010:	01 c0       	rjmp	.+2      	; 0x3014 <vLs020PutChar6x8+0x2e>
		else rot = rot - 4;
    3012:	04 50       	subi	r16, 0x04	; 4

	vLs020Rotation(x, y, 6, 8, rot);
    3014:	46 e0       	ldi	r20, 0x06	; 6
    3016:	28 e0       	ldi	r18, 0x08	; 8
    3018:	0e 94 7b 15 	call	0x2af6	; 0x2af6 <vLs020Rotation>

//	vLs020Rotation(x, y, 14, 8, 0);
//	vLs020SetWindow(x, y, x + 7, y + 5, 1);

	int offset = 6*(symbol);
    301c:	86 e0       	ldi	r24, 0x06	; 6
    301e:	9a 2d       	mov	r25, r10
    3020:	98 9f       	mul	r25, r24
    3022:	e0 01       	movw	r28, r0
    3024:	11 24       	eor	r1, r1

	switch (bits_color)	
    3026:	8e 2d       	mov	r24, r14
    3028:	88 30       	cpi	r24, 0x08	; 8
    302a:	21 f0       	breq	.+8      	; 0x3034 <vLs020PutChar6x8+0x4e>
    302c:	80 31       	cpi	r24, 0x10	; 16
    302e:	09 f0       	breq	.+2      	; 0x3032 <vLs020PutChar6x8+0x4c>
    3030:	3d c0       	rjmp	.+122    	; 0x30ac <vLs020PutChar6x8+0xc6>
    3032:	12 c0       	rjmp	.+36     	; 0x3058 <vLs020PutChar6x8+0x72>
		{
		case 8: 
			vLs020Mode8bit(0);
    3034:	0e 94 ff 13 	call	0x27fe	; 0x27fe <vLs020Mode8bit.clone.0>
// color   -   
// bkcolor -  

#if (Include6x8Font == 1)

void vLs020PutChar6x8(char x, char y, char symbol, int color, int bkcolor, char bits_color, char rot)
    3038:	8e 01       	movw	r16, r28
    303a:	0a 5f       	subi	r16, 0xFA	; 250
    303c:	1f 4f       	sbci	r17, 0xFF	; 255
    303e:	09 c0       	rjmp	.+18     	; 0x3052 <vLs020PutChar6x8+0x6c>
			for (char i = 0; i < 6 ; i++)
    			for (char j = 0; j<8; j++)
	  				if (((pgm_read_byte(font6x8 + offset + i) >> j) & 0x80) == 0x01)
	    					vLs020WriteData8(color8);
	  				else
	    					vLs020WriteData8(bkcolor8);		
    3040:	8f 2d       	mov	r24, r15
    3042:	0e 94 08 14 	call	0x2810	; 0x2810 <vLs020WriteData8>
    3046:	ea 94       	dec	r14
		case 8: 
			vLs020Mode8bit(0);
			color8 = color & 0x00FF;
			bkcolor8 = bkcolor & 0x00FF;
			for (char i = 0; i < 6 ; i++)
    			for (char j = 0; j<8; j++)
    3048:	d9 f7       	brne	.-10     	; 0x3040 <vLs020PutChar6x8+0x5a>
    304a:	21 96       	adiw	r28, 0x01	; 1
		{
		case 8: 
			vLs020Mode8bit(0);
			color8 = color & 0x00FF;
			bkcolor8 = bkcolor & 0x00FF;
			for (char i = 0; i < 6 ; i++)
    304c:	c0 17       	cp	r28, r16
    304e:	d1 07       	cpc	r29, r17
    3050:	69 f1       	breq	.+90     	; 0x30ac <vLs020PutChar6x8+0xc6>
// bkcolor -  

#if (Include6x8Font == 1)

void vLs020PutChar6x8(char x, char y, char symbol, int color, int bkcolor, char bits_color, char rot)
{	
    3052:	38 e0       	ldi	r19, 0x08	; 8
    3054:	e3 2e       	mov	r14, r19
    3056:	f4 cf       	rjmp	.-24     	; 0x3040 <vLs020PutChar6x8+0x5a>
	  				else
	    					vLs020WriteData8(bkcolor8);		
			break;

		case 16: 
		 	vLs020Mode16bit();
    3058:	0e 94 60 14 	call	0x28c0	; 0x28c0 <vLs020Mode16bit>
// color   -   
// bkcolor -  

#if (Include6x8Font == 1)

void vLs020PutChar6x8(char x, char y, char symbol, int color, int bkcolor, char bits_color, char rot)
    305c:	26 e0       	ldi	r18, 0x06	; 6
    305e:	82 2e       	mov	r8, r18
    3060:	91 2c       	mov	r9, r1
    3062:	8c 0e       	add	r8, r28
    3064:	9d 1e       	adc	r9, r29
    3066:	1a c0       	rjmp	.+52     	; 0x309c <vLs020PutChar6x8+0xb6>

		case 16: 
		 	vLs020Mode16bit();
			for (char i = 0; i < 6 ; i++)
    			for (char j = 0; j<8; j++)
	  				if (((pgm_read_byte(font6x8 + offset + i) >> j) & 0x01) == 0x01)
    3068:	c5 01       	movw	r24, r10
    306a:	0c 2c       	mov	r0, r12
    306c:	02 c0       	rjmp	.+4      	; 0x3072 <vLs020PutChar6x8+0x8c>
    306e:	95 95       	asr	r25
    3070:	87 95       	ror	r24
    3072:	0a 94       	dec	r0
    3074:	e2 f7       	brpl	.-8      	; 0x306e <vLs020PutChar6x8+0x88>
    3076:	80 ff       	sbrs	r24, 0
    3078:	02 c0       	rjmp	.+4      	; 0x307e <vLs020PutChar6x8+0x98>
	    					vLs020WriteData16(color);
    307a:	c3 01       	movw	r24, r6
    307c:	02 c0       	rjmp	.+4      	; 0x3082 <vLs020PutChar6x8+0x9c>
	  				else
	    					vLs020WriteData16(bkcolor);	
    307e:	8f 2d       	mov	r24, r15
    3080:	91 2f       	mov	r25, r17
    3082:	0e 94 10 14 	call	0x2820	; 0x2820 <vLs020WriteData16>
    3086:	08 94       	sec
    3088:	c1 1c       	adc	r12, r1
    308a:	d1 1c       	adc	r13, r1
			break;

		case 16: 
		 	vLs020Mode16bit();
			for (char i = 0; i < 6 ; i++)
    			for (char j = 0; j<8; j++)
    308c:	98 e0       	ldi	r25, 0x08	; 8
    308e:	c9 16       	cp	r12, r25
    3090:	d1 04       	cpc	r13, r1
    3092:	51 f7       	brne	.-44     	; 0x3068 <vLs020PutChar6x8+0x82>
    3094:	21 96       	adiw	r28, 0x01	; 1
	    					vLs020WriteData8(bkcolor8);		
			break;

		case 16: 
		 	vLs020Mode16bit();
			for (char i = 0; i < 6 ; i++)
    3096:	c8 15       	cp	r28, r8
    3098:	d9 05       	cpc	r29, r9
    309a:	41 f0       	breq	.+16     	; 0x30ac <vLs020PutChar6x8+0xc6>
// bkcolor -  

#if (Include6x8Font == 1)

void vLs020PutChar6x8(char x, char y, char symbol, int color, int bkcolor, char bits_color, char rot)
{	
    309c:	cc 24       	eor	r12, r12
    309e:	dd 24       	eor	r13, r13

		case 16: 
		 	vLs020Mode16bit();
			for (char i = 0; i < 6 ; i++)
    			for (char j = 0; j<8; j++)
	  				if (((pgm_read_byte(font6x8 + offset + i) >> j) & 0x01) == 0x01)
    30a0:	fe 01       	movw	r30, r28
    30a2:	ec 51       	subi	r30, 0x1C	; 28
    30a4:	ff 4f       	sbci	r31, 0xFF	; 255
    30a6:	a4 90       	lpm	r10, Z+
    30a8:	bb 24       	eor	r11, r11
    30aa:	de cf       	rjmp	.-68     	; 0x3068 <vLs020PutChar6x8+0x82>
	    					vLs020WriteData16(bkcolor);	
			break;
		
		}
  	
	vLs020Mode8bit(0);
    30ac:	0e 94 ff 13 	call	0x27fe	; 0x27fe <vLs020Mode8bit.clone.0>
	vLs020ZeroRotation();
    30b0:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <vLs020ZeroRotation>
  	
}
    30b4:	df 91       	pop	r29
    30b6:	cf 91       	pop	r28
    30b8:	1f 91       	pop	r17
    30ba:	0f 91       	pop	r16
    30bc:	ff 90       	pop	r15
    30be:	ef 90       	pop	r14
    30c0:	df 90       	pop	r13
    30c2:	cf 90       	pop	r12
    30c4:	bf 90       	pop	r11
    30c6:	af 90       	pop	r10
    30c8:	9f 90       	pop	r9
    30ca:	8f 90       	pop	r8
    30cc:	7f 90       	pop	r7
    30ce:	6f 90       	pop	r6
    30d0:	08 95       	ret

000030d2 <vLs020PutString6x8>:
// color   -   
// bkcolor -  
#if (Include6x8Font == 1)

void vLs020PutString6x8(char x, char y, char * text, int color, int bkcolor, char bits_color, char rot)
{
    30d2:	6f 92       	push	r6
    30d4:	7f 92       	push	r7
    30d6:	8f 92       	push	r8
    30d8:	9f 92       	push	r9
    30da:	af 92       	push	r10
    30dc:	bf 92       	push	r11
    30de:	cf 92       	push	r12
    30e0:	df 92       	push	r13
    30e2:	ef 92       	push	r14
    30e4:	ff 92       	push	r15
    30e6:	0f 93       	push	r16
    30e8:	1f 93       	push	r17
    30ea:	cf 93       	push	r28
    30ec:	df 93       	push	r29
    30ee:	b8 2e       	mov	r11, r24
    30f0:	f6 2e       	mov	r15, r22
    30f2:	4a 01       	movw	r8, r20
    30f4:	39 01       	movw	r6, r18
    30f6:	e8 01       	movw	r28, r16
    30f8:	de 2c       	mov	r13, r14
    30fa:	8c 2d       	mov	r24, r12
    	vLs020PutChar6x8(x,y+y0,text[i], color,bkcolor, bits_color, rot);
    	i++;
    	y0+=6;
  		}
*/	
	switch (rot)
    30fc:	83 30       	cpi	r24, 0x03	; 3
    30fe:	c1 f0       	breq	.+48     	; 0x3130 <vLs020PutString6x8+0x5e>
    3100:	84 30       	cpi	r24, 0x04	; 4
    3102:	28 f4       	brcc	.+10     	; 0x310e <vLs020PutString6x8+0x3c>
    3104:	81 30       	cpi	r24, 0x01	; 1
    3106:	c1 f0       	breq	.+48     	; 0x3138 <vLs020PutString6x8+0x66>
    3108:	82 30       	cpi	r24, 0x02	; 2
    310a:	a0 f4       	brcc	.+40     	; 0x3134 <vLs020PutString6x8+0x62>
    310c:	17 c0       	rjmp	.+46     	; 0x313c <vLs020PutString6x8+0x6a>
    310e:	85 30       	cpi	r24, 0x05	; 5
    3110:	59 f0       	breq	.+22     	; 0x3128 <vLs020PutString6x8+0x56>
    3112:	85 30       	cpi	r24, 0x05	; 5
    3114:	58 f0       	brcs	.+22     	; 0x312c <vLs020PutString6x8+0x5a>
    3116:	86 30       	cpi	r24, 0x06	; 6
    3118:	29 f0       	breq	.+10     	; 0x3124 <vLs020PutString6x8+0x52>
    311a:	87 30       	cpi	r24, 0x07	; 7
    311c:	09 f0       	breq	.+2      	; 0x3120 <vLs020PutString6x8+0x4e>
    311e:	a6 c0       	rjmp	.+332    	; 0x326c <vLs020PutString6x8+0x19a>
    3120:	aa 24       	eor	r10, r10
    3122:	9e c0       	rjmp	.+316    	; 0x3260 <vLs020PutString6x8+0x18e>
    3124:	aa 24       	eor	r10, r10
    3126:	89 c0       	rjmp	.+274    	; 0x323a <vLs020PutString6x8+0x168>
    3128:	aa 24       	eor	r10, r10
    312a:	74 c0       	rjmp	.+232    	; 0x3214 <vLs020PutString6x8+0x142>
    312c:	aa 24       	eor	r10, r10
    312e:	5f c0       	rjmp	.+190    	; 0x31ee <vLs020PutString6x8+0x11c>
    3130:	aa 24       	eor	r10, r10
    3132:	4a c0       	rjmp	.+148    	; 0x31c8 <vLs020PutString6x8+0xf6>
    3134:	aa 24       	eor	r10, r10
    3136:	35 c0       	rjmp	.+106    	; 0x31a2 <vLs020PutString6x8+0xd0>
    3138:	aa 24       	eor	r10, r10
    313a:	20 c0       	rjmp	.+64     	; 0x317c <vLs020PutString6x8+0xaa>
    313c:	aa 24       	eor	r10, r10
    313e:	0b c0       	rjmp	.+22     	; 0x3156 <vLs020PutString6x8+0x84>
		{
		case 0:
			while (text[i] != 0)
  				{
				vLs020PutChar6x8(x, y + y0, text[i], color, bkcolor, bits_color, rot);
    3140:	8b 2d       	mov	r24, r11
    3142:	6f 2d       	mov	r22, r15
    3144:	93 01       	movw	r18, r6
    3146:	8e 01       	movw	r16, r28
    3148:	ed 2c       	mov	r14, r13
    314a:	cc 24       	eor	r12, r12
    314c:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vLs020PutChar6x8>
    			i++;
    3150:	a3 94       	inc	r10
    3152:	86 e0       	ldi	r24, 0x06	; 6
    3154:	f8 0e       	add	r15, r24
  		}
*/	
	switch (rot)
		{
		case 0:
			while (text[i] != 0)
    3156:	f4 01       	movw	r30, r8
    3158:	ea 0d       	add	r30, r10
    315a:	f1 1d       	adc	r31, r1
    315c:	40 81       	ld	r20, Z
    315e:	44 23       	and	r20, r20
    3160:	79 f7       	brne	.-34     	; 0x3140 <vLs020PutString6x8+0x6e>
    3162:	84 c0       	rjmp	.+264    	; 0x326c <vLs020PutString6x8+0x19a>
			break;

		case 1:
			while (text[i] != 0)
  				{
				vLs020PutChar6x8(x, y - y0, text[i], color, bkcolor, bits_color, rot);
    3164:	8b 2d       	mov	r24, r11
    3166:	6f 2d       	mov	r22, r15
    3168:	93 01       	movw	r18, r6
    316a:	8e 01       	movw	r16, r28
    316c:	ed 2c       	mov	r14, r13
    316e:	cc 24       	eor	r12, r12
    3170:	c3 94       	inc	r12
    3172:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vLs020PutChar6x8>
    			i++;
    3176:	a3 94       	inc	r10
    3178:	8a ef       	ldi	r24, 0xFA	; 250
    317a:	f8 0e       	add	r15, r24
    			y0+=6;
  				}
			break;

		case 1:
			while (text[i] != 0)
    317c:	f4 01       	movw	r30, r8
    317e:	ea 0d       	add	r30, r10
    3180:	f1 1d       	adc	r31, r1
    3182:	40 81       	ld	r20, Z
    3184:	44 23       	and	r20, r20
    3186:	71 f7       	brne	.-36     	; 0x3164 <vLs020PutString6x8+0x92>
    3188:	71 c0       	rjmp	.+226    	; 0x326c <vLs020PutString6x8+0x19a>
			break;
			
		case 2:
			while (text[i] != 0)
  				{
				vLs020PutChar6x8(x, y + y0, text[i], color, bkcolor, bits_color, rot);
    318a:	8b 2d       	mov	r24, r11
    318c:	6f 2d       	mov	r22, r15
    318e:	93 01       	movw	r18, r6
    3190:	8e 01       	movw	r16, r28
    3192:	ed 2c       	mov	r14, r13
    3194:	b2 e0       	ldi	r27, 0x02	; 2
    3196:	cb 2e       	mov	r12, r27
    3198:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vLs020PutChar6x8>
    			i++;
    319c:	a3 94       	inc	r10
    319e:	86 e0       	ldi	r24, 0x06	; 6
    31a0:	f8 0e       	add	r15, r24
    			y0+=6;
  				}
			break;
			
		case 2:
			while (text[i] != 0)
    31a2:	f4 01       	movw	r30, r8
    31a4:	ea 0d       	add	r30, r10
    31a6:	f1 1d       	adc	r31, r1
    31a8:	40 81       	ld	r20, Z
    31aa:	44 23       	and	r20, r20
    31ac:	71 f7       	brne	.-36     	; 0x318a <vLs020PutString6x8+0xb8>
    31ae:	5e c0       	rjmp	.+188    	; 0x326c <vLs020PutString6x8+0x19a>
			break;					

		case 3:
			while (text[i] != 0)
  				{
				vLs020PutChar6x8(x, y - y0, text[i], color, bkcolor, bits_color, rot);
    31b0:	8b 2d       	mov	r24, r11
    31b2:	6f 2d       	mov	r22, r15
    31b4:	93 01       	movw	r18, r6
    31b6:	8e 01       	movw	r16, r28
    31b8:	ed 2c       	mov	r14, r13
    31ba:	a3 e0       	ldi	r26, 0x03	; 3
    31bc:	ca 2e       	mov	r12, r26
    31be:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vLs020PutChar6x8>
    			i++;
    31c2:	a3 94       	inc	r10
    31c4:	8a ef       	ldi	r24, 0xFA	; 250
    31c6:	f8 0e       	add	r15, r24
    			y0+=6;
  				}
			break;					

		case 3:
			while (text[i] != 0)
    31c8:	f4 01       	movw	r30, r8
    31ca:	ea 0d       	add	r30, r10
    31cc:	f1 1d       	adc	r31, r1
    31ce:	40 81       	ld	r20, Z
    31d0:	44 23       	and	r20, r20
    31d2:	71 f7       	brne	.-36     	; 0x31b0 <vLs020PutString6x8+0xde>
    31d4:	4b c0       	rjmp	.+150    	; 0x326c <vLs020PutString6x8+0x19a>
			break;

		case 4:
			while (text[i] != 0)
  				{
				vLs020PutChar6x8(x + x0, y, text[i], color, bkcolor, bits_color, rot);
    31d6:	8b 2d       	mov	r24, r11
    31d8:	6f 2d       	mov	r22, r15
    31da:	93 01       	movw	r18, r6
    31dc:	8e 01       	movw	r16, r28
    31de:	ed 2c       	mov	r14, r13
    31e0:	f4 e0       	ldi	r31, 0x04	; 4
    31e2:	cf 2e       	mov	r12, r31
    31e4:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vLs020PutChar6x8>
    			i++;
    31e8:	a3 94       	inc	r10
    31ea:	86 e0       	ldi	r24, 0x06	; 6
    31ec:	b8 0e       	add	r11, r24
    			y0+=6;
  				}
			break;

		case 4:
			while (text[i] != 0)
    31ee:	f4 01       	movw	r30, r8
    31f0:	ea 0d       	add	r30, r10
    31f2:	f1 1d       	adc	r31, r1
    31f4:	40 81       	ld	r20, Z
    31f6:	44 23       	and	r20, r20
    31f8:	71 f7       	brne	.-36     	; 0x31d6 <vLs020PutString6x8+0x104>
    31fa:	38 c0       	rjmp	.+112    	; 0x326c <vLs020PutString6x8+0x19a>
			break;

		case 5:
			while (text[i] != 0)
  				{
				vLs020PutChar6x8(x + x0, y, text[i], color, bkcolor, bits_color, rot);
    31fc:	8b 2d       	mov	r24, r11
    31fe:	6f 2d       	mov	r22, r15
    3200:	93 01       	movw	r18, r6
    3202:	8e 01       	movw	r16, r28
    3204:	ed 2c       	mov	r14, r13
    3206:	e5 e0       	ldi	r30, 0x05	; 5
    3208:	ce 2e       	mov	r12, r30
    320a:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vLs020PutChar6x8>
    			i++;
    320e:	a3 94       	inc	r10
    3210:	86 e0       	ldi	r24, 0x06	; 6
    3212:	b8 0e       	add	r11, r24
    			x0+=6;
  				}
			break;

		case 5:
			while (text[i] != 0)
    3214:	f4 01       	movw	r30, r8
    3216:	ea 0d       	add	r30, r10
    3218:	f1 1d       	adc	r31, r1
    321a:	40 81       	ld	r20, Z
    321c:	44 23       	and	r20, r20
    321e:	71 f7       	brne	.-36     	; 0x31fc <vLs020PutString6x8+0x12a>
    3220:	25 c0       	rjmp	.+74     	; 0x326c <vLs020PutString6x8+0x19a>
			break;
			
		case 6:
			while (text[i] != 0)
  				{
				vLs020PutChar6x8(x - x0, y, text[i], color, bkcolor, bits_color, rot);
    3222:	8b 2d       	mov	r24, r11
    3224:	6f 2d       	mov	r22, r15
    3226:	93 01       	movw	r18, r6
    3228:	8e 01       	movw	r16, r28
    322a:	ed 2c       	mov	r14, r13
    322c:	76 e0       	ldi	r23, 0x06	; 6
    322e:	c7 2e       	mov	r12, r23
    3230:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vLs020PutChar6x8>
    			i++;
    3234:	a3 94       	inc	r10
    3236:	8a ef       	ldi	r24, 0xFA	; 250
    3238:	b8 0e       	add	r11, r24
    			x0+=6;
  				}
			break;
			
		case 6:
			while (text[i] != 0)
    323a:	f4 01       	movw	r30, r8
    323c:	ea 0d       	add	r30, r10
    323e:	f1 1d       	adc	r31, r1
    3240:	40 81       	ld	r20, Z
    3242:	44 23       	and	r20, r20
    3244:	71 f7       	brne	.-36     	; 0x3222 <vLs020PutString6x8+0x150>
    3246:	12 c0       	rjmp	.+36     	; 0x326c <vLs020PutString6x8+0x19a>
			break;					

		case 7:
			while (text[i] != 0)
  				{
				vLs020PutChar6x8(x - x0, y, text[i], color, bkcolor, bits_color, rot);
    3248:	8b 2d       	mov	r24, r11
    324a:	6f 2d       	mov	r22, r15
    324c:	93 01       	movw	r18, r6
    324e:	8e 01       	movw	r16, r28
    3250:	ed 2c       	mov	r14, r13
    3252:	57 e0       	ldi	r21, 0x07	; 7
    3254:	c5 2e       	mov	r12, r21
    3256:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vLs020PutChar6x8>
    			i++;
    325a:	a3 94       	inc	r10
    325c:	8a ef       	ldi	r24, 0xFA	; 250
    325e:	b8 0e       	add	r11, r24
    			x0+=6;
  				}
			break;					

		case 7:
			while (text[i] != 0)
    3260:	f4 01       	movw	r30, r8
    3262:	ea 0d       	add	r30, r10
    3264:	f1 1d       	adc	r31, r1
    3266:	40 81       	ld	r20, Z
    3268:	44 23       	and	r20, r20
    326a:	71 f7       	brne	.-36     	; 0x3248 <vLs020PutString6x8+0x176>
    			i++;
    			x0+=6;
  				}
			break;
		}
	vLs020ZeroRotation();
    326c:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <vLs020ZeroRotation>

}
    3270:	df 91       	pop	r29
    3272:	cf 91       	pop	r28
    3274:	1f 91       	pop	r17
    3276:	0f 91       	pop	r16
    3278:	ff 90       	pop	r15
    327a:	ef 90       	pop	r14
    327c:	df 90       	pop	r13
    327e:	cf 90       	pop	r12
    3280:	bf 90       	pop	r11
    3282:	af 90       	pop	r10
    3284:	9f 90       	pop	r9
    3286:	8f 90       	pop	r8
    3288:	7f 90       	pop	r7
    328a:	6f 90       	pop	r6
    328c:	08 95       	ret

0000328e <vLs020PutString8x14>:
// bkcolor -  

#if (Include8x14Font == 1)

void vLs020PutString8x14(char x, char y, char * text, int color, int bkcolor, char bits_color, char rot)
{
    328e:	6f 92       	push	r6
    3290:	7f 92       	push	r7
    3292:	8f 92       	push	r8
    3294:	9f 92       	push	r9
    3296:	af 92       	push	r10
    3298:	bf 92       	push	r11
    329a:	cf 92       	push	r12
    329c:	df 92       	push	r13
    329e:	ef 92       	push	r14
    32a0:	ff 92       	push	r15
    32a2:	0f 93       	push	r16
    32a4:	1f 93       	push	r17
    32a6:	cf 93       	push	r28
    32a8:	df 93       	push	r29
    32aa:	b8 2e       	mov	r11, r24
    32ac:	f6 2e       	mov	r15, r22
    32ae:	4a 01       	movw	r8, r20
    32b0:	39 01       	movw	r6, r18
    32b2:	e8 01       	movw	r28, r16
    32b4:	de 2c       	mov	r13, r14
    32b6:	8c 2d       	mov	r24, r12
		vLs020PutChar8x14(x, y + y0, text[i], color, bkcolor, bits_color, rot);
    	i++;
    	y0+=8;
  		}
*/
	switch (rot)
    32b8:	83 30       	cpi	r24, 0x03	; 3
    32ba:	c1 f0       	breq	.+48     	; 0x32ec <vLs020PutString8x14+0x5e>
    32bc:	84 30       	cpi	r24, 0x04	; 4
    32be:	28 f4       	brcc	.+10     	; 0x32ca <vLs020PutString8x14+0x3c>
    32c0:	81 30       	cpi	r24, 0x01	; 1
    32c2:	c1 f0       	breq	.+48     	; 0x32f4 <vLs020PutString8x14+0x66>
    32c4:	82 30       	cpi	r24, 0x02	; 2
    32c6:	a0 f4       	brcc	.+40     	; 0x32f0 <vLs020PutString8x14+0x62>
    32c8:	17 c0       	rjmp	.+46     	; 0x32f8 <vLs020PutString8x14+0x6a>
    32ca:	85 30       	cpi	r24, 0x05	; 5
    32cc:	59 f0       	breq	.+22     	; 0x32e4 <vLs020PutString8x14+0x56>
    32ce:	85 30       	cpi	r24, 0x05	; 5
    32d0:	58 f0       	brcs	.+22     	; 0x32e8 <vLs020PutString8x14+0x5a>
    32d2:	86 30       	cpi	r24, 0x06	; 6
    32d4:	29 f0       	breq	.+10     	; 0x32e0 <vLs020PutString8x14+0x52>
    32d6:	87 30       	cpi	r24, 0x07	; 7
    32d8:	09 f0       	breq	.+2      	; 0x32dc <vLs020PutString8x14+0x4e>
    32da:	a6 c0       	rjmp	.+332    	; 0x3428 <vLs020PutString8x14+0x19a>
    32dc:	aa 24       	eor	r10, r10
    32de:	9e c0       	rjmp	.+316    	; 0x341c <vLs020PutString8x14+0x18e>
    32e0:	aa 24       	eor	r10, r10
    32e2:	89 c0       	rjmp	.+274    	; 0x33f6 <vLs020PutString8x14+0x168>
    32e4:	aa 24       	eor	r10, r10
    32e6:	74 c0       	rjmp	.+232    	; 0x33d0 <vLs020PutString8x14+0x142>
    32e8:	aa 24       	eor	r10, r10
    32ea:	5f c0       	rjmp	.+190    	; 0x33aa <vLs020PutString8x14+0x11c>
    32ec:	aa 24       	eor	r10, r10
    32ee:	4a c0       	rjmp	.+148    	; 0x3384 <vLs020PutString8x14+0xf6>
    32f0:	aa 24       	eor	r10, r10
    32f2:	35 c0       	rjmp	.+106    	; 0x335e <vLs020PutString8x14+0xd0>
    32f4:	aa 24       	eor	r10, r10
    32f6:	20 c0       	rjmp	.+64     	; 0x3338 <vLs020PutString8x14+0xaa>
    32f8:	aa 24       	eor	r10, r10
    32fa:	0b c0       	rjmp	.+22     	; 0x3312 <vLs020PutString8x14+0x84>
		{
		case 0:
			while (text[i] != 0)
  				{
				vLs020PutChar8x14(x, y + y0, text[i], color, bkcolor, bits_color, rot);
    32fc:	8b 2d       	mov	r24, r11
    32fe:	6f 2d       	mov	r22, r15
    3300:	93 01       	movw	r18, r6
    3302:	8e 01       	movw	r16, r28
    3304:	ed 2c       	mov	r14, r13
    3306:	cc 24       	eor	r12, r12
    3308:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <vLs020PutChar8x14>
    			i++;
    330c:	a3 94       	inc	r10
    330e:	88 e0       	ldi	r24, 0x08	; 8
    3310:	f8 0e       	add	r15, r24
  		}
*/
	switch (rot)
		{
		case 0:
			while (text[i] != 0)
    3312:	f4 01       	movw	r30, r8
    3314:	ea 0d       	add	r30, r10
    3316:	f1 1d       	adc	r31, r1
    3318:	40 81       	ld	r20, Z
    331a:	44 23       	and	r20, r20
    331c:	79 f7       	brne	.-34     	; 0x32fc <vLs020PutString8x14+0x6e>
    331e:	84 c0       	rjmp	.+264    	; 0x3428 <vLs020PutString8x14+0x19a>
			break;

		case 1:
			while (text[i] != 0)
  				{
				vLs020PutChar8x14(x, y - y0, text[i], color, bkcolor, bits_color, rot);
    3320:	8b 2d       	mov	r24, r11
    3322:	6f 2d       	mov	r22, r15
    3324:	93 01       	movw	r18, r6
    3326:	8e 01       	movw	r16, r28
    3328:	ed 2c       	mov	r14, r13
    332a:	cc 24       	eor	r12, r12
    332c:	c3 94       	inc	r12
    332e:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <vLs020PutChar8x14>
    			i++;
    3332:	a3 94       	inc	r10
    3334:	88 ef       	ldi	r24, 0xF8	; 248
    3336:	f8 0e       	add	r15, r24
    			y0+=8;
  				}
			break;

		case 1:
			while (text[i] != 0)
    3338:	f4 01       	movw	r30, r8
    333a:	ea 0d       	add	r30, r10
    333c:	f1 1d       	adc	r31, r1
    333e:	40 81       	ld	r20, Z
    3340:	44 23       	and	r20, r20
    3342:	71 f7       	brne	.-36     	; 0x3320 <vLs020PutString8x14+0x92>
    3344:	71 c0       	rjmp	.+226    	; 0x3428 <vLs020PutString8x14+0x19a>
			break;
			
		case 2:
			while (text[i] != 0)
  				{
				vLs020PutChar8x14(x, y + y0, text[i], color, bkcolor, bits_color, rot);
    3346:	8b 2d       	mov	r24, r11
    3348:	6f 2d       	mov	r22, r15
    334a:	93 01       	movw	r18, r6
    334c:	8e 01       	movw	r16, r28
    334e:	ed 2c       	mov	r14, r13
    3350:	a2 e0       	ldi	r26, 0x02	; 2
    3352:	ca 2e       	mov	r12, r26
    3354:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <vLs020PutChar8x14>
    			i++;
    3358:	a3 94       	inc	r10
    335a:	88 e0       	ldi	r24, 0x08	; 8
    335c:	f8 0e       	add	r15, r24
    			y0+=8;
  				}
			break;
			
		case 2:
			while (text[i] != 0)
    335e:	f4 01       	movw	r30, r8
    3360:	ea 0d       	add	r30, r10
    3362:	f1 1d       	adc	r31, r1
    3364:	40 81       	ld	r20, Z
    3366:	44 23       	and	r20, r20
    3368:	71 f7       	brne	.-36     	; 0x3346 <vLs020PutString8x14+0xb8>
    336a:	5e c0       	rjmp	.+188    	; 0x3428 <vLs020PutString8x14+0x19a>
			break;					

		case 3:
			while (text[i] != 0)
  				{
				vLs020PutChar8x14(x, y - y0, text[i], color, bkcolor, bits_color, rot);
    336c:	8b 2d       	mov	r24, r11
    336e:	6f 2d       	mov	r22, r15
    3370:	93 01       	movw	r18, r6
    3372:	8e 01       	movw	r16, r28
    3374:	ed 2c       	mov	r14, r13
    3376:	f3 e0       	ldi	r31, 0x03	; 3
    3378:	cf 2e       	mov	r12, r31
    337a:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <vLs020PutChar8x14>
    			i++;
    337e:	a3 94       	inc	r10
    3380:	88 ef       	ldi	r24, 0xF8	; 248
    3382:	f8 0e       	add	r15, r24
    			y0+=8;
  				}
			break;					

		case 3:
			while (text[i] != 0)
    3384:	f4 01       	movw	r30, r8
    3386:	ea 0d       	add	r30, r10
    3388:	f1 1d       	adc	r31, r1
    338a:	40 81       	ld	r20, Z
    338c:	44 23       	and	r20, r20
    338e:	71 f7       	brne	.-36     	; 0x336c <vLs020PutString8x14+0xde>
    3390:	4b c0       	rjmp	.+150    	; 0x3428 <vLs020PutString8x14+0x19a>
			break;

		case 4:
			while (text[i] != 0)
  				{
				vLs020PutChar8x14(x + x0, y, text[i], color, bkcolor, bits_color, rot);
    3392:	8b 2d       	mov	r24, r11
    3394:	6f 2d       	mov	r22, r15
    3396:	93 01       	movw	r18, r6
    3398:	8e 01       	movw	r16, r28
    339a:	ed 2c       	mov	r14, r13
    339c:	e4 e0       	ldi	r30, 0x04	; 4
    339e:	ce 2e       	mov	r12, r30
    33a0:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <vLs020PutChar8x14>
    			i++;
    33a4:	a3 94       	inc	r10
    33a6:	88 e0       	ldi	r24, 0x08	; 8
    33a8:	b8 0e       	add	r11, r24
    			y0+=8;
  				}
			break;

		case 4:
			while (text[i] != 0)
    33aa:	f4 01       	movw	r30, r8
    33ac:	ea 0d       	add	r30, r10
    33ae:	f1 1d       	adc	r31, r1
    33b0:	40 81       	ld	r20, Z
    33b2:	44 23       	and	r20, r20
    33b4:	71 f7       	brne	.-36     	; 0x3392 <vLs020PutString8x14+0x104>
    33b6:	38 c0       	rjmp	.+112    	; 0x3428 <vLs020PutString8x14+0x19a>
			break;

		case 5:
			while (text[i] != 0)
  				{
				vLs020PutChar8x14(x + x0, y, text[i], color, bkcolor, bits_color, rot);
    33b8:	8b 2d       	mov	r24, r11
    33ba:	6f 2d       	mov	r22, r15
    33bc:	93 01       	movw	r18, r6
    33be:	8e 01       	movw	r16, r28
    33c0:	ed 2c       	mov	r14, r13
    33c2:	75 e0       	ldi	r23, 0x05	; 5
    33c4:	c7 2e       	mov	r12, r23
    33c6:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <vLs020PutChar8x14>
    			i++;
    33ca:	a3 94       	inc	r10
    33cc:	88 e0       	ldi	r24, 0x08	; 8
    33ce:	b8 0e       	add	r11, r24
    			x0+=8;
  				}
			break;

		case 5:
			while (text[i] != 0)
    33d0:	f4 01       	movw	r30, r8
    33d2:	ea 0d       	add	r30, r10
    33d4:	f1 1d       	adc	r31, r1
    33d6:	40 81       	ld	r20, Z
    33d8:	44 23       	and	r20, r20
    33da:	71 f7       	brne	.-36     	; 0x33b8 <vLs020PutString8x14+0x12a>
    33dc:	25 c0       	rjmp	.+74     	; 0x3428 <vLs020PutString8x14+0x19a>
			break;
			
		case 6:
			while (text[i] != 0)
  				{
				vLs020PutChar8x14(x - x0, y, text[i], color, bkcolor, bits_color, rot);
    33de:	8b 2d       	mov	r24, r11
    33e0:	6f 2d       	mov	r22, r15
    33e2:	93 01       	movw	r18, r6
    33e4:	8e 01       	movw	r16, r28
    33e6:	ed 2c       	mov	r14, r13
    33e8:	56 e0       	ldi	r21, 0x06	; 6
    33ea:	c5 2e       	mov	r12, r21
    33ec:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <vLs020PutChar8x14>
    			i++;
    33f0:	a3 94       	inc	r10
    33f2:	88 ef       	ldi	r24, 0xF8	; 248
    33f4:	b8 0e       	add	r11, r24
    			x0+=8;
  				}
			break;
			
		case 6:
			while (text[i] != 0)
    33f6:	f4 01       	movw	r30, r8
    33f8:	ea 0d       	add	r30, r10
    33fa:	f1 1d       	adc	r31, r1
    33fc:	40 81       	ld	r20, Z
    33fe:	44 23       	and	r20, r20
    3400:	71 f7       	brne	.-36     	; 0x33de <vLs020PutString8x14+0x150>
    3402:	12 c0       	rjmp	.+36     	; 0x3428 <vLs020PutString8x14+0x19a>
			break;					

		case 7:
			while (text[i] != 0)
  				{
				vLs020PutChar8x14(x - x0, y, text[i], color, bkcolor, bits_color, rot);
    3404:	8b 2d       	mov	r24, r11
    3406:	6f 2d       	mov	r22, r15
    3408:	93 01       	movw	r18, r6
    340a:	8e 01       	movw	r16, r28
    340c:	ed 2c       	mov	r14, r13
    340e:	97 e0       	ldi	r25, 0x07	; 7
    3410:	c9 2e       	mov	r12, r25
    3412:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <vLs020PutChar8x14>
    			i++;
    3416:	a3 94       	inc	r10
    3418:	88 ef       	ldi	r24, 0xF8	; 248
    341a:	b8 0e       	add	r11, r24
    			x0+=8;
  				}
			break;					

		case 7:
			while (text[i] != 0)
    341c:	f4 01       	movw	r30, r8
    341e:	ea 0d       	add	r30, r10
    3420:	f1 1d       	adc	r31, r1
    3422:	40 81       	ld	r20, Z
    3424:	44 23       	and	r20, r20
    3426:	71 f7       	brne	.-36     	; 0x3404 <vLs020PutString8x14+0x176>
    			i++;
    			x0+=8;
  				}
			break;
		}
	vLs020ZeroRotation();
    3428:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <vLs020ZeroRotation>
}
    342c:	df 91       	pop	r29
    342e:	cf 91       	pop	r28
    3430:	1f 91       	pop	r17
    3432:	0f 91       	pop	r16
    3434:	ff 90       	pop	r15
    3436:	ef 90       	pop	r14
    3438:	df 90       	pop	r13
    343a:	cf 90       	pop	r12
    343c:	bf 90       	pop	r11
    343e:	af 90       	pop	r10
    3440:	9f 90       	pop	r9
    3442:	8f 90       	pop	r8
    3444:	7f 90       	pop	r7
    3446:	6f 90       	pop	r6
    3448:	08 95       	ret

0000344a <vLs020Rectangle>:
#endif

//------------------------------------------------------------------------------------------------------
//      
void vLs020Rectangle(char x1, char y1, char x2, char y2, int color, char bits_color)
{	
    344a:	af 92       	push	r10
    344c:	bf 92       	push	r11
    344e:	cf 92       	push	r12
    3450:	df 92       	push	r13
    3452:	ef 92       	push	r14
    3454:	ff 92       	push	r15
    3456:	0f 93       	push	r16
    3458:	1f 93       	push	r17
    345a:	f8 2e       	mov	r15, r24
    345c:	a6 2e       	mov	r10, r22
    345e:	d4 2e       	mov	r13, r20
    3460:	c2 2e       	mov	r12, r18
    3462:	b0 2e       	mov	r11, r16
	vLs020SetWindow(x1,y1,x2,y2,1);
    3464:	01 e0       	ldi	r16, 0x01	; 1
    3466:	0e 94 7b 14 	call	0x28f6	; 0x28f6 <vLs020SetWindow>
	uint8_t color8 ;
	switch (bits_color)	
    346a:	8e 2d       	mov	r24, r14
    346c:	88 30       	cpi	r24, 0x08	; 8
    346e:	19 f0       	breq	.+6      	; 0x3476 <vLs020Rectangle+0x2c>
    3470:	80 31       	cpi	r24, 0x10	; 16
    3472:	f1 f4       	brne	.+60     	; 0x34b0 <vLs020Rectangle+0x66>
    3474:	0e c0       	rjmp	.+28     	; 0x3492 <vLs020Rectangle+0x48>
		{
		case 8: 
			color8 = color & 0x00FF;
			vLs020Mode8bit(0);  
    3476:	0e 94 ff 13 	call	0x27fe	; 0x27fe <vLs020Mode8bit.clone.0>
			for (char y = y1; y <= y2; y++)
    347a:	07 c0       	rjmp	.+14     	; 0x348a <vLs020Rectangle+0x40>
    			for (char x = x1; x <= x2; x++)
    				vLs020WriteData8(color8);		
    347c:	8b 2d       	mov	r24, r11
    347e:	0e 94 08 14 	call	0x2810	; 0x2810 <vLs020WriteData8>
		{
		case 8: 
			color8 = color & 0x00FF;
			vLs020Mode8bit(0);  
			for (char y = y1; y <= y2; y++)
    			for (char x = x1; x <= x2; x++)
    3482:	1f 5f       	subi	r17, 0xFF	; 255
    3484:	d1 16       	cp	r13, r17
    3486:	d0 f7       	brcc	.-12     	; 0x347c <vLs020Rectangle+0x32>
	switch (bits_color)	
		{
		case 8: 
			color8 = color & 0x00FF;
			vLs020Mode8bit(0);  
			for (char y = y1; y <= y2; y++)
    3488:	a3 94       	inc	r10
    348a:	ca 14       	cp	r12, r10
    348c:	88 f0       	brcs	.+34     	; 0x34b0 <vLs020Rectangle+0x66>
    348e:	1f 2d       	mov	r17, r15
    3490:	f9 cf       	rjmp	.-14     	; 0x3484 <vLs020Rectangle+0x3a>
    			for (char x = x1; x <= x2; x++)
    				vLs020WriteData8(color8);		
			break;

		case 16: 
		 	vLs020Mode16bit();
    3492:	0e 94 60 14 	call	0x28c0	; 0x28c0 <vLs020Mode16bit>
			for (char y = y1; y <= y2; y++)
    3496:	08 c0       	rjmp	.+16     	; 0x34a8 <vLs020Rectangle+0x5e>
    			for (char x = x1; x <= x2; x++)
    				vLs020WriteData16(color);
    3498:	8b 2d       	mov	r24, r11
    349a:	91 2f       	mov	r25, r17
    349c:	0e 94 10 14 	call	0x2820	; 0x2820 <vLs020WriteData16>
			break;

		case 16: 
		 	vLs020Mode16bit();
			for (char y = y1; y <= y2; y++)
    			for (char x = x1; x <= x2; x++)
    34a0:	e3 94       	inc	r14
    34a2:	de 14       	cp	r13, r14
    34a4:	c8 f7       	brcc	.-14     	; 0x3498 <vLs020Rectangle+0x4e>
    				vLs020WriteData8(color8);		
			break;

		case 16: 
		 	vLs020Mode16bit();
			for (char y = y1; y <= y2; y++)
    34a6:	a3 94       	inc	r10
    34a8:	ca 14       	cp	r12, r10
    34aa:	10 f0       	brcs	.+4      	; 0x34b0 <vLs020Rectangle+0x66>
    34ac:	ef 2c       	mov	r14, r15
    34ae:	f9 cf       	rjmp	.-14     	; 0x34a2 <vLs020Rectangle+0x58>
    			for (char x = x1; x <= x2; x++)
    				vLs020WriteData16(color);
			break;
		
		}
  	vLs020Mode8bit(0);
    34b0:	0e 94 ff 13 	call	0x27fe	; 0x27fe <vLs020Mode8bit.clone.0>
}
    34b4:	1f 91       	pop	r17
    34b6:	0f 91       	pop	r16
    34b8:	ff 90       	pop	r15
    34ba:	ef 90       	pop	r14
    34bc:	df 90       	pop	r13
    34be:	cf 90       	pop	r12
    34c0:	bf 90       	pop	r11
    34c2:	af 90       	pop	r10
    34c4:	08 95       	ret

000034c6 <vLs020StatusBar>:
*/
//  :
//	vLs020StatusBar(10, 10, 102, 12, black, green, black, 16, 1, 0, 99);

void vLs020StatusBar(uint8_t start_pos_x,uint8_t start_pos_y,uint8_t width,uint8_t high, int color_border, int color_fon, int color_text, uint8_t bits_color, uint8_t rot, uint8_t old_status, uint8_t new_status)
{
    34c6:	2f 92       	push	r2
    34c8:	3f 92       	push	r3
    34ca:	4f 92       	push	r4
    34cc:	5f 92       	push	r5
    34ce:	6f 92       	push	r6
    34d0:	7f 92       	push	r7
    34d2:	8f 92       	push	r8
    34d4:	9f 92       	push	r9
    34d6:	af 92       	push	r10
    34d8:	bf 92       	push	r11
    34da:	cf 92       	push	r12
    34dc:	df 92       	push	r13
    34de:	ef 92       	push	r14
    34e0:	ff 92       	push	r15
    34e2:	0f 93       	push	r16
    34e4:	1f 93       	push	r17
    34e6:	df 93       	push	r29
    34e8:	cf 93       	push	r28
    34ea:	cd b7       	in	r28, 0x3d	; 61
    34ec:	de b7       	in	r29, 0x3e	; 62
    34ee:	2c 97       	sbiw	r28, 0x0c	; 12
    34f0:	0f b6       	in	r0, 0x3f	; 63
    34f2:	f8 94       	cli
    34f4:	de bf       	out	0x3e, r29	; 62
    34f6:	0f be       	out	0x3f, r0	; 63
    34f8:	cd bf       	out	0x3d, r28	; 61
    34fa:	58 2e       	mov	r5, r24
    34fc:	b6 2e       	mov	r11, r22
    34fe:	44 2e       	mov	r4, r20
    3500:	92 2e       	mov	r9, r18
    3502:	1b 87       	std	Y+11, r17	; 0x0b
    3504:	0a 87       	std	Y+10, r16	; 0x0a
    3506:	37 01       	movw	r6, r14
    3508:	16 01       	movw	r2, r12
	unsigned char Xstolb; 					//     
	unsigned char Xpercent,Xpercent_ostat; 	//       

	char Data [] = "AAA";					//    
    350a:	80 91 02 02 	lds	r24, 0x0202
    350e:	90 91 03 02 	lds	r25, 0x0203
    3512:	a0 91 04 02 	lds	r26, 0x0204
    3516:	b0 91 05 02 	lds	r27, 0x0205
    351a:	89 83       	std	Y+1, r24	; 0x01
    351c:	9a 83       	std	Y+2, r25	; 0x02
    351e:	ab 83       	std	Y+3, r26	; 0x03
    3520:	bc 83       	std	Y+4, r27	; 0x04

	Xstolb = width - 2; 					//   	
    3522:	84 2f       	mov	r24, r20
    3524:	82 50       	subi	r24, 0x02	; 2
	Xpercent = Xstolb/100;
    3526:	64 e6       	ldi	r22, 0x64	; 100
    3528:	0e 94 03 1f 	call	0x3e06	; 0x3e06 <__udivmodqi4>

//	itoa(Xpercent_ostat,Data,10);						//    
//	vLs020PutString6x8(140, 10 , Data, 0xAAAA, 0x0000, 16, 0);
	

	uint8_t X_start =  start_pos_x + 1 + Xpercent*old_status;
    352c:	25 2d       	mov	r18, r5
    352e:	2f 5f       	subi	r18, 0xFF	; 255
    3530:	29 87       	std	Y+9, r18	; 0x09
    3532:	fa a0       	ldd	r15, Y+34	; 0x22
    3534:	f8 9e       	mul	r15, r24
    3536:	f0 2c       	mov	r15, r0
    3538:	11 24       	eor	r1, r1
    353a:	f2 0e       	add	r15, r18
	uint8_t X_stop  =  start_pos_x + width - 1 - Xpercent*(100 - new_status)- Xpercent_ostat*(100 - new_status)/100 ;	
    353c:	e4 2e       	mov	r14, r20
    353e:	e5 0c       	add	r14, r5
    3540:	0b a1       	ldd	r16, Y+35	; 0x23
    3542:	10 e0       	ldi	r17, 0x00	; 0
    3544:	ce 2c       	mov	r12, r14
    3546:	ca 94       	dec	r12
    3548:	98 01       	movw	r18, r16
    354a:	24 56       	subi	r18, 0x64	; 100
    354c:	30 40       	sbci	r19, 0x00	; 0
    354e:	82 9f       	mul	r24, r18
    3550:	e0 2d       	mov	r30, r0
    3552:	11 24       	eor	r1, r1
    3554:	ec 0d       	add	r30, r12
    3556:	24 e6       	ldi	r18, 0x64	; 100
    3558:	30 e0       	ldi	r19, 0x00	; 0
    355a:	20 1b       	sub	r18, r16
    355c:	31 0b       	sbc	r19, r17
    355e:	49 2f       	mov	r20, r25
    3560:	50 e0       	ldi	r21, 0x00	; 0
    3562:	24 9f       	mul	r18, r20
    3564:	c0 01       	movw	r24, r0
    3566:	25 9f       	mul	r18, r21
    3568:	90 0d       	add	r25, r0
    356a:	34 9f       	mul	r19, r20
    356c:	90 0d       	add	r25, r0
    356e:	11 24       	eor	r1, r1
    3570:	6c e9       	ldi	r22, 0x9C	; 156
    3572:	7f ef       	ldi	r23, 0xFF	; 255
    3574:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <__divmodhi4>
    3578:	e6 0f       	add	r30, r22
//	itoa(X_start,Data,10);					//    
//	vLs020PutString6x8(100, 10 , Data, 0xAAAA, 0x0000, 16, 0);
//	itoa(X_stop,Data,10);					//    
//	vLs020PutString6x8(110, 10 , Data, 0xAAAA, 0x0000, 16, 0);

	if (X_stop > (start_pos_x + width - 1)) X_stop = start_pos_x + width - 1;
    357a:	84 2d       	mov	r24, r4
    357c:	90 e0       	ldi	r25, 0x00	; 0
    357e:	98 87       	std	Y+8, r25	; 0x08
    3580:	8f 83       	std	Y+7, r24	; 0x07
    3582:	85 0d       	add	r24, r5
    3584:	91 1d       	adc	r25, r1
    3586:	9e 83       	std	Y+6, r25	; 0x06
    3588:	8d 83       	std	Y+5, r24	; 0x05
    358a:	8e 2f       	mov	r24, r30
    358c:	90 e0       	ldi	r25, 0x00	; 0
    358e:	2d 81       	ldd	r18, Y+5	; 0x05
    3590:	3e 81       	ldd	r19, Y+6	; 0x06
    3592:	82 17       	cp	r24, r18
    3594:	93 07       	cpc	r25, r19
    3596:	0c f4       	brge	.+2      	; 0x359a <vLs020StatusBar+0xd4>
//	itoa(Xpercent_ostat,Data,10);						//    
//	vLs020PutString6x8(140, 10 , Data, 0xAAAA, 0x0000, 16, 0);
	

	uint8_t X_start =  start_pos_x + 1 + Xpercent*old_status;
	uint8_t X_stop  =  start_pos_x + width - 1 - Xpercent*(100 - new_status)- Xpercent_ostat*(100 - new_status)/100 ;	
    3598:	ce 2e       	mov	r12, r30
	if (X_stop > (start_pos_x + width - 1)) X_stop = start_pos_x + width - 1;

//	itoa(X_stop,Data,10);					//    
//	vLs020PutString6x8(120, 10 , Data, 0xAAAA, 0x0000, 16, 0);

	itoa(new_status,Data,10);
    359a:	c8 01       	movw	r24, r16
    359c:	be 01       	movw	r22, r28
    359e:	6f 5f       	subi	r22, 0xFF	; 255
    35a0:	7f 4f       	sbci	r23, 0xFF	; 255
    35a2:	4a e0       	ldi	r20, 0x0A	; 10
    35a4:	50 e0       	ldi	r21, 0x00	; 0
    35a6:	0e 94 5f 1f 	call	0x3ebe	; 0x3ebe <itoa>
	
	if (rot == 0)
    35aa:	88 20       	and	r8, r8
    35ac:	09 f0       	breq	.+2      	; 0x35b0 <vLs020StatusBar+0xea>
    35ae:	5e c0       	rjmp	.+188    	; 0x366c <vLs020StatusBar+0x1a6>
		{
		//    -  
		vLs020DrawSquare(start_pos_x, start_pos_y, start_pos_x + width, start_pos_y + high, color_border, bits_color);	
    35b0:	d9 2c       	mov	r13, r9
    35b2:	db 0c       	add	r13, r11
    35b4:	85 2d       	mov	r24, r5
    35b6:	6b 2d       	mov	r22, r11
    35b8:	4e 2d       	mov	r20, r14
    35ba:	2d 2d       	mov	r18, r13
    35bc:	0a 85       	ldd	r16, Y+10	; 0x0a
    35be:	1b 85       	ldd	r17, Y+11	; 0x0b
    35c0:	ea 2c       	mov	r14, r10
    35c2:	0e 94 4b 15 	call	0x2a96	; 0x2a96 <vLs020DrawSquare>
		
		for (uint8_t i = X_start; i <= X_stop; i++ )
			vLs020LineVertical(start_pos_y + 1, start_pos_y + high - 1, i, color_fon, bits_color);	
    35c6:	5b 2c       	mov	r5, r11
    35c8:	53 94       	inc	r5
    35ca:	da 94       	dec	r13
	if (rot == 0)
		{
		//    -  
		vLs020DrawSquare(start_pos_x, start_pos_y, start_pos_x + width, start_pos_y + high, color_border, bits_color);	
		
		for (uint8_t i = X_start; i <= X_stop; i++ )
    35cc:	08 c0       	rjmp	.+16     	; 0x35de <vLs020StatusBar+0x118>
			vLs020LineVertical(start_pos_y + 1, start_pos_y + high - 1, i, color_fon, bits_color);	
    35ce:	85 2d       	mov	r24, r5
    35d0:	6d 2d       	mov	r22, r13
    35d2:	4f 2d       	mov	r20, r15
    35d4:	93 01       	movw	r18, r6
    35d6:	0a 2d       	mov	r16, r10
    35d8:	0e 94 ac 14 	call	0x2958	; 0x2958 <vLs020LineVertical>
	if (rot == 0)
		{
		//    -  
		vLs020DrawSquare(start_pos_x, start_pos_y, start_pos_x + width, start_pos_y + high, color_border, bits_color);	
		
		for (uint8_t i = X_start; i <= X_stop; i++ )
    35dc:	f3 94       	inc	r15
    35de:	cf 14       	cp	r12, r15
    35e0:	b0 f7       	brcc	.-20     	; 0x35ce <vLs020StatusBar+0x108>
			vLs020LineVertical(start_pos_y + 1, start_pos_y + high - 1, i, color_fon, bits_color);	

		//   		
		if (high >=16)
    35e2:	39 2d       	mov	r19, r9
    35e4:	30 31       	cpi	r19, 0x10	; 16
    35e6:	f8 f0       	brcs	.+62     	; 0x3626 <vLs020StatusBar+0x160>
			{
			
			#if (Include8x14Font == 1)

			vLs020PutString8x14((start_pos_x + width) / 2 - 8, start_pos_y + (high + 14) / 2, Data, color_text, color_fon, bits_color, 5);		
    35e8:	8d 81       	ldd	r24, Y+5	; 0x05
    35ea:	9e 81       	ldd	r25, Y+6	; 0x06
    35ec:	95 95       	asr	r25
    35ee:	87 95       	ror	r24
    35f0:	98 2f       	mov	r25, r24
    35f2:	29 2d       	mov	r18, r9
    35f4:	30 e0       	ldi	r19, 0x00	; 0
    35f6:	22 5f       	subi	r18, 0xF2	; 242
    35f8:	3f 4f       	sbci	r19, 0xFF	; 255
    35fa:	35 95       	asr	r19
    35fc:	27 95       	ror	r18
    35fe:	fb 2c       	mov	r15, r11
    3600:	f2 0e       	add	r15, r18
    3602:	88 50       	subi	r24, 0x08	; 8
    3604:	6f 2d       	mov	r22, r15
    3606:	ae 01       	movw	r20, r28
    3608:	4f 5f       	subi	r20, 0xFF	; 255
    360a:	5f 4f       	sbci	r21, 0xFF	; 255
    360c:	91 01       	movw	r18, r2
    360e:	83 01       	movw	r16, r6
    3610:	ea 2c       	mov	r14, r10
    3612:	a5 e0       	ldi	r26, 0x05	; 5
    3614:	ca 2e       	mov	r12, r26
    3616:	9c 87       	std	Y+12, r25	; 0x0c
    3618:	0e 94 47 19 	call	0x328e	; 0x328e <vLs020PutString8x14>
			vLs020PutChar8x14((start_pos_x + width) / 2 - 8 + 24, start_pos_y + (high + 14) / 2, '%', color_text, color_fon, bits_color, 5);
    361c:	9c 85       	ldd	r25, Y+12	; 0x0c
    361e:	89 2f       	mov	r24, r25
    3620:	80 5f       	subi	r24, 0xF0	; 240
    3622:	6f 2d       	mov	r22, r15
    3624:	61 c0       	rjmp	.+194    	; 0x36e8 <vLs020StatusBar+0x222>
			
			#endif			
			}

			else if (high >=8)
    3626:	89 2d       	mov	r24, r9
    3628:	88 30       	cpi	r24, 0x08	; 8
    362a:	08 f4       	brcc	.+2      	; 0x362e <vLs020StatusBar+0x168>
    362c:	87 c0       	rjmp	.+270    	; 0x373c <vLs020StatusBar+0x276>
				{
				#if (Include6x8Font == 1)

				vLs020PutString6x8((start_pos_x + width) / 2 - 6, start_pos_y + (high + 8) / 2, Data, color_text, color_fon, bits_color, 5);		
    362e:	8d 81       	ldd	r24, Y+5	; 0x05
    3630:	9e 81       	ldd	r25, Y+6	; 0x06
    3632:	95 95       	asr	r25
    3634:	87 95       	ror	r24
    3636:	98 2f       	mov	r25, r24
    3638:	29 2d       	mov	r18, r9
    363a:	30 e0       	ldi	r19, 0x00	; 0
    363c:	28 5f       	subi	r18, 0xF8	; 248
    363e:	3f 4f       	sbci	r19, 0xFF	; 255
    3640:	35 95       	asr	r19
    3642:	27 95       	ror	r18
    3644:	fb 2c       	mov	r15, r11
    3646:	f2 0e       	add	r15, r18
    3648:	86 50       	subi	r24, 0x06	; 6
    364a:	6f 2d       	mov	r22, r15
    364c:	ae 01       	movw	r20, r28
    364e:	4f 5f       	subi	r20, 0xFF	; 255
    3650:	5f 4f       	sbci	r21, 0xFF	; 255
    3652:	91 01       	movw	r18, r2
    3654:	83 01       	movw	r16, r6
    3656:	ea 2c       	mov	r14, r10
    3658:	75 e0       	ldi	r23, 0x05	; 5
    365a:	c7 2e       	mov	r12, r23
    365c:	9c 87       	std	Y+12, r25	; 0x0c
    365e:	0e 94 69 18 	call	0x30d2	; 0x30d2 <vLs020PutString6x8>
				vLs020PutChar6x8((start_pos_x + width) / 2 - 6 + 18, start_pos_y + (high + 8) / 2, '%', color_text, color_fon, bits_color, 5);
    3662:	9c 85       	ldd	r25, Y+12	; 0x0c
    3664:	89 2f       	mov	r24, r25
    3666:	84 5f       	subi	r24, 0xF4	; 244
    3668:	6f 2d       	mov	r22, r15
    366a:	64 c0       	rjmp	.+200    	; 0x3734 <vLs020StatusBar+0x26e>

				#endif
				}
		}	

	if (rot == 1)
    366c:	98 2d       	mov	r25, r8
    366e:	91 30       	cpi	r25, 0x01	; 1
    3670:	09 f0       	breq	.+2      	; 0x3674 <vLs020StatusBar+0x1ae>
    3672:	64 c0       	rjmp	.+200    	; 0x373c <vLs020StatusBar+0x276>
		{
		
		//    -  		
		vLs020DrawSquare(start_pos_x, start_pos_y, start_pos_x + high, start_pos_y + width, color_border, bits_color);
    3674:	d9 2c       	mov	r13, r9
    3676:	d5 0c       	add	r13, r5
    3678:	24 2d       	mov	r18, r4
    367a:	2b 0d       	add	r18, r11
    367c:	85 2d       	mov	r24, r5
    367e:	6b 2d       	mov	r22, r11
    3680:	4d 2d       	mov	r20, r13
    3682:	0a 85       	ldd	r16, Y+10	; 0x0a
    3684:	1b 85       	ldd	r17, Y+11	; 0x0b
    3686:	ea 2c       	mov	r14, r10
    3688:	0e 94 4b 15 	call	0x2a96	; 0x2a96 <vLs020DrawSquare>
		
		//  
		for (char i = X_start; i <= X_stop; i++ )
			vLs020LineHorizontal(start_pos_x + 1, start_pos_x + high - 1, i, color_fon, bits_color);
    368c:	da 94       	dec	r13
		
		//    -  		
		vLs020DrawSquare(start_pos_x, start_pos_y, start_pos_x + high, start_pos_y + width, color_border, bits_color);
		
		//  
		for (char i = X_start; i <= X_stop; i++ )
    368e:	08 c0       	rjmp	.+16     	; 0x36a0 <vLs020StatusBar+0x1da>
			vLs020LineHorizontal(start_pos_x + 1, start_pos_x + high - 1, i, color_fon, bits_color);
    3690:	89 85       	ldd	r24, Y+9	; 0x09
    3692:	6d 2d       	mov	r22, r13
    3694:	4f 2d       	mov	r20, r15
    3696:	93 01       	movw	r18, r6
    3698:	0a 2d       	mov	r16, r10
    369a:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <vLs020LineHorizontal>
		
		//    -  		
		vLs020DrawSquare(start_pos_x, start_pos_y, start_pos_x + high, start_pos_y + width, color_border, bits_color);
		
		//  
		for (char i = X_start; i <= X_stop; i++ )
    369e:	f3 94       	inc	r15
    36a0:	cf 14       	cp	r12, r15
    36a2:	b0 f7       	brcc	.-20     	; 0x3690 <vLs020StatusBar+0x1ca>
			vLs020LineHorizontal(start_pos_x + 1, start_pos_x + high - 1, i, color_fon, bits_color);
					
		//   
		if (high >=16)
    36a4:	29 2d       	mov	r18, r9
    36a6:	20 31       	cpi	r18, 0x10	; 16
    36a8:	20 f1       	brcs	.+72     	; 0x36f2 <vLs020StatusBar+0x22c>
			{
			#if (Include8x14Font == 1)

			vLs020PutString8x14( start_pos_x + (high - 14) / 2,(start_pos_y + width) / 2 - 8, Data, color_text, color_fon, bits_color, 0);
    36aa:	89 2d       	mov	r24, r9
    36ac:	90 e0       	ldi	r25, 0x00	; 0
    36ae:	0e 97       	sbiw	r24, 0x0e	; 14
    36b0:	95 95       	asr	r25
    36b2:	87 95       	ror	r24
    36b4:	98 2e       	mov	r9, r24
    36b6:	6f 81       	ldd	r22, Y+7	; 0x07
    36b8:	78 85       	ldd	r23, Y+8	; 0x08
    36ba:	6b 0d       	add	r22, r11
    36bc:	71 1d       	adc	r23, r1
    36be:	75 95       	asr	r23
    36c0:	67 95       	ror	r22
    36c2:	68 50       	subi	r22, 0x08	; 8
    36c4:	89 2d       	mov	r24, r9
    36c6:	85 0d       	add	r24, r5
    36c8:	ae 01       	movw	r20, r28
    36ca:	4f 5f       	subi	r20, 0xFF	; 255
    36cc:	5f 4f       	sbci	r21, 0xFF	; 255
    36ce:	91 01       	movw	r18, r2
    36d0:	83 01       	movw	r16, r6
    36d2:	ea 2c       	mov	r14, r10
    36d4:	cc 24       	eor	r12, r12
    36d6:	0e 94 47 19 	call	0x328e	; 0x328e <vLs020PutString8x14>
			vLs020PutChar8x14( start_pos_y + (high - 14) / 2,(start_pos_x + width) / 2 - 8 + 24, '%', color_text, color_fon, bits_color, 0);
    36da:	6d 81       	ldd	r22, Y+5	; 0x05
    36dc:	7e 81       	ldd	r23, Y+6	; 0x06
    36de:	75 95       	asr	r23
    36e0:	67 95       	ror	r22
    36e2:	60 5f       	subi	r22, 0xF0	; 240
    36e4:	89 2d       	mov	r24, r9
    36e6:	8b 0d       	add	r24, r11
    36e8:	45 e2       	ldi	r20, 0x25	; 37
    36ea:	91 01       	movw	r18, r2
    36ec:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <vLs020PutChar8x14>
    36f0:	25 c0       	rjmp	.+74     	; 0x373c <vLs020StatusBar+0x276>
			
			#endif			
			}
			else if (high >=8)			
    36f2:	39 2d       	mov	r19, r9
    36f4:	38 30       	cpi	r19, 0x08	; 8
    36f6:	10 f1       	brcs	.+68     	; 0x373c <vLs020StatusBar+0x276>
				{
				#if (Include6x8Font == 1)

				vLs020PutString6x8( start_pos_x + (high - 8) / 2,(start_pos_y + width) / 2 - 6, Data, color_text, color_fon, bits_color, 0);
    36f8:	89 2d       	mov	r24, r9
    36fa:	90 e0       	ldi	r25, 0x00	; 0
    36fc:	08 97       	sbiw	r24, 0x08	; 8
    36fe:	95 95       	asr	r25
    3700:	87 95       	ror	r24
    3702:	98 2e       	mov	r9, r24
    3704:	6f 81       	ldd	r22, Y+7	; 0x07
    3706:	78 85       	ldd	r23, Y+8	; 0x08
    3708:	6b 0d       	add	r22, r11
    370a:	71 1d       	adc	r23, r1
    370c:	75 95       	asr	r23
    370e:	67 95       	ror	r22
    3710:	66 50       	subi	r22, 0x06	; 6
    3712:	85 0d       	add	r24, r5
    3714:	ae 01       	movw	r20, r28
    3716:	4f 5f       	subi	r20, 0xFF	; 255
    3718:	5f 4f       	sbci	r21, 0xFF	; 255
    371a:	91 01       	movw	r18, r2
    371c:	83 01       	movw	r16, r6
    371e:	ea 2c       	mov	r14, r10
    3720:	cc 24       	eor	r12, r12
    3722:	0e 94 69 18 	call	0x30d2	; 0x30d2 <vLs020PutString6x8>
				vLs020PutChar6x8( start_pos_y + (high - 8) / 2, (start_pos_x + width) / 2 - 6 + 18, '%', color_text, color_fon, bits_color, 0);
    3726:	6d 81       	ldd	r22, Y+5	; 0x05
    3728:	7e 81       	ldd	r23, Y+6	; 0x06
    372a:	75 95       	asr	r23
    372c:	67 95       	ror	r22
    372e:	64 5f       	subi	r22, 0xF4	; 244
    3730:	89 2d       	mov	r24, r9
    3732:	8b 0d       	add	r24, r11
    3734:	45 e2       	ldi	r20, 0x25	; 37
    3736:	91 01       	movw	r18, r2
    3738:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vLs020PutChar6x8>
				#endif
				}
		}	


}
    373c:	2c 96       	adiw	r28, 0x0c	; 12
    373e:	0f b6       	in	r0, 0x3f	; 63
    3740:	f8 94       	cli
    3742:	de bf       	out	0x3e, r29	; 62
    3744:	0f be       	out	0x3f, r0	; 63
    3746:	cd bf       	out	0x3d, r28	; 61
    3748:	cf 91       	pop	r28
    374a:	df 91       	pop	r29
    374c:	1f 91       	pop	r17
    374e:	0f 91       	pop	r16
    3750:	ff 90       	pop	r15
    3752:	ef 90       	pop	r14
    3754:	df 90       	pop	r13
    3756:	cf 90       	pop	r12
    3758:	bf 90       	pop	r11
    375a:	af 90       	pop	r10
    375c:	9f 90       	pop	r9
    375e:	8f 90       	pop	r8
    3760:	7f 90       	pop	r7
    3762:	6f 90       	pop	r6
    3764:	5f 90       	pop	r5
    3766:	4f 90       	pop	r4
    3768:	3f 90       	pop	r3
    376a:	2f 90       	pop	r2
    376c:	08 95       	ret

0000376e <__vector_21>:
int dots = 0x00;


//------------------------------------------------------------------------------------------------------
ISR(TIMER0_COMPA_vect)
{
    376e:	1f 92       	push	r1
    3770:	0f 92       	push	r0
    3772:	0f b6       	in	r0, 0x3f	; 63
    3774:	0f 92       	push	r0
    3776:	11 24       	eor	r1, r1
    3778:	2f 93       	push	r18
    377a:	8f 93       	push	r24
    377c:	9f 93       	push	r25
    377e:	af 93       	push	r26
    3780:	bf 93       	push	r27
	if(++ms_count == 1000)
    3782:	80 91 34 03 	lds	r24, 0x0334
    3786:	90 91 35 03 	lds	r25, 0x0335
    378a:	01 96       	adiw	r24, 0x01	; 1
    378c:	90 93 35 03 	sts	0x0335, r25
    3790:	80 93 34 03 	sts	0x0334, r24
    3794:	80 91 34 03 	lds	r24, 0x0334
    3798:	90 91 35 03 	lds	r25, 0x0335
    379c:	23 e0       	ldi	r18, 0x03	; 3
    379e:	88 3e       	cpi	r24, 0xE8	; 232
    37a0:	92 07       	cpc	r25, r18
    37a2:	d9 f4       	brne	.+54     	; 0x37da <__vector_21+0x6c>
	{
		++second_count;
    37a4:	80 91 28 03 	lds	r24, 0x0328
    37a8:	90 91 29 03 	lds	r25, 0x0329
    37ac:	a0 91 2a 03 	lds	r26, 0x032A
    37b0:	b0 91 2b 03 	lds	r27, 0x032B
    37b4:	01 96       	adiw	r24, 0x01	; 1
    37b6:	a1 1d       	adc	r26, r1
    37b8:	b1 1d       	adc	r27, r1
    37ba:	80 93 28 03 	sts	0x0328, r24
    37be:	90 93 29 03 	sts	0x0329, r25
    37c2:	a0 93 2a 03 	sts	0x032A, r26
    37c6:	b0 93 2b 03 	sts	0x032B, r27
		ms_count = 0;
    37ca:	10 92 35 03 	sts	0x0335, r1
    37ce:	10 92 34 03 	sts	0x0334, r1
		PORTG = PORTG ^ 0x02;
    37d2:	84 b3       	in	r24, 0x14	; 20
    37d4:	92 e0       	ldi	r25, 0x02	; 2
    37d6:	89 27       	eor	r24, r25
    37d8:	84 bb       	out	0x14, r24	; 20
	}
}
    37da:	bf 91       	pop	r27
    37dc:	af 91       	pop	r26
    37de:	9f 91       	pop	r25
    37e0:	8f 91       	pop	r24
    37e2:	2f 91       	pop	r18
    37e4:	0f 90       	pop	r0
    37e6:	0f be       	out	0x3f, r0	; 63
    37e8:	0f 90       	pop	r0
    37ea:	1f 90       	pop	r1
    37ec:	18 95       	reti

000037ee <__vector_29>:
void vApplicationIdleHook(){
}


SIGNAL(SIG_ADC)
{	
    37ee:	1f 92       	push	r1
    37f0:	0f 92       	push	r0
    37f2:	0f b6       	in	r0, 0x3f	; 63
    37f4:	0f 92       	push	r0
    37f6:	11 24       	eor	r1, r1
    37f8:	8f 93       	push	r24
//	SendToUart0(ADCH);
	ADC_Hlobal = ADCH;
    37fa:	80 91 79 00 	lds	r24, 0x0079
    37fe:	80 93 20 06 	sts	0x0620, r24
//	char str[3] = "000";
//	itoa(ADCH,str,10);

*/

}
    3802:	8f 91       	pop	r24
    3804:	0f 90       	pop	r0
    3806:	0f be       	out	0x3f, r0	; 63
    3808:	0f 90       	pop	r0
    380a:	1f 90       	pop	r1
    380c:	18 95       	reti

0000380e <udp_packet>:
{
	ip_packet_t *ip = (void*)(frame->data);
	udp_packet_t *udp = (void*)(ip->data);
	uint32_t timestamp;

	if(udp->to_port == NTP_LOCAL_PORT)
    380e:	fc 01       	movw	r30, r24
    3810:	24 a1       	ldd	r18, Z+36	; 0x24
    3812:	35 a1       	ldd	r19, Z+37	; 0x25
    3814:	fc e6       	ldi	r31, 0x6C	; 108
    3816:	28 33       	cpi	r18, 0x38	; 56
    3818:	3f 07       	cpc	r19, r31
    381a:	81 f5       	brne	.+96     	; 0x387c <udp_packet+0x6e>
	{
		if((timestamp = ntp_parse_reply(udp->data, len)))
    381c:	8a 96       	adiw	r24, 0x2a	; 42
    381e:	0e 94 d0 0b 	call	0x17a0	; 0x17a0 <ntp_parse_reply>
    3822:	61 15       	cp	r22, r1
    3824:	71 05       	cpc	r23, r1
    3826:	81 05       	cpc	r24, r1
    3828:	91 05       	cpc	r25, r1
    382a:	41 f1       	breq	.+80     	; 0x387c <udp_packet+0x6e>
		{
			time_offset = timestamp - second_count;
    382c:	20 91 28 03 	lds	r18, 0x0328
    3830:	30 91 29 03 	lds	r19, 0x0329
    3834:	40 91 2a 03 	lds	r20, 0x032A
    3838:	50 91 2b 03 	lds	r21, 0x032B
    383c:	62 1b       	sub	r22, r18
    383e:	73 0b       	sbc	r23, r19
    3840:	84 0b       	sbc	r24, r20
    3842:	95 0b       	sbc	r25, r21
    3844:	60 93 30 03 	sts	0x0330, r22
    3848:	70 93 31 03 	sts	0x0331, r23
    384c:	80 93 32 03 	sts	0x0332, r24
    3850:	90 93 33 03 	sts	0x0333, r25
			ntp_next_update = second_count + 12UL*60*60;
    3854:	80 91 28 03 	lds	r24, 0x0328
    3858:	90 91 29 03 	lds	r25, 0x0329
    385c:	a0 91 2a 03 	lds	r26, 0x032A
    3860:	b0 91 2b 03 	lds	r27, 0x032B
    3864:	80 54       	subi	r24, 0x40	; 64
    3866:	97 45       	sbci	r25, 0x57	; 87
    3868:	af 4f       	sbci	r26, 0xFF	; 255
    386a:	bf 4f       	sbci	r27, 0xFF	; 255
    386c:	80 93 2c 03 	sts	0x032C, r24
    3870:	90 93 2d 03 	sts	0x032D, r25
    3874:	a0 93 2e 03 	sts	0x032E, r26
    3878:	b0 93 2f 03 	sts	0x032F, r27
    387c:	08 95       	ret

0000387e <InitHardware>:



//------------------------------------  ---------------------------------------------
void InitHardware(void)
{
    387e:	9f 92       	push	r9
    3880:	af 92       	push	r10
    3882:	bf 92       	push	r11
    3884:	cf 92       	push	r12
    3886:	df 92       	push	r13
    3888:	ef 92       	push	r14
    388a:	ff 92       	push	r15
    388c:	0f 93       	push	r16
    388e:	1f 93       	push	r17
    3890:	df 93       	push	r29
    3892:	cf 93       	push	r28
    3894:	cd b7       	in	r28, 0x3d	; 61
    3896:	de b7       	in	r29, 0x3e	; 62
    3898:	e2 97       	sbiw	r28, 0x32	; 50
    389a:	0f b6       	in	r0, 0x3f	; 63
    389c:	f8 94       	cli
    389e:	de bf       	out	0x3e, r29	; 62
    38a0:	0f be       	out	0x3f, r0	; 63
    38a2:	cd bf       	out	0x3d, r28	; 61

	DDRC = 0x00;
    38a4:	17 b8       	out	0x07, r1	; 7
	PORTC = 0xFF;
    38a6:	8f ef       	ldi	r24, 0xFF	; 255
    38a8:	88 b9       	out	0x08, r24	; 8

	DDRD = 0x00;
    38aa:	1a b8       	out	0x0a, r1	; 10
	PORTD = 0xFF;
    38ac:	8b b9       	out	0x0b, r24	; 11

	DDRE |= ((1<<PINE3) | (1<<DDE4));
    38ae:	9d b1       	in	r25, 0x0d	; 13
    38b0:	98 61       	ori	r25, 0x18	; 24
    38b2:	9d b9       	out	0x0d, r25	; 13
	DDRG |= 1<<PG1;
    38b4:	99 9a       	sbi	0x13, 1	; 19
	DDRB = 0xFF;
    38b6:	84 b9       	out	0x04, r24	; 4
    38b8:	2f ef       	ldi	r18, 0xFF	; 255
    38ba:	3e e9       	ldi	r19, 0x9E	; 158
    38bc:	44 e2       	ldi	r20, 0x24	; 36
    38be:	21 50       	subi	r18, 0x01	; 1
    38c0:	30 40       	sbci	r19, 0x00	; 0
    38c2:	40 40       	sbci	r20, 0x00	; 0
    38c4:	e1 f7       	brne	.-8      	; 0x38be <InitHardware+0x40>
    38c6:	00 c0       	rjmp	.+0      	; 0x38c8 <InitHardware+0x4a>
    38c8:	00 00       	nop

	while(1)
	{
		_delay_ms(1000);
		PORTB = 0x00;
    38ca:	15 b8       	out	0x05, r1	; 5
		PORTG = 0x00;
    38cc:	14 ba       	out	0x14, r1	; 20
		PORTE = 0x00;
    38ce:	1e b8       	out	0x0e, r1	; 14
    38d0:	8f ef       	ldi	r24, 0xFF	; 255
    38d2:	9e e9       	ldi	r25, 0x9E	; 158
    38d4:	a4 e2       	ldi	r26, 0x24	; 36
    38d6:	81 50       	subi	r24, 0x01	; 1
    38d8:	90 40       	sbci	r25, 0x00	; 0
    38da:	a0 40       	sbci	r26, 0x00	; 0
    38dc:	e1 f7       	brne	.-8      	; 0x38d6 <InitHardware+0x58>
    38de:	00 c0       	rjmp	.+0      	; 0x38e0 <InitHardware+0x62>
    38e0:	00 00       	nop

		_delay_ms(1000);
		PORTE = PORTE ^ (1<<DDE3);
    38e2:	8e b1       	in	r24, 0x0e	; 14
    38e4:	98 e0       	ldi	r25, 0x08	; 8
    38e6:	89 27       	eor	r24, r25
    38e8:	8e b9       	out	0x0e, r24	; 14
		PORTE = PORTE ^ (1<<DDE4);
    38ea:	8e b1       	in	r24, 0x0e	; 14
    38ec:	90 e1       	ldi	r25, 0x10	; 16
    38ee:	89 27       	eor	r24, r25
    38f0:	8e b9       	out	0x0e, r24	; 14
		PORTG = PORTG ^ (1<<DDG1);
    38f2:	84 b3       	in	r24, 0x14	; 20
    38f4:	92 e0       	ldi	r25, 0x02	; 2
    38f6:	89 27       	eor	r24, r25
    38f8:	84 bb       	out	0x14, r24	; 20
    38fa:	2f ef       	ldi	r18, 0xFF	; 255
    38fc:	3e e9       	ldi	r19, 0x9E	; 158
    38fe:	44 e2       	ldi	r20, 0x24	; 36
    3900:	21 50       	subi	r18, 0x01	; 1
    3902:	30 40       	sbci	r19, 0x00	; 0
    3904:	40 40       	sbci	r20, 0x00	; 0
    3906:	e1 f7       	brne	.-8      	; 0x3900 <InitHardware+0x82>
    3908:	00 c0       	rjmp	.+0      	; 0x390a <InitHardware+0x8c>
    390a:	00 00       	nop
		break;
	}

	_delay_ms(1000);
	PORTG = 0x00;
    390c:	14 ba       	out	0x14, r1	; 20
	PORTE = 0x00;
    390e:	1e b8       	out	0x0e, r1	; 14




// 	 0,1  C     //
	DDRE |= ((1<<DDE3) | (1<<DDE4));
    3910:	8d b1       	in	r24, 0x0d	; 13
    3912:	88 61       	ori	r24, 0x18	; 24
    3914:	8d b9       	out	0x0d, r24	; 13
	DDRG |= 1<<PG1;
    3916:	99 9a       	sbi	0x13, 1	; 19
	DDRG |= 1<<PING0;
    3918:	98 9a       	sbi	0x13, 0	; 19


	// init timer, freq = 1 kHz @ CLK = 16 MHz
	TCCR0A = (1<<WGM01);
    391a:	94 bd       	out	0x24, r25	; 36
	TCCR0B = (1<<CS01)|(1<<CS00);
    391c:	83 e0       	ldi	r24, 0x03	; 3
    391e:	85 bd       	out	0x25, r24	; 37
	OCR0A = 187;
    3920:	8b eb       	ldi	r24, 0xBB	; 187
    3922:	87 bd       	out	0x27, r24	; 39
	TIMSK0 |= (1<<OCIE0A);
    3924:	80 91 6e 00 	lds	r24, 0x006E
    3928:	82 60       	ori	r24, 0x02	; 2
    392a:	80 93 6e 00 	sts	0x006E, r24
	sei();
    392e:	78 94       	sei



	InitUART0(57600,8,1,0,0);		//  0
    3930:	80 e0       	ldi	r24, 0x00	; 0
    3932:	91 ee       	ldi	r25, 0xE1	; 225
    3934:	68 e0       	ldi	r22, 0x08	; 8
    3936:	41 e0       	ldi	r20, 0x01	; 1
    3938:	20 e0       	ldi	r18, 0x00	; 0
    393a:	00 e0       	ldi	r16, 0x00	; 0
    393c:	0e 94 26 0e 	call	0x1c4c	; 0x1c4c <InitUART0>
	SendToUart0('0');
    3940:	80 e3       	ldi	r24, 0x30	; 48
    3942:	0e 94 a2 11 	call	0x2344	; 0x2344 <SendToUart0>

	InitUART1(9600,8,1,0,0);		//  0
    3946:	80 e8       	ldi	r24, 0x80	; 128
    3948:	95 e2       	ldi	r25, 0x25	; 37
    394a:	68 e0       	ldi	r22, 0x08	; 8
    394c:	41 e0       	ldi	r20, 0x01	; 1
    394e:	20 e0       	ldi	r18, 0x00	; 0
    3950:	0e 94 05 0f 	call	0x1e0a	; 0x1e0a <InitUART1>
	SendToUart0('1');
    3954:	81 e3       	ldi	r24, 0x31	; 49
    3956:	0e 94 a2 11 	call	0x2344	; 0x2344 <SendToUart0>

	InitUART2(9600,8,1,0,0);		//  0
    395a:	80 e8       	ldi	r24, 0x80	; 128
    395c:	95 e2       	ldi	r25, 0x25	; 37
    395e:	68 e0       	ldi	r22, 0x08	; 8
    3960:	41 e0       	ldi	r20, 0x01	; 1
    3962:	20 e0       	ldi	r18, 0x00	; 0
    3964:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <InitUART2>
	SendToUart0('2');
    3968:	82 e3       	ldi	r24, 0x32	; 50
    396a:	0e 94 a2 11 	call	0x2344	; 0x2344 <SendToUart0>

	InitUART3(9600,8,1,0,0);		//  0
    396e:	80 e8       	ldi	r24, 0x80	; 128
    3970:	95 e2       	ldi	r25, 0x25	; 37
    3972:	68 e0       	ldi	r22, 0x08	; 8
    3974:	41 e0       	ldi	r20, 0x01	; 1
    3976:	20 e0       	ldi	r18, 0x00	; 0
    3978:	0e 94 c3 10 	call	0x2186	; 0x2186 <InitUART3>
	SendToUart0('3');
    397c:	83 e3       	ldi	r24, 0x33	; 51
    397e:	0e 94 a2 11 	call	0x2344	; 0x2344 <SendToUart0>

	vLcdInit(LS_ULINE);				//  
    3982:	82 e0       	ldi	r24, 0x02	; 2
    3984:	0e 94 f9 12 	call	0x25f2	; 0x25f2 <vLcdInit>
	SendToUart0('4');
    3988:	84 e3       	ldi	r24, 0x34	; 52
    398a:	0e 94 a2 11 	call	0x2344	; 0x2344 <SendToUart0>

	I2CInit(); 						//   I2C
    398e:	0e 94 37 13 	call	0x266e	; 0x266e <I2CInit>
	SendToUart0('5');
    3992:	85 e3       	ldi	r24, 0x35	; 53
    3994:	0e 94 a2 11 	call	0x2344	; 0x2344 <SendToUart0>

	InitADCEx();					//   
    3998:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <InitADCEx>
	SendToUart0('6');			
    399c:	86 e3       	ldi	r24, 0x36	; 54
    399e:	0e 94 a2 11 	call	0x2344	; 0x2344 <SendToUart0>

	transmitStringToUart(0,"\n");
    39a2:	80 e0       	ldi	r24, 0x00	; 0
    39a4:	90 e0       	ldi	r25, 0x00	; 0
    39a6:	66 e0       	ldi	r22, 0x06	; 6
    39a8:	72 e0       	ldi	r23, 0x02	; 2
    39aa:	0e 94 be 11 	call	0x237c	; 0x237c <transmitStringToUart>
	for (int i = 0; i < 8; i++ ){
    39ae:	00 e0       	ldi	r16, 0x00	; 0
    39b0:	10 e0       	ldi	r17, 0x00	; 0
		uint16_t res = ReadADCEx(i);
		char buff[50] = "";
    39b2:	2e e2       	ldi	r18, 0x2E	; 46
    39b4:	92 2e       	mov	r9, r18
    39b6:	95 e0       	ldi	r25, 0x05	; 5
    39b8:	c9 2e       	mov	r12, r25
    39ba:	d1 2c       	mov	r13, r1
    39bc:	cc 0e       	add	r12, r28
    39be:	dd 1e       	adc	r13, r29
		sprintf(buff, "ADC Data = %05d, channel = %d\n", res, i);
    39c0:	7e 01       	movw	r14, r28
    39c2:	08 94       	sec
    39c4:	e1 1c       	adc	r14, r1
    39c6:	f1 1c       	adc	r15, r1
    39c8:	88 e0       	ldi	r24, 0x08	; 8
    39ca:	a8 2e       	mov	r10, r24
    39cc:	82 e0       	ldi	r24, 0x02	; 2
    39ce:	b8 2e       	mov	r11, r24
	InitADCEx();					//   
	SendToUart0('6');			

	transmitStringToUart(0,"\n");
	for (int i = 0; i < 8; i++ ){
		uint16_t res = ReadADCEx(i);
    39d0:	80 2f       	mov	r24, r16
    39d2:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <ReadADCEx>
		char buff[50] = "";
    39d6:	19 82       	std	Y+1, r1	; 0x01
    39d8:	1a 82       	std	Y+2, r1	; 0x02
    39da:	1b 82       	std	Y+3, r1	; 0x03
    39dc:	1c 82       	std	Y+4, r1	; 0x04
    39de:	d6 01       	movw	r26, r12
    39e0:	e9 2d       	mov	r30, r9
    39e2:	1d 92       	st	X+, r1
    39e4:	ea 95       	dec	r30
    39e6:	e9 f7       	brne	.-6      	; 0x39e2 <InitHardware+0x164>
		sprintf(buff, "ADC Data = %05d, channel = %d\n", res, i);
    39e8:	2d b7       	in	r18, 0x3d	; 61
    39ea:	3e b7       	in	r19, 0x3e	; 62
    39ec:	28 50       	subi	r18, 0x08	; 8
    39ee:	30 40       	sbci	r19, 0x00	; 0
    39f0:	0f b6       	in	r0, 0x3f	; 63
    39f2:	f8 94       	cli
    39f4:	3e bf       	out	0x3e, r19	; 62
    39f6:	0f be       	out	0x3f, r0	; 63
    39f8:	2d bf       	out	0x3d, r18	; 61
    39fa:	ed b7       	in	r30, 0x3d	; 61
    39fc:	fe b7       	in	r31, 0x3e	; 62
    39fe:	31 96       	adiw	r30, 0x01	; 1
    3a00:	ad b7       	in	r26, 0x3d	; 61
    3a02:	be b7       	in	r27, 0x3e	; 62
    3a04:	12 96       	adiw	r26, 0x02	; 2
    3a06:	fc 92       	st	X, r15
    3a08:	ee 92       	st	-X, r14
    3a0a:	11 97       	sbiw	r26, 0x01	; 1
    3a0c:	b3 82       	std	Z+3, r11	; 0x03
    3a0e:	a2 82       	std	Z+2, r10	; 0x02
    3a10:	95 83       	std	Z+5, r25	; 0x05
    3a12:	84 83       	std	Z+4, r24	; 0x04
    3a14:	17 83       	std	Z+7, r17	; 0x07
    3a16:	06 83       	std	Z+6, r16	; 0x06
    3a18:	0e 94 80 1f 	call	0x3f00	; 0x3f00 <sprintf>

		transmitStringToUart(0, buff);
    3a1c:	ed b7       	in	r30, 0x3d	; 61
    3a1e:	fe b7       	in	r31, 0x3e	; 62
    3a20:	38 96       	adiw	r30, 0x08	; 8
    3a22:	0f b6       	in	r0, 0x3f	; 63
    3a24:	f8 94       	cli
    3a26:	fe bf       	out	0x3e, r31	; 62
    3a28:	0f be       	out	0x3f, r0	; 63
    3a2a:	ed bf       	out	0x3d, r30	; 61
    3a2c:	80 e0       	ldi	r24, 0x00	; 0
    3a2e:	90 e0       	ldi	r25, 0x00	; 0
    3a30:	b7 01       	movw	r22, r14
    3a32:	0e 94 be 11 	call	0x237c	; 0x237c <transmitStringToUart>

	InitADCEx();					//   
	SendToUart0('6');			

	transmitStringToUart(0,"\n");
	for (int i = 0; i < 8; i++ ){
    3a36:	0f 5f       	subi	r16, 0xFF	; 255
    3a38:	1f 4f       	sbci	r17, 0xFF	; 255
    3a3a:	08 30       	cpi	r16, 0x08	; 8
    3a3c:	11 05       	cpc	r17, r1
    3a3e:	41 f6       	brne	.-112    	; 0x39d0 <InitHardware+0x152>

		transmitStringToUart(0, buff);
	}

//	lan_init();						// Init LAN
	SendToUart0('7');
    3a40:	87 e3       	ldi	r24, 0x37	; 55
    3a42:	0e 94 a2 11 	call	0x2344	; 0x2344 <SendToUart0>
}
    3a46:	e2 96       	adiw	r28, 0x32	; 50
    3a48:	0f b6       	in	r0, 0x3f	; 63
    3a4a:	f8 94       	cli
    3a4c:	de bf       	out	0x3e, r29	; 62
    3a4e:	0f be       	out	0x3f, r0	; 63
    3a50:	cd bf       	out	0x3d, r28	; 61
    3a52:	cf 91       	pop	r28
    3a54:	df 91       	pop	r29
    3a56:	1f 91       	pop	r17
    3a58:	0f 91       	pop	r16
    3a5a:	ff 90       	pop	r15
    3a5c:	ef 90       	pop	r14
    3a5e:	df 90       	pop	r13
    3a60:	cf 90       	pop	r12
    3a62:	bf 90       	pop	r11
    3a64:	af 90       	pop	r10
    3a66:	9f 90       	pop	r9
    3a68:	08 95       	ret

00003a6a <main>:


//-------------------------------------------------------------------------------------------------------------------

int main(void)
{
    3a6a:	2f 92       	push	r2
    3a6c:	3f 92       	push	r3
    3a6e:	4f 92       	push	r4
    3a70:	5f 92       	push	r5
    3a72:	6f 92       	push	r6
    3a74:	7f 92       	push	r7
    3a76:	8f 92       	push	r8
    3a78:	9f 92       	push	r9
    3a7a:	af 92       	push	r10
    3a7c:	bf 92       	push	r11
    3a7e:	cf 92       	push	r12
    3a80:	df 92       	push	r13
    3a82:	ef 92       	push	r14
    3a84:	ff 92       	push	r15
    3a86:	0f 93       	push	r16
    3a88:	1f 93       	push	r17
    3a8a:	df 93       	push	r29
    3a8c:	cf 93       	push	r28
    3a8e:	cd b7       	in	r28, 0x3d	; 61
    3a90:	de b7       	in	r29, 0x3e	; 62
    3a92:	64 97       	sbiw	r28, 0x14	; 20
    3a94:	0f b6       	in	r0, 0x3f	; 63
    3a96:	f8 94       	cli
    3a98:	de bf       	out	0x3e, r29	; 62
    3a9a:	0f be       	out	0x3f, r0	; 63
    3a9c:	cd bf       	out	0x3d, r28	; 61
    3a9e:	8f ef       	ldi	r24, 0xFF	; 255
    3aa0:	9e e9       	ldi	r25, 0x9E	; 158
    3aa2:	a4 e2       	ldi	r26, 0x24	; 36
    3aa4:	81 50       	subi	r24, 0x01	; 1
    3aa6:	90 40       	sbci	r25, 0x00	; 0
    3aa8:	a0 40       	sbci	r26, 0x00	; 0
    3aaa:	e1 f7       	brne	.-8      	; 0x3aa4 <main+0x3a>
    3aac:	00 c0       	rjmp	.+0      	; 0x3aae <main+0x44>
    3aae:	00 00       	nop
	_delay_ms(1000);

	InitHardware();
    3ab0:	0e 94 3f 1c 	call	0x387e	; 0x387e <InitHardware>


	// Init LCD
	vHd44780Init();
    3ab4:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <vHd44780Init>
	vHd44780Mode(1,1,0);
    3ab8:	8e e0       	ldi	r24, 0x0E	; 14
    3aba:	0e 94 48 12 	call	0x2490	; 0x2490 <vHd44780Cmd>
	vHd44780Clear();
    3abe:	81 e0       	ldi	r24, 0x01	; 1
    3ac0:	0e 94 48 12 	call	0x2490	; 0x2490 <vHd44780Cmd>
	vHd44780PutString("StartS1 Hd44780 ");
    3ac4:	87 e2       	ldi	r24, 0x27	; 39
    3ac6:	92 e0       	ldi	r25, 0x02	; 2
    3ac8:	0e 94 8c 12 	call	0x2518	; 0x2518 <vHd44780PutString>
	//_delay_ms(1000);

	InitSPI(0,0,0,0);
    3acc:	80 e0       	ldi	r24, 0x00	; 0
    3ace:	60 e0       	ldi	r22, 0x00	; 0
    3ad0:	40 e0       	ldi	r20, 0x00	; 0
    3ad2:	20 e0       	ldi	r18, 0x00	; 0
    3ad4:	0e 94 5e 13 	call	0x26bc	; 0x26bc <InitSPI>
	vHd44780Clear();
    3ad8:	81 e0       	ldi	r24, 0x01	; 1
    3ada:	0e 94 48 12 	call	0x2490	; 0x2490 <vHd44780Cmd>
	vHd44780PutString("StartS2 InitSPI ");
    3ade:	88 e3       	ldi	r24, 0x38	; 56
    3ae0:	92 e0       	ldi	r25, 0x02	; 2
    3ae2:	0e 94 8c 12 	call	0x2518	; 0x2518 <vHd44780PutString>
	//_delay_ms(1000);

	vLs020Init(); 		// Init LS020 LCD
    3ae6:	0e 94 1a 14 	call	0x2834	; 0x2834 <vLs020Init>
	vHd44780Clear();
    3aea:	81 e0       	ldi	r24, 0x01	; 1
    3aec:	0e 94 48 12 	call	0x2490	; 0x2490 <vHd44780Cmd>
	vHd44780PutString("StartS21 Ls020In");
    3af0:	89 e4       	ldi	r24, 0x49	; 73
    3af2:	92 e0       	ldi	r25, 0x02	; 2
    3af4:	0e 94 8c 12 	call	0x2518	; 0x2518 <vHd44780PutString>
	//_delay_ms(1000);
	
	vLs020Mode8bit(0); 	// Set 8bit LCD host mode
    3af8:	80 e0       	ldi	r24, 0x00	; 0
    3afa:	0e 94 4b 14 	call	0x2896	; 0x2896 <vLs020Mode8bit>
	vHd44780Clear();
    3afe:	81 e0       	ldi	r24, 0x01	; 1
    3b00:	0e 94 48 12 	call	0x2490	; 0x2490 <vHd44780Cmd>
	vHd44780PutString("StartS22 Mode8b ");
    3b04:	8a e5       	ldi	r24, 0x5A	; 90
    3b06:	92 e0       	ldi	r25, 0x02	; 2
    3b08:	0e 94 8c 12 	call	0x2518	; 0x2518 <vHd44780PutString>
	//_delay_ms(1000);
	
	vLs020Rectangle(0,0,175,131,bgColor,8);
    3b0c:	80 e0       	ldi	r24, 0x00	; 0
    3b0e:	60 e0       	ldi	r22, 0x00	; 0
    3b10:	4f ea       	ldi	r20, 0xAF	; 175
    3b12:	23 e8       	ldi	r18, 0x83	; 131
    3b14:	0f ef       	ldi	r16, 0xFF	; 255
    3b16:	1f ef       	ldi	r17, 0xFF	; 255
    3b18:	38 e0       	ldi	r19, 0x08	; 8
    3b1a:	e3 2e       	mov	r14, r19
    3b1c:	0e 94 25 1a 	call	0x344a	; 0x344a <vLs020Rectangle>
	vHd44780Clear();
    3b20:	81 e0       	ldi	r24, 0x01	; 1
    3b22:	0e 94 48 12 	call	0x2490	; 0x2490 <vHd44780Cmd>
	vHd44780PutString("StartS23 Ls020Rl");
    3b26:	8b e6       	ldi	r24, 0x6B	; 107
    3b28:	92 e0       	ldi	r25, 0x02	; 2
    3b2a:	0e 94 8c 12 	call	0x2518	; 0x2518 <vHd44780PutString>
	//_delay_ms(1000);

	vLs020Rotation_2(30, 30, 14, 8, 0);
    3b2e:	8e e1       	ldi	r24, 0x1E	; 30
    3b30:	6e e1       	ldi	r22, 0x1E	; 30
    3b32:	4e e0       	ldi	r20, 0x0E	; 14
    3b34:	28 e0       	ldi	r18, 0x08	; 8
    3b36:	00 e0       	ldi	r16, 0x00	; 0
    3b38:	0e 94 87 16 	call	0x2d0e	; 0x2d0e <vLs020Rotation_2>
	vHd44780Clear();
    3b3c:	81 e0       	ldi	r24, 0x01	; 1
    3b3e:	0e 94 48 12 	call	0x2490	; 0x2490 <vHd44780Cmd>
	vHd44780PutString("StartS4 Ls020Rot");
    3b42:	8c e7       	ldi	r24, 0x7C	; 124
    3b44:	92 e0       	ldi	r25, 0x02	; 2
    3b46:	0e 94 8c 12 	call	0x2518	; 0x2518 <vHd44780PutString>
	//_delay_ms(1000);

	//vLs020PutChar8x14(14, 50, 'P', 0x91D4, 0xFFFF, 16, 0);
	//vLs020PutChar8x14(40, 50, 'A', 0x91D4, 0xFFFF, 16, 0);
	vLs020PutString8x14(40, 50, "test", 0x91D4, 0xFFFF, 16, 0);
    3b4a:	88 e2       	ldi	r24, 0x28	; 40
    3b4c:	62 e3       	ldi	r22, 0x32	; 50
    3b4e:	4d e8       	ldi	r20, 0x8D	; 141
    3b50:	52 e0       	ldi	r21, 0x02	; 2
    3b52:	24 ed       	ldi	r18, 0xD4	; 212
    3b54:	31 e9       	ldi	r19, 0x91	; 145
    3b56:	0f ef       	ldi	r16, 0xFF	; 255
    3b58:	1f ef       	ldi	r17, 0xFF	; 255
    3b5a:	90 e1       	ldi	r25, 0x10	; 16
    3b5c:	e9 2e       	mov	r14, r25
    3b5e:	cc 24       	eor	r12, r12
    3b60:	0e 94 47 19 	call	0x328e	; 0x328e <vLs020PutString8x14>
	vHd44780Clear();
    3b64:	81 e0       	ldi	r24, 0x01	; 1
    3b66:	0e 94 48 12 	call	0x2490	; 0x2490 <vHd44780Cmd>
	vHd44780PutString("StartS5 Chars   ");
    3b6a:	82 e9       	ldi	r24, 0x92	; 146
    3b6c:	92 e0       	ldi	r25, 0x02	; 2
    3b6e:	0e 94 8c 12 	call	0x2518	; 0x2518 <vHd44780PutString>
	//_delay_ms(1000);

	// Init LAN
	lan_init();
    3b72:	0e 94 97 0b 	call	0x172e	; 0x172e <lan_init>

	vHd44780Clear();
    3b76:	81 e0       	ldi	r24, 0x01	; 1
    3b78:	0e 94 48 12 	call	0x2490	; 0x2490 <vHd44780Cmd>
	vHd44780PutString("StartS6 lan_init");
    3b7c:	83 ea       	ldi	r24, 0xA3	; 163
    3b7e:	92 e0       	ldi	r25, 0x02	; 2
    3b80:	0e 94 8c 12 	call	0x2518	; 0x2518 <vHd44780PutString>
	transmitStringToUart(0,"StartS6 lan_init\n");
    3b84:	80 e0       	ldi	r24, 0x00	; 0
    3b86:	90 e0       	ldi	r25, 0x00	; 0
    3b88:	64 eb       	ldi	r22, 0xB4	; 180
    3b8a:	72 e0       	ldi	r23, 0x02	; 2
    3b8c:	0e 94 be 11 	call	0x237c	; 0x237c <transmitStringToUart>

	for (char i = 0; i<=100; i++)
    3b90:	90 e0       	ldi	r25, 0x00	; 0
	{
		vLs020StatusBar(10, 10, 112, 12, black, green, black, 16, 1, i-1, i);
    3b92:	0f 92       	push	r0
    3b94:	0f 92       	push	r0
    3b96:	89 2f       	mov	r24, r25
    3b98:	81 50       	subi	r24, 0x01	; 1
    3b9a:	ad b7       	in	r26, 0x3d	; 61
    3b9c:	be b7       	in	r27, 0x3e	; 62
    3b9e:	11 96       	adiw	r26, 0x01	; 1
    3ba0:	8c 93       	st	X, r24
    3ba2:	11 97       	sbiw	r26, 0x01	; 1
    3ba4:	12 96       	adiw	r26, 0x02	; 2
    3ba6:	9c 93       	st	X, r25
    3ba8:	8a e0       	ldi	r24, 0x0A	; 10
    3baa:	6a e0       	ldi	r22, 0x0A	; 10
    3bac:	40 e7       	ldi	r20, 0x70	; 112
    3bae:	2c e0       	ldi	r18, 0x0C	; 12
    3bb0:	00 e0       	ldi	r16, 0x00	; 0
    3bb2:	10 e0       	ldi	r17, 0x00	; 0
    3bb4:	b0 ee       	ldi	r27, 0xE0	; 224
    3bb6:	eb 2e       	mov	r14, r27
    3bb8:	b7 e0       	ldi	r27, 0x07	; 7
    3bba:	fb 2e       	mov	r15, r27
    3bbc:	cc 24       	eor	r12, r12
    3bbe:	dd 24       	eor	r13, r13
    3bc0:	a0 e1       	ldi	r26, 0x10	; 16
    3bc2:	aa 2e       	mov	r10, r26
    3bc4:	88 24       	eor	r8, r8
    3bc6:	83 94       	inc	r8
    3bc8:	9a 8b       	std	Y+18, r25	; 0x12
    3bca:	0e 94 63 1a 	call	0x34c6	; 0x34c6 <vLs020StatusBar>
    3bce:	ef e2       	ldi	r30, 0x2F	; 47
    3bd0:	f5 e7       	ldi	r31, 0x75	; 117
    3bd2:	31 97       	sbiw	r30, 0x01	; 1
    3bd4:	f1 f7       	brne	.-4      	; 0x3bd2 <main+0x168>
    3bd6:	00 c0       	rjmp	.+0      	; 0x3bd8 <main+0x16e>
    3bd8:	00 00       	nop

	vHd44780Clear();
	vHd44780PutString("StartS6 lan_init");
	transmitStringToUart(0,"StartS6 lan_init\n");

	for (char i = 0; i<=100; i++)
    3bda:	9a 89       	ldd	r25, Y+18	; 0x12
    3bdc:	9f 5f       	subi	r25, 0xFF	; 255
    3bde:	0f 90       	pop	r0
    3be0:	0f 90       	pop	r0
    3be2:	95 36       	cpi	r25, 0x65	; 101
    3be4:	b1 f6       	brne	.-84     	; 0x3b92 <main+0x128>
		if((time_offset) && (second_count >= display_next_update))
		{
			display_next_update = second_count+1;
			
			loctime = time_offset+second_count + 60UL*60*TIMEZONE;
			s = loctime % 60;
    3be6:	fc e3       	ldi	r31, 0x3C	; 60
    3be8:	6f 2e       	mov	r6, r31
    3bea:	71 2c       	mov	r7, r1
    3bec:	81 2c       	mov	r8, r1
    3bee:	91 2c       	mov	r9, r1
			m = (loctime/60)%60;
			h = (loctime/3600)%24;
    3bf0:	e0 e1       	ldi	r30, 0x10	; 16
    3bf2:	2e 2e       	mov	r2, r30
    3bf4:	ee e0       	ldi	r30, 0x0E	; 14
    3bf6:	3e 2e       	mov	r3, r30
    3bf8:	41 2c       	mov	r4, r1
    3bfa:	51 2c       	mov	r5, r1

			char buff[17] = "";
    3bfc:	ce 01       	movw	r24, r28
    3bfe:	05 96       	adiw	r24, 0x05	; 5
    3c00:	9c 8b       	std	Y+20, r25	; 0x14
    3c02:	8b 8b       	std	Y+19, r24	; 0x13
			sprintf(buff, "%02d:%02d:%02d", h,m,s );
    3c04:	5e 01       	movw	r10, r28
    3c06:	08 94       	sec
    3c08:	a1 1c       	adc	r10, r1
    3c0a:	b1 1c       	adc	r11, r1
		_delay_ms(10);
	}

	while(1)
	{
		lan_poll();
    3c0c:	0e 94 9c 0b 	call	0x1738	; 0x1738 <lan_poll>
		
		// Time to send NTP request?
		if(second_count >= ntp_next_update)
    3c10:	20 91 28 03 	lds	r18, 0x0328
    3c14:	30 91 29 03 	lds	r19, 0x0329
    3c18:	40 91 2a 03 	lds	r20, 0x032A
    3c1c:	50 91 2b 03 	lds	r21, 0x032B
    3c20:	80 91 2c 03 	lds	r24, 0x032C
    3c24:	90 91 2d 03 	lds	r25, 0x032D
    3c28:	a0 91 2e 03 	lds	r26, 0x032E
    3c2c:	b0 91 2f 03 	lds	r27, 0x032F
    3c30:	28 17       	cp	r18, r24
    3c32:	39 07       	cpc	r19, r25
    3c34:	4a 07       	cpc	r20, r26
    3c36:	5b 07       	cpc	r21, r27
    3c38:	38 f1       	brcs	.+78     	; 0x3c88 <main+0x21e>
		{
			if(!ntp_request(NTP_SERVER))
    3c3a:	62 e5       	ldi	r22, 0x52	; 82
    3c3c:	71 ec       	ldi	r23, 0xC1	; 193
    3c3e:	85 e7       	ldi	r24, 0x75	; 117
    3c40:	9a e5       	ldi	r25, 0x5A	; 90
    3c42:	0e 94 ab 0b 	call	0x1756	; 0x1756 <ntp_request>
    3c46:	88 23       	and	r24, r24
    3c48:	61 f4       	brne	.+24     	; 0x3c62 <main+0x1f8>
				ntp_next_update = second_count+2;
    3c4a:	80 91 28 03 	lds	r24, 0x0328
    3c4e:	90 91 29 03 	lds	r25, 0x0329
    3c52:	a0 91 2a 03 	lds	r26, 0x032A
    3c56:	b0 91 2b 03 	lds	r27, 0x032B
    3c5a:	02 96       	adiw	r24, 0x02	; 2
    3c5c:	a1 1d       	adc	r26, r1
    3c5e:	b1 1d       	adc	r27, r1
    3c60:	0b c0       	rjmp	.+22     	; 0x3c78 <main+0x20e>
			else
				ntp_next_update = second_count+60;
    3c62:	80 91 28 03 	lds	r24, 0x0328
    3c66:	90 91 29 03 	lds	r25, 0x0329
    3c6a:	a0 91 2a 03 	lds	r26, 0x032A
    3c6e:	b0 91 2b 03 	lds	r27, 0x032B
    3c72:	cc 96       	adiw	r24, 0x3c	; 60
    3c74:	a1 1d       	adc	r26, r1
    3c76:	b1 1d       	adc	r27, r1
    3c78:	80 93 2c 03 	sts	0x032C, r24
    3c7c:	90 93 2d 03 	sts	0x032D, r25
    3c80:	a0 93 2e 03 	sts	0x032E, r26
    3c84:	b0 93 2f 03 	sts	0x032F, r27
		}

		// Time to refresh display?
		if((time_offset) && (second_count >= display_next_update))
    3c88:	80 91 30 03 	lds	r24, 0x0330
    3c8c:	90 91 31 03 	lds	r25, 0x0331
    3c90:	a0 91 32 03 	lds	r26, 0x0332
    3c94:	b0 91 33 03 	lds	r27, 0x0333
    3c98:	00 97       	sbiw	r24, 0x00	; 0
    3c9a:	a1 05       	cpc	r26, r1
    3c9c:	b1 05       	cpc	r27, r1
    3c9e:	09 f4       	brne	.+2      	; 0x3ca2 <main+0x238>
    3ca0:	b5 cf       	rjmp	.-150    	; 0x3c0c <main+0x1a2>
    3ca2:	20 91 28 03 	lds	r18, 0x0328
    3ca6:	30 91 29 03 	lds	r19, 0x0329
    3caa:	40 91 2a 03 	lds	r20, 0x032A
    3cae:	50 91 2b 03 	lds	r21, 0x032B
    3cb2:	80 91 24 03 	lds	r24, 0x0324
    3cb6:	90 91 25 03 	lds	r25, 0x0325
    3cba:	a0 91 26 03 	lds	r26, 0x0326
    3cbe:	b0 91 27 03 	lds	r27, 0x0327
    3cc2:	28 17       	cp	r18, r24
    3cc4:	39 07       	cpc	r19, r25
    3cc6:	4a 07       	cpc	r20, r26
    3cc8:	5b 07       	cpc	r21, r27
    3cca:	08 f4       	brcc	.+2      	; 0x3cce <main+0x264>
    3ccc:	9f cf       	rjmp	.-194    	; 0x3c0c <main+0x1a2>
		{
			display_next_update = second_count+1;
    3cce:	80 91 28 03 	lds	r24, 0x0328
    3cd2:	90 91 29 03 	lds	r25, 0x0329
    3cd6:	a0 91 2a 03 	lds	r26, 0x032A
    3cda:	b0 91 2b 03 	lds	r27, 0x032B
    3cde:	01 96       	adiw	r24, 0x01	; 1
    3ce0:	a1 1d       	adc	r26, r1
    3ce2:	b1 1d       	adc	r27, r1
    3ce4:	80 93 24 03 	sts	0x0324, r24
    3ce8:	90 93 25 03 	sts	0x0325, r25
    3cec:	a0 93 26 03 	sts	0x0326, r26
    3cf0:	b0 93 27 03 	sts	0x0327, r27
			
			loctime = time_offset+second_count + 60UL*60*TIMEZONE;
    3cf4:	e0 90 30 03 	lds	r14, 0x0330
    3cf8:	f0 90 31 03 	lds	r15, 0x0331
    3cfc:	00 91 32 03 	lds	r16, 0x0332
    3d00:	10 91 33 03 	lds	r17, 0x0333
    3d04:	80 91 28 03 	lds	r24, 0x0328
    3d08:	90 91 29 03 	lds	r25, 0x0329
    3d0c:	a0 91 2a 03 	lds	r26, 0x032A
    3d10:	b0 91 2b 03 	lds	r27, 0x032B
    3d14:	e8 0e       	add	r14, r24
    3d16:	f9 1e       	adc	r15, r25
    3d18:	0a 1f       	adc	r16, r26
    3d1a:	1b 1f       	adc	r17, r27
    3d1c:	80 e2       	ldi	r24, 0x20	; 32
    3d1e:	9c e1       	ldi	r25, 0x1C	; 28
    3d20:	a0 e0       	ldi	r26, 0x00	; 0
    3d22:	b0 e0       	ldi	r27, 0x00	; 0
    3d24:	e8 0e       	add	r14, r24
    3d26:	f9 1e       	adc	r15, r25
    3d28:	0a 1f       	adc	r16, r26
    3d2a:	1b 1f       	adc	r17, r27
    3d2c:	e0 92 28 06 	sts	0x0628, r14
    3d30:	f0 92 29 06 	sts	0x0629, r15
    3d34:	00 93 2a 06 	sts	0x062A, r16
    3d38:	10 93 2b 06 	sts	0x062B, r17
			s = loctime % 60;
    3d3c:	c8 01       	movw	r24, r16
    3d3e:	b7 01       	movw	r22, r14
    3d40:	a4 01       	movw	r20, r8
    3d42:	93 01       	movw	r18, r6
    3d44:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    3d48:	c6 2e       	mov	r12, r22
    3d4a:	60 93 2e 06 	sts	0x062E, r22
			m = (loctime/60)%60;
    3d4e:	ca 01       	movw	r24, r20
    3d50:	b9 01       	movw	r22, r18
    3d52:	a4 01       	movw	r20, r8
    3d54:	93 01       	movw	r18, r6
    3d56:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    3d5a:	d6 2e       	mov	r13, r22
    3d5c:	60 93 95 06 	sts	0x0695, r22
			h = (loctime/3600)%24;
    3d60:	c8 01       	movw	r24, r16
    3d62:	b7 01       	movw	r22, r14
    3d64:	a2 01       	movw	r20, r4
    3d66:	91 01       	movw	r18, r2
    3d68:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    3d6c:	ca 01       	movw	r24, r20
    3d6e:	b9 01       	movw	r22, r18
    3d70:	28 e1       	ldi	r18, 0x18	; 24
    3d72:	30 e0       	ldi	r19, 0x00	; 0
    3d74:	40 e0       	ldi	r20, 0x00	; 0
    3d76:	50 e0       	ldi	r21, 0x00	; 0
    3d78:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__udivmodsi4>
    3d7c:	60 93 2f 06 	sts	0x062F, r22

			char buff[17] = "";
    3d80:	19 82       	std	Y+1, r1	; 0x01
    3d82:	1a 82       	std	Y+2, r1	; 0x02
    3d84:	1b 82       	std	Y+3, r1	; 0x03
    3d86:	1c 82       	std	Y+4, r1	; 0x04
    3d88:	ab 89       	ldd	r26, Y+19	; 0x13
    3d8a:	bc 89       	ldd	r27, Y+20	; 0x14
    3d8c:	ed e0       	ldi	r30, 0x0D	; 13
    3d8e:	1d 92       	st	X+, r1
    3d90:	ea 95       	dec	r30
    3d92:	e9 f7       	brne	.-6      	; 0x3d8e <main+0x324>
			sprintf(buff, "%02d:%02d:%02d", h,m,s );
    3d94:	8d b7       	in	r24, 0x3d	; 61
    3d96:	9e b7       	in	r25, 0x3e	; 62
    3d98:	0a 97       	sbiw	r24, 0x0a	; 10
    3d9a:	0f b6       	in	r0, 0x3f	; 63
    3d9c:	f8 94       	cli
    3d9e:	9e bf       	out	0x3e, r25	; 62
    3da0:	0f be       	out	0x3f, r0	; 63
    3da2:	8d bf       	out	0x3d, r24	; 61
    3da4:	ed b7       	in	r30, 0x3d	; 61
    3da6:	fe b7       	in	r31, 0x3e	; 62
    3da8:	31 96       	adiw	r30, 0x01	; 1
    3daa:	ad b7       	in	r26, 0x3d	; 61
    3dac:	be b7       	in	r27, 0x3e	; 62
    3dae:	12 96       	adiw	r26, 0x02	; 2
    3db0:	bc 92       	st	X, r11
    3db2:	ae 92       	st	-X, r10
    3db4:	11 97       	sbiw	r26, 0x01	; 1
    3db6:	86 ec       	ldi	r24, 0xC6	; 198
    3db8:	92 e0       	ldi	r25, 0x02	; 2
    3dba:	93 83       	std	Z+3, r25	; 0x03
    3dbc:	82 83       	std	Z+2, r24	; 0x02
    3dbe:	64 83       	std	Z+4, r22	; 0x04
    3dc0:	15 82       	std	Z+5, r1	; 0x05
    3dc2:	d6 82       	std	Z+6, r13	; 0x06
    3dc4:	17 82       	std	Z+7, r1	; 0x07
    3dc6:	c0 86       	std	Z+8, r12	; 0x08
    3dc8:	11 86       	std	Z+9, r1	; 0x09
    3dca:	0e 94 80 1f 	call	0x3f00	; 0x3f00 <sprintf>
			vLcdGotoXY(0,0);
    3dce:	ad b7       	in	r26, 0x3d	; 61
    3dd0:	be b7       	in	r27, 0x3e	; 62
    3dd2:	1a 96       	adiw	r26, 0x0a	; 10
    3dd4:	0f b6       	in	r0, 0x3f	; 63
    3dd6:	f8 94       	cli
    3dd8:	be bf       	out	0x3e, r27	; 62
    3dda:	0f be       	out	0x3f, r0	; 63
    3ddc:	ad bf       	out	0x3d, r26	; 61
    3dde:	80 e0       	ldi	r24, 0x00	; 0
    3de0:	60 e0       	ldi	r22, 0x00	; 0
    3de2:	0e 94 2e 13 	call	0x265c	; 0x265c <vLcdGotoXY>
			vHd44780PutString(buff);
    3de6:	c5 01       	movw	r24, r10
    3de8:	0e 94 8c 12 	call	0x2518	; 0x2518 <vHd44780PutString>
			vLs020PutString8x14(40, 50, buff, 0x91D4, 0xFFFF, 16, 0);
    3dec:	88 e2       	ldi	r24, 0x28	; 40
    3dee:	62 e3       	ldi	r22, 0x32	; 50
    3df0:	a5 01       	movw	r20, r10
    3df2:	24 ed       	ldi	r18, 0xD4	; 212
    3df4:	31 e9       	ldi	r19, 0x91	; 145
    3df6:	0f ef       	ldi	r16, 0xFF	; 255
    3df8:	1f ef       	ldi	r17, 0xFF	; 255
    3dfa:	70 e1       	ldi	r23, 0x10	; 16
    3dfc:	e7 2e       	mov	r14, r23
    3dfe:	cc 24       	eor	r12, r12
    3e00:	0e 94 47 19 	call	0x328e	; 0x328e <vLs020PutString8x14>
    3e04:	03 cf       	rjmp	.-506    	; 0x3c0c <main+0x1a2>

00003e06 <__udivmodqi4>:
    3e06:	99 1b       	sub	r25, r25
    3e08:	79 e0       	ldi	r23, 0x09	; 9
    3e0a:	04 c0       	rjmp	.+8      	; 0x3e14 <__udivmodqi4_ep>

00003e0c <__udivmodqi4_loop>:
    3e0c:	99 1f       	adc	r25, r25
    3e0e:	96 17       	cp	r25, r22
    3e10:	08 f0       	brcs	.+2      	; 0x3e14 <__udivmodqi4_ep>
    3e12:	96 1b       	sub	r25, r22

00003e14 <__udivmodqi4_ep>:
    3e14:	88 1f       	adc	r24, r24
    3e16:	7a 95       	dec	r23
    3e18:	c9 f7       	brne	.-14     	; 0x3e0c <__udivmodqi4_loop>
    3e1a:	80 95       	com	r24
    3e1c:	08 95       	ret

00003e1e <__udivmodhi4>:
    3e1e:	aa 1b       	sub	r26, r26
    3e20:	bb 1b       	sub	r27, r27
    3e22:	51 e1       	ldi	r21, 0x11	; 17
    3e24:	07 c0       	rjmp	.+14     	; 0x3e34 <__udivmodhi4_ep>

00003e26 <__udivmodhi4_loop>:
    3e26:	aa 1f       	adc	r26, r26
    3e28:	bb 1f       	adc	r27, r27
    3e2a:	a6 17       	cp	r26, r22
    3e2c:	b7 07       	cpc	r27, r23
    3e2e:	10 f0       	brcs	.+4      	; 0x3e34 <__udivmodhi4_ep>
    3e30:	a6 1b       	sub	r26, r22
    3e32:	b7 0b       	sbc	r27, r23

00003e34 <__udivmodhi4_ep>:
    3e34:	88 1f       	adc	r24, r24
    3e36:	99 1f       	adc	r25, r25
    3e38:	5a 95       	dec	r21
    3e3a:	a9 f7       	brne	.-22     	; 0x3e26 <__udivmodhi4_loop>
    3e3c:	80 95       	com	r24
    3e3e:	90 95       	com	r25
    3e40:	bc 01       	movw	r22, r24
    3e42:	cd 01       	movw	r24, r26
    3e44:	08 95       	ret

00003e46 <__divmodhi4>:
    3e46:	97 fb       	bst	r25, 7
    3e48:	09 2e       	mov	r0, r25
    3e4a:	07 26       	eor	r0, r23
    3e4c:	0a d0       	rcall	.+20     	; 0x3e62 <__divmodhi4_neg1>
    3e4e:	77 fd       	sbrc	r23, 7
    3e50:	04 d0       	rcall	.+8      	; 0x3e5a <__divmodhi4_neg2>
    3e52:	e5 df       	rcall	.-54     	; 0x3e1e <__udivmodhi4>
    3e54:	06 d0       	rcall	.+12     	; 0x3e62 <__divmodhi4_neg1>
    3e56:	00 20       	and	r0, r0
    3e58:	1a f4       	brpl	.+6      	; 0x3e60 <__divmodhi4_exit>

00003e5a <__divmodhi4_neg2>:
    3e5a:	70 95       	com	r23
    3e5c:	61 95       	neg	r22
    3e5e:	7f 4f       	sbci	r23, 0xFF	; 255

00003e60 <__divmodhi4_exit>:
    3e60:	08 95       	ret

00003e62 <__divmodhi4_neg1>:
    3e62:	f6 f7       	brtc	.-4      	; 0x3e60 <__divmodhi4_exit>
    3e64:	90 95       	com	r25
    3e66:	81 95       	neg	r24
    3e68:	9f 4f       	sbci	r25, 0xFF	; 255
    3e6a:	08 95       	ret

00003e6c <__udivmodsi4>:
    3e6c:	a1 e2       	ldi	r26, 0x21	; 33
    3e6e:	1a 2e       	mov	r1, r26
    3e70:	aa 1b       	sub	r26, r26
    3e72:	bb 1b       	sub	r27, r27
    3e74:	fd 01       	movw	r30, r26
    3e76:	0d c0       	rjmp	.+26     	; 0x3e92 <__udivmodsi4_ep>

00003e78 <__udivmodsi4_loop>:
    3e78:	aa 1f       	adc	r26, r26
    3e7a:	bb 1f       	adc	r27, r27
    3e7c:	ee 1f       	adc	r30, r30
    3e7e:	ff 1f       	adc	r31, r31
    3e80:	a2 17       	cp	r26, r18
    3e82:	b3 07       	cpc	r27, r19
    3e84:	e4 07       	cpc	r30, r20
    3e86:	f5 07       	cpc	r31, r21
    3e88:	20 f0       	brcs	.+8      	; 0x3e92 <__udivmodsi4_ep>
    3e8a:	a2 1b       	sub	r26, r18
    3e8c:	b3 0b       	sbc	r27, r19
    3e8e:	e4 0b       	sbc	r30, r20
    3e90:	f5 0b       	sbc	r31, r21

00003e92 <__udivmodsi4_ep>:
    3e92:	66 1f       	adc	r22, r22
    3e94:	77 1f       	adc	r23, r23
    3e96:	88 1f       	adc	r24, r24
    3e98:	99 1f       	adc	r25, r25
    3e9a:	1a 94       	dec	r1
    3e9c:	69 f7       	brne	.-38     	; 0x3e78 <__udivmodsi4_loop>
    3e9e:	60 95       	com	r22
    3ea0:	70 95       	com	r23
    3ea2:	80 95       	com	r24
    3ea4:	90 95       	com	r25
    3ea6:	9b 01       	movw	r18, r22
    3ea8:	ac 01       	movw	r20, r24
    3eaa:	bd 01       	movw	r22, r26
    3eac:	cf 01       	movw	r24, r30
    3eae:	08 95       	ret

00003eb0 <memset>:
    3eb0:	dc 01       	movw	r26, r24
    3eb2:	01 c0       	rjmp	.+2      	; 0x3eb6 <memset+0x6>
    3eb4:	6d 93       	st	X+, r22
    3eb6:	41 50       	subi	r20, 0x01	; 1
    3eb8:	50 40       	sbci	r21, 0x00	; 0
    3eba:	e0 f7       	brcc	.-8      	; 0x3eb4 <memset+0x4>
    3ebc:	08 95       	ret

00003ebe <itoa>:
    3ebe:	fb 01       	movw	r30, r22
    3ec0:	9f 01       	movw	r18, r30
    3ec2:	e8 94       	clt
    3ec4:	42 30       	cpi	r20, 0x02	; 2
    3ec6:	c4 f0       	brlt	.+48     	; 0x3ef8 <itoa+0x3a>
    3ec8:	45 32       	cpi	r20, 0x25	; 37
    3eca:	b4 f4       	brge	.+44     	; 0x3ef8 <itoa+0x3a>
    3ecc:	4a 30       	cpi	r20, 0x0A	; 10
    3ece:	29 f4       	brne	.+10     	; 0x3eda <itoa+0x1c>
    3ed0:	97 fb       	bst	r25, 7
    3ed2:	1e f4       	brtc	.+6      	; 0x3eda <itoa+0x1c>
    3ed4:	90 95       	com	r25
    3ed6:	81 95       	neg	r24
    3ed8:	9f 4f       	sbci	r25, 0xFF	; 255
    3eda:	64 2f       	mov	r22, r20
    3edc:	77 27       	eor	r23, r23
    3ede:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <__udivmodhi4>
    3ee2:	80 5d       	subi	r24, 0xD0	; 208
    3ee4:	8a 33       	cpi	r24, 0x3A	; 58
    3ee6:	0c f0       	brlt	.+2      	; 0x3eea <itoa+0x2c>
    3ee8:	89 5d       	subi	r24, 0xD9	; 217
    3eea:	81 93       	st	Z+, r24
    3eec:	cb 01       	movw	r24, r22
    3eee:	00 97       	sbiw	r24, 0x00	; 0
    3ef0:	a1 f7       	brne	.-24     	; 0x3eda <itoa+0x1c>
    3ef2:	16 f4       	brtc	.+4      	; 0x3ef8 <itoa+0x3a>
    3ef4:	5d e2       	ldi	r21, 0x2D	; 45
    3ef6:	51 93       	st	Z+, r21
    3ef8:	10 82       	st	Z, r1
    3efa:	c9 01       	movw	r24, r18
    3efc:	0c 94 d6 21 	jmp	0x43ac	; 0x43ac <strrev>

00003f00 <sprintf>:
    3f00:	0f 93       	push	r16
    3f02:	1f 93       	push	r17
    3f04:	df 93       	push	r29
    3f06:	cf 93       	push	r28
    3f08:	cd b7       	in	r28, 0x3d	; 61
    3f0a:	de b7       	in	r29, 0x3e	; 62
    3f0c:	2e 97       	sbiw	r28, 0x0e	; 14
    3f0e:	0f b6       	in	r0, 0x3f	; 63
    3f10:	f8 94       	cli
    3f12:	de bf       	out	0x3e, r29	; 62
    3f14:	0f be       	out	0x3f, r0	; 63
    3f16:	cd bf       	out	0x3d, r28	; 61
    3f18:	0e 89       	ldd	r16, Y+22	; 0x16
    3f1a:	1f 89       	ldd	r17, Y+23	; 0x17
    3f1c:	86 e0       	ldi	r24, 0x06	; 6
    3f1e:	8c 83       	std	Y+4, r24	; 0x04
    3f20:	1a 83       	std	Y+2, r17	; 0x02
    3f22:	09 83       	std	Y+1, r16	; 0x01
    3f24:	8f ef       	ldi	r24, 0xFF	; 255
    3f26:	9f e7       	ldi	r25, 0x7F	; 127
    3f28:	9e 83       	std	Y+6, r25	; 0x06
    3f2a:	8d 83       	std	Y+5, r24	; 0x05
    3f2c:	9e 01       	movw	r18, r28
    3f2e:	26 5e       	subi	r18, 0xE6	; 230
    3f30:	3f 4f       	sbci	r19, 0xFF	; 255
    3f32:	ce 01       	movw	r24, r28
    3f34:	01 96       	adiw	r24, 0x01	; 1
    3f36:	68 8d       	ldd	r22, Y+24	; 0x18
    3f38:	79 8d       	ldd	r23, Y+25	; 0x19
    3f3a:	a9 01       	movw	r20, r18
    3f3c:	0e 94 b0 1f 	call	0x3f60	; 0x3f60 <vfprintf>
    3f40:	ef 81       	ldd	r30, Y+7	; 0x07
    3f42:	f8 85       	ldd	r31, Y+8	; 0x08
    3f44:	e0 0f       	add	r30, r16
    3f46:	f1 1f       	adc	r31, r17
    3f48:	10 82       	st	Z, r1
    3f4a:	2e 96       	adiw	r28, 0x0e	; 14
    3f4c:	0f b6       	in	r0, 0x3f	; 63
    3f4e:	f8 94       	cli
    3f50:	de bf       	out	0x3e, r29	; 62
    3f52:	0f be       	out	0x3f, r0	; 63
    3f54:	cd bf       	out	0x3d, r28	; 61
    3f56:	cf 91       	pop	r28
    3f58:	df 91       	pop	r29
    3f5a:	1f 91       	pop	r17
    3f5c:	0f 91       	pop	r16
    3f5e:	08 95       	ret

00003f60 <vfprintf>:
    3f60:	2f 92       	push	r2
    3f62:	3f 92       	push	r3
    3f64:	4f 92       	push	r4
    3f66:	5f 92       	push	r5
    3f68:	6f 92       	push	r6
    3f6a:	7f 92       	push	r7
    3f6c:	8f 92       	push	r8
    3f6e:	9f 92       	push	r9
    3f70:	af 92       	push	r10
    3f72:	bf 92       	push	r11
    3f74:	cf 92       	push	r12
    3f76:	df 92       	push	r13
    3f78:	ef 92       	push	r14
    3f7a:	ff 92       	push	r15
    3f7c:	0f 93       	push	r16
    3f7e:	1f 93       	push	r17
    3f80:	df 93       	push	r29
    3f82:	cf 93       	push	r28
    3f84:	cd b7       	in	r28, 0x3d	; 61
    3f86:	de b7       	in	r29, 0x3e	; 62
    3f88:	2c 97       	sbiw	r28, 0x0c	; 12
    3f8a:	0f b6       	in	r0, 0x3f	; 63
    3f8c:	f8 94       	cli
    3f8e:	de bf       	out	0x3e, r29	; 62
    3f90:	0f be       	out	0x3f, r0	; 63
    3f92:	cd bf       	out	0x3d, r28	; 61
    3f94:	6c 01       	movw	r12, r24
    3f96:	1b 01       	movw	r2, r22
    3f98:	8a 01       	movw	r16, r20
    3f9a:	fc 01       	movw	r30, r24
    3f9c:	17 82       	std	Z+7, r1	; 0x07
    3f9e:	16 82       	std	Z+6, r1	; 0x06
    3fa0:	83 81       	ldd	r24, Z+3	; 0x03
    3fa2:	81 ff       	sbrs	r24, 1
    3fa4:	d1 c1       	rjmp	.+930    	; 0x4348 <vfprintf+0x3e8>
    3fa6:	2e 01       	movw	r4, r28
    3fa8:	08 94       	sec
    3faa:	41 1c       	adc	r4, r1
    3fac:	51 1c       	adc	r5, r1
    3fae:	f6 01       	movw	r30, r12
    3fb0:	93 81       	ldd	r25, Z+3	; 0x03
    3fb2:	f1 01       	movw	r30, r2
    3fb4:	93 fd       	sbrc	r25, 3
    3fb6:	85 91       	lpm	r24, Z+
    3fb8:	93 ff       	sbrs	r25, 3
    3fba:	81 91       	ld	r24, Z+
    3fbc:	1f 01       	movw	r2, r30
    3fbe:	88 23       	and	r24, r24
    3fc0:	09 f4       	brne	.+2      	; 0x3fc4 <vfprintf+0x64>
    3fc2:	be c1       	rjmp	.+892    	; 0x4340 <vfprintf+0x3e0>
    3fc4:	85 32       	cpi	r24, 0x25	; 37
    3fc6:	39 f4       	brne	.+14     	; 0x3fd6 <vfprintf+0x76>
    3fc8:	93 fd       	sbrc	r25, 3
    3fca:	85 91       	lpm	r24, Z+
    3fcc:	93 ff       	sbrs	r25, 3
    3fce:	81 91       	ld	r24, Z+
    3fd0:	1f 01       	movw	r2, r30
    3fd2:	85 32       	cpi	r24, 0x25	; 37
    3fd4:	29 f4       	brne	.+10     	; 0x3fe0 <vfprintf+0x80>
    3fd6:	90 e0       	ldi	r25, 0x00	; 0
    3fd8:	b6 01       	movw	r22, r12
    3fda:	0e 94 e6 21 	call	0x43cc	; 0x43cc <fputc>
    3fde:	e7 cf       	rjmp	.-50     	; 0x3fae <vfprintf+0x4e>
    3fe0:	ee 24       	eor	r14, r14
    3fe2:	ff 24       	eor	r15, r15
    3fe4:	20 e0       	ldi	r18, 0x00	; 0
    3fe6:	20 32       	cpi	r18, 0x20	; 32
    3fe8:	b0 f4       	brcc	.+44     	; 0x4016 <vfprintf+0xb6>
    3fea:	8b 32       	cpi	r24, 0x2B	; 43
    3fec:	69 f0       	breq	.+26     	; 0x4008 <vfprintf+0xa8>
    3fee:	8c 32       	cpi	r24, 0x2C	; 44
    3ff0:	28 f4       	brcc	.+10     	; 0x3ffc <vfprintf+0x9c>
    3ff2:	80 32       	cpi	r24, 0x20	; 32
    3ff4:	51 f0       	breq	.+20     	; 0x400a <vfprintf+0xaa>
    3ff6:	83 32       	cpi	r24, 0x23	; 35
    3ff8:	71 f4       	brne	.+28     	; 0x4016 <vfprintf+0xb6>
    3ffa:	0b c0       	rjmp	.+22     	; 0x4012 <vfprintf+0xb2>
    3ffc:	8d 32       	cpi	r24, 0x2D	; 45
    3ffe:	39 f0       	breq	.+14     	; 0x400e <vfprintf+0xae>
    4000:	80 33       	cpi	r24, 0x30	; 48
    4002:	49 f4       	brne	.+18     	; 0x4016 <vfprintf+0xb6>
    4004:	21 60       	ori	r18, 0x01	; 1
    4006:	2c c0       	rjmp	.+88     	; 0x4060 <vfprintf+0x100>
    4008:	22 60       	ori	r18, 0x02	; 2
    400a:	24 60       	ori	r18, 0x04	; 4
    400c:	29 c0       	rjmp	.+82     	; 0x4060 <vfprintf+0x100>
    400e:	28 60       	ori	r18, 0x08	; 8
    4010:	27 c0       	rjmp	.+78     	; 0x4060 <vfprintf+0x100>
    4012:	20 61       	ori	r18, 0x10	; 16
    4014:	25 c0       	rjmp	.+74     	; 0x4060 <vfprintf+0x100>
    4016:	27 fd       	sbrc	r18, 7
    4018:	2c c0       	rjmp	.+88     	; 0x4072 <vfprintf+0x112>
    401a:	38 2f       	mov	r19, r24
    401c:	30 53       	subi	r19, 0x30	; 48
    401e:	3a 30       	cpi	r19, 0x0A	; 10
    4020:	98 f4       	brcc	.+38     	; 0x4048 <vfprintf+0xe8>
    4022:	26 ff       	sbrs	r18, 6
    4024:	08 c0       	rjmp	.+16     	; 0x4036 <vfprintf+0xd6>
    4026:	8e 2d       	mov	r24, r14
    4028:	88 0f       	add	r24, r24
    402a:	e8 2e       	mov	r14, r24
    402c:	ee 0c       	add	r14, r14
    402e:	ee 0c       	add	r14, r14
    4030:	e8 0e       	add	r14, r24
    4032:	e3 0e       	add	r14, r19
    4034:	15 c0       	rjmp	.+42     	; 0x4060 <vfprintf+0x100>
    4036:	8f 2d       	mov	r24, r15
    4038:	88 0f       	add	r24, r24
    403a:	f8 2e       	mov	r15, r24
    403c:	ff 0c       	add	r15, r15
    403e:	ff 0c       	add	r15, r15
    4040:	f8 0e       	add	r15, r24
    4042:	f3 0e       	add	r15, r19
    4044:	20 62       	ori	r18, 0x20	; 32
    4046:	0c c0       	rjmp	.+24     	; 0x4060 <vfprintf+0x100>
    4048:	8e 32       	cpi	r24, 0x2E	; 46
    404a:	21 f4       	brne	.+8      	; 0x4054 <vfprintf+0xf4>
    404c:	26 fd       	sbrc	r18, 6
    404e:	78 c1       	rjmp	.+752    	; 0x4340 <vfprintf+0x3e0>
    4050:	20 64       	ori	r18, 0x40	; 64
    4052:	06 c0       	rjmp	.+12     	; 0x4060 <vfprintf+0x100>
    4054:	8c 36       	cpi	r24, 0x6C	; 108
    4056:	11 f4       	brne	.+4      	; 0x405c <vfprintf+0xfc>
    4058:	20 68       	ori	r18, 0x80	; 128
    405a:	02 c0       	rjmp	.+4      	; 0x4060 <vfprintf+0x100>
    405c:	88 36       	cpi	r24, 0x68	; 104
    405e:	49 f4       	brne	.+18     	; 0x4072 <vfprintf+0x112>
    4060:	f1 01       	movw	r30, r2
    4062:	93 fd       	sbrc	r25, 3
    4064:	85 91       	lpm	r24, Z+
    4066:	93 ff       	sbrs	r25, 3
    4068:	81 91       	ld	r24, Z+
    406a:	1f 01       	movw	r2, r30
    406c:	88 23       	and	r24, r24
    406e:	09 f0       	breq	.+2      	; 0x4072 <vfprintf+0x112>
    4070:	ba cf       	rjmp	.-140    	; 0x3fe6 <vfprintf+0x86>
    4072:	98 2f       	mov	r25, r24
    4074:	95 54       	subi	r25, 0x45	; 69
    4076:	93 30       	cpi	r25, 0x03	; 3
    4078:	18 f0       	brcs	.+6      	; 0x4080 <vfprintf+0x120>
    407a:	90 52       	subi	r25, 0x20	; 32
    407c:	93 30       	cpi	r25, 0x03	; 3
    407e:	28 f4       	brcc	.+10     	; 0x408a <vfprintf+0x12a>
    4080:	0c 5f       	subi	r16, 0xFC	; 252
    4082:	1f 4f       	sbci	r17, 0xFF	; 255
    4084:	ff e3       	ldi	r31, 0x3F	; 63
    4086:	f9 83       	std	Y+1, r31	; 0x01
    4088:	0d c0       	rjmp	.+26     	; 0x40a4 <vfprintf+0x144>
    408a:	83 36       	cpi	r24, 0x63	; 99
    408c:	31 f0       	breq	.+12     	; 0x409a <vfprintf+0x13a>
    408e:	83 37       	cpi	r24, 0x73	; 115
    4090:	71 f0       	breq	.+28     	; 0x40ae <vfprintf+0x14e>
    4092:	83 35       	cpi	r24, 0x53	; 83
    4094:	09 f0       	breq	.+2      	; 0x4098 <vfprintf+0x138>
    4096:	60 c0       	rjmp	.+192    	; 0x4158 <vfprintf+0x1f8>
    4098:	22 c0       	rjmp	.+68     	; 0x40de <vfprintf+0x17e>
    409a:	f8 01       	movw	r30, r16
    409c:	80 81       	ld	r24, Z
    409e:	89 83       	std	Y+1, r24	; 0x01
    40a0:	0e 5f       	subi	r16, 0xFE	; 254
    40a2:	1f 4f       	sbci	r17, 0xFF	; 255
    40a4:	42 01       	movw	r8, r4
    40a6:	71 e0       	ldi	r23, 0x01	; 1
    40a8:	a7 2e       	mov	r10, r23
    40aa:	b1 2c       	mov	r11, r1
    40ac:	16 c0       	rjmp	.+44     	; 0x40da <vfprintf+0x17a>
    40ae:	62 e0       	ldi	r22, 0x02	; 2
    40b0:	66 2e       	mov	r6, r22
    40b2:	71 2c       	mov	r7, r1
    40b4:	60 0e       	add	r6, r16
    40b6:	71 1e       	adc	r7, r17
    40b8:	f8 01       	movw	r30, r16
    40ba:	80 80       	ld	r8, Z
    40bc:	91 80       	ldd	r9, Z+1	; 0x01
    40be:	26 ff       	sbrs	r18, 6
    40c0:	03 c0       	rjmp	.+6      	; 0x40c8 <vfprintf+0x168>
    40c2:	6e 2d       	mov	r22, r14
    40c4:	70 e0       	ldi	r23, 0x00	; 0
    40c6:	02 c0       	rjmp	.+4      	; 0x40cc <vfprintf+0x16c>
    40c8:	6f ef       	ldi	r22, 0xFF	; 255
    40ca:	7f ef       	ldi	r23, 0xFF	; 255
    40cc:	c4 01       	movw	r24, r8
    40ce:	2c 87       	std	Y+12, r18	; 0x0c
    40d0:	0e 94 cb 21 	call	0x4396	; 0x4396 <strnlen>
    40d4:	5c 01       	movw	r10, r24
    40d6:	83 01       	movw	r16, r6
    40d8:	2c 85       	ldd	r18, Y+12	; 0x0c
    40da:	2f 77       	andi	r18, 0x7F	; 127
    40dc:	17 c0       	rjmp	.+46     	; 0x410c <vfprintf+0x1ac>
    40de:	52 e0       	ldi	r21, 0x02	; 2
    40e0:	65 2e       	mov	r6, r21
    40e2:	71 2c       	mov	r7, r1
    40e4:	60 0e       	add	r6, r16
    40e6:	71 1e       	adc	r7, r17
    40e8:	f8 01       	movw	r30, r16
    40ea:	80 80       	ld	r8, Z
    40ec:	91 80       	ldd	r9, Z+1	; 0x01
    40ee:	26 ff       	sbrs	r18, 6
    40f0:	03 c0       	rjmp	.+6      	; 0x40f8 <vfprintf+0x198>
    40f2:	6e 2d       	mov	r22, r14
    40f4:	70 e0       	ldi	r23, 0x00	; 0
    40f6:	02 c0       	rjmp	.+4      	; 0x40fc <vfprintf+0x19c>
    40f8:	6f ef       	ldi	r22, 0xFF	; 255
    40fa:	7f ef       	ldi	r23, 0xFF	; 255
    40fc:	c4 01       	movw	r24, r8
    40fe:	2c 87       	std	Y+12, r18	; 0x0c
    4100:	0e 94 c0 21 	call	0x4380	; 0x4380 <strnlen_P>
    4104:	5c 01       	movw	r10, r24
    4106:	2c 85       	ldd	r18, Y+12	; 0x0c
    4108:	20 68       	ori	r18, 0x80	; 128
    410a:	83 01       	movw	r16, r6
    410c:	23 fd       	sbrc	r18, 3
    410e:	20 c0       	rjmp	.+64     	; 0x4150 <vfprintf+0x1f0>
    4110:	08 c0       	rjmp	.+16     	; 0x4122 <vfprintf+0x1c2>
    4112:	80 e2       	ldi	r24, 0x20	; 32
    4114:	90 e0       	ldi	r25, 0x00	; 0
    4116:	b6 01       	movw	r22, r12
    4118:	2c 87       	std	Y+12, r18	; 0x0c
    411a:	0e 94 e6 21 	call	0x43cc	; 0x43cc <fputc>
    411e:	fa 94       	dec	r15
    4120:	2c 85       	ldd	r18, Y+12	; 0x0c
    4122:	8f 2d       	mov	r24, r15
    4124:	90 e0       	ldi	r25, 0x00	; 0
    4126:	a8 16       	cp	r10, r24
    4128:	b9 06       	cpc	r11, r25
    412a:	98 f3       	brcs	.-26     	; 0x4112 <vfprintf+0x1b2>
    412c:	11 c0       	rjmp	.+34     	; 0x4150 <vfprintf+0x1f0>
    412e:	f4 01       	movw	r30, r8
    4130:	27 fd       	sbrc	r18, 7
    4132:	85 91       	lpm	r24, Z+
    4134:	27 ff       	sbrs	r18, 7
    4136:	81 91       	ld	r24, Z+
    4138:	4f 01       	movw	r8, r30
    413a:	90 e0       	ldi	r25, 0x00	; 0
    413c:	b6 01       	movw	r22, r12
    413e:	2c 87       	std	Y+12, r18	; 0x0c
    4140:	0e 94 e6 21 	call	0x43cc	; 0x43cc <fputc>
    4144:	2c 85       	ldd	r18, Y+12	; 0x0c
    4146:	f1 10       	cpse	r15, r1
    4148:	fa 94       	dec	r15
    414a:	08 94       	sec
    414c:	a1 08       	sbc	r10, r1
    414e:	b1 08       	sbc	r11, r1
    4150:	a1 14       	cp	r10, r1
    4152:	b1 04       	cpc	r11, r1
    4154:	61 f7       	brne	.-40     	; 0x412e <vfprintf+0x1ce>
    4156:	f1 c0       	rjmp	.+482    	; 0x433a <vfprintf+0x3da>
    4158:	84 36       	cpi	r24, 0x64	; 100
    415a:	11 f0       	breq	.+4      	; 0x4160 <vfprintf+0x200>
    415c:	89 36       	cpi	r24, 0x69	; 105
    415e:	49 f5       	brne	.+82     	; 0x41b2 <vfprintf+0x252>
    4160:	27 ff       	sbrs	r18, 7
    4162:	08 c0       	rjmp	.+16     	; 0x4174 <vfprintf+0x214>
    4164:	f8 01       	movw	r30, r16
    4166:	60 81       	ld	r22, Z
    4168:	71 81       	ldd	r23, Z+1	; 0x01
    416a:	82 81       	ldd	r24, Z+2	; 0x02
    416c:	93 81       	ldd	r25, Z+3	; 0x03
    416e:	0c 5f       	subi	r16, 0xFC	; 252
    4170:	1f 4f       	sbci	r17, 0xFF	; 255
    4172:	09 c0       	rjmp	.+18     	; 0x4186 <vfprintf+0x226>
    4174:	f8 01       	movw	r30, r16
    4176:	60 81       	ld	r22, Z
    4178:	71 81       	ldd	r23, Z+1	; 0x01
    417a:	88 27       	eor	r24, r24
    417c:	77 fd       	sbrc	r23, 7
    417e:	80 95       	com	r24
    4180:	98 2f       	mov	r25, r24
    4182:	0e 5f       	subi	r16, 0xFE	; 254
    4184:	1f 4f       	sbci	r17, 0xFF	; 255
    4186:	4f e6       	ldi	r20, 0x6F	; 111
    4188:	b4 2e       	mov	r11, r20
    418a:	b2 22       	and	r11, r18
    418c:	97 ff       	sbrs	r25, 7
    418e:	09 c0       	rjmp	.+18     	; 0x41a2 <vfprintf+0x242>
    4190:	90 95       	com	r25
    4192:	80 95       	com	r24
    4194:	70 95       	com	r23
    4196:	61 95       	neg	r22
    4198:	7f 4f       	sbci	r23, 0xFF	; 255
    419a:	8f 4f       	sbci	r24, 0xFF	; 255
    419c:	9f 4f       	sbci	r25, 0xFF	; 255
    419e:	f0 e8       	ldi	r31, 0x80	; 128
    41a0:	bf 2a       	or	r11, r31
    41a2:	a2 01       	movw	r20, r4
    41a4:	2a e0       	ldi	r18, 0x0A	; 10
    41a6:	30 e0       	ldi	r19, 0x00	; 0
    41a8:	0e 94 12 22 	call	0x4424	; 0x4424 <__ultoa_invert>
    41ac:	78 2e       	mov	r7, r24
    41ae:	74 18       	sub	r7, r4
    41b0:	45 c0       	rjmp	.+138    	; 0x423c <vfprintf+0x2dc>
    41b2:	85 37       	cpi	r24, 0x75	; 117
    41b4:	31 f4       	brne	.+12     	; 0x41c2 <vfprintf+0x262>
    41b6:	3f ee       	ldi	r19, 0xEF	; 239
    41b8:	b3 2e       	mov	r11, r19
    41ba:	b2 22       	and	r11, r18
    41bc:	2a e0       	ldi	r18, 0x0A	; 10
    41be:	30 e0       	ldi	r19, 0x00	; 0
    41c0:	25 c0       	rjmp	.+74     	; 0x420c <vfprintf+0x2ac>
    41c2:	99 ef       	ldi	r25, 0xF9	; 249
    41c4:	b9 2e       	mov	r11, r25
    41c6:	b2 22       	and	r11, r18
    41c8:	8f 36       	cpi	r24, 0x6F	; 111
    41ca:	c1 f0       	breq	.+48     	; 0x41fc <vfprintf+0x29c>
    41cc:	80 37       	cpi	r24, 0x70	; 112
    41ce:	20 f4       	brcc	.+8      	; 0x41d8 <vfprintf+0x278>
    41d0:	88 35       	cpi	r24, 0x58	; 88
    41d2:	09 f0       	breq	.+2      	; 0x41d6 <vfprintf+0x276>
    41d4:	b5 c0       	rjmp	.+362    	; 0x4340 <vfprintf+0x3e0>
    41d6:	0d c0       	rjmp	.+26     	; 0x41f2 <vfprintf+0x292>
    41d8:	80 37       	cpi	r24, 0x70	; 112
    41da:	21 f0       	breq	.+8      	; 0x41e4 <vfprintf+0x284>
    41dc:	88 37       	cpi	r24, 0x78	; 120
    41de:	09 f0       	breq	.+2      	; 0x41e2 <vfprintf+0x282>
    41e0:	af c0       	rjmp	.+350    	; 0x4340 <vfprintf+0x3e0>
    41e2:	02 c0       	rjmp	.+4      	; 0x41e8 <vfprintf+0x288>
    41e4:	20 e1       	ldi	r18, 0x10	; 16
    41e6:	b2 2a       	or	r11, r18
    41e8:	b4 fe       	sbrs	r11, 4
    41ea:	0b c0       	rjmp	.+22     	; 0x4202 <vfprintf+0x2a2>
    41ec:	84 e0       	ldi	r24, 0x04	; 4
    41ee:	b8 2a       	or	r11, r24
    41f0:	08 c0       	rjmp	.+16     	; 0x4202 <vfprintf+0x2a2>
    41f2:	b4 fe       	sbrs	r11, 4
    41f4:	09 c0       	rjmp	.+18     	; 0x4208 <vfprintf+0x2a8>
    41f6:	e6 e0       	ldi	r30, 0x06	; 6
    41f8:	be 2a       	or	r11, r30
    41fa:	06 c0       	rjmp	.+12     	; 0x4208 <vfprintf+0x2a8>
    41fc:	28 e0       	ldi	r18, 0x08	; 8
    41fe:	30 e0       	ldi	r19, 0x00	; 0
    4200:	05 c0       	rjmp	.+10     	; 0x420c <vfprintf+0x2ac>
    4202:	20 e1       	ldi	r18, 0x10	; 16
    4204:	30 e0       	ldi	r19, 0x00	; 0
    4206:	02 c0       	rjmp	.+4      	; 0x420c <vfprintf+0x2ac>
    4208:	20 e1       	ldi	r18, 0x10	; 16
    420a:	32 e0       	ldi	r19, 0x02	; 2
    420c:	b7 fe       	sbrs	r11, 7
    420e:	08 c0       	rjmp	.+16     	; 0x4220 <vfprintf+0x2c0>
    4210:	f8 01       	movw	r30, r16
    4212:	60 81       	ld	r22, Z
    4214:	71 81       	ldd	r23, Z+1	; 0x01
    4216:	82 81       	ldd	r24, Z+2	; 0x02
    4218:	93 81       	ldd	r25, Z+3	; 0x03
    421a:	0c 5f       	subi	r16, 0xFC	; 252
    421c:	1f 4f       	sbci	r17, 0xFF	; 255
    421e:	07 c0       	rjmp	.+14     	; 0x422e <vfprintf+0x2ce>
    4220:	f8 01       	movw	r30, r16
    4222:	60 81       	ld	r22, Z
    4224:	71 81       	ldd	r23, Z+1	; 0x01
    4226:	80 e0       	ldi	r24, 0x00	; 0
    4228:	90 e0       	ldi	r25, 0x00	; 0
    422a:	0e 5f       	subi	r16, 0xFE	; 254
    422c:	1f 4f       	sbci	r17, 0xFF	; 255
    422e:	a2 01       	movw	r20, r4
    4230:	0e 94 12 22 	call	0x4424	; 0x4424 <__ultoa_invert>
    4234:	78 2e       	mov	r7, r24
    4236:	74 18       	sub	r7, r4
    4238:	ff e7       	ldi	r31, 0x7F	; 127
    423a:	bf 22       	and	r11, r31
    423c:	b6 fe       	sbrs	r11, 6
    423e:	0b c0       	rjmp	.+22     	; 0x4256 <vfprintf+0x2f6>
    4240:	2e ef       	ldi	r18, 0xFE	; 254
    4242:	b2 22       	and	r11, r18
    4244:	7e 14       	cp	r7, r14
    4246:	38 f4       	brcc	.+14     	; 0x4256 <vfprintf+0x2f6>
    4248:	b4 fe       	sbrs	r11, 4
    424a:	07 c0       	rjmp	.+14     	; 0x425a <vfprintf+0x2fa>
    424c:	b2 fc       	sbrc	r11, 2
    424e:	05 c0       	rjmp	.+10     	; 0x425a <vfprintf+0x2fa>
    4250:	8f ee       	ldi	r24, 0xEF	; 239
    4252:	b8 22       	and	r11, r24
    4254:	02 c0       	rjmp	.+4      	; 0x425a <vfprintf+0x2fa>
    4256:	a7 2c       	mov	r10, r7
    4258:	01 c0       	rjmp	.+2      	; 0x425c <vfprintf+0x2fc>
    425a:	ae 2c       	mov	r10, r14
    425c:	8b 2d       	mov	r24, r11
    425e:	90 e0       	ldi	r25, 0x00	; 0
    4260:	b4 fe       	sbrs	r11, 4
    4262:	0d c0       	rjmp	.+26     	; 0x427e <vfprintf+0x31e>
    4264:	fe 01       	movw	r30, r28
    4266:	e7 0d       	add	r30, r7
    4268:	f1 1d       	adc	r31, r1
    426a:	20 81       	ld	r18, Z
    426c:	20 33       	cpi	r18, 0x30	; 48
    426e:	19 f4       	brne	.+6      	; 0x4276 <vfprintf+0x316>
    4270:	e9 ee       	ldi	r30, 0xE9	; 233
    4272:	be 22       	and	r11, r30
    4274:	09 c0       	rjmp	.+18     	; 0x4288 <vfprintf+0x328>
    4276:	a3 94       	inc	r10
    4278:	b2 fe       	sbrs	r11, 2
    427a:	06 c0       	rjmp	.+12     	; 0x4288 <vfprintf+0x328>
    427c:	04 c0       	rjmp	.+8      	; 0x4286 <vfprintf+0x326>
    427e:	86 78       	andi	r24, 0x86	; 134
    4280:	90 70       	andi	r25, 0x00	; 0
    4282:	00 97       	sbiw	r24, 0x00	; 0
    4284:	09 f0       	breq	.+2      	; 0x4288 <vfprintf+0x328>
    4286:	a3 94       	inc	r10
    4288:	8b 2c       	mov	r8, r11
    428a:	99 24       	eor	r9, r9
    428c:	b3 fc       	sbrc	r11, 3
    428e:	14 c0       	rjmp	.+40     	; 0x42b8 <vfprintf+0x358>
    4290:	b0 fe       	sbrs	r11, 0
    4292:	0f c0       	rjmp	.+30     	; 0x42b2 <vfprintf+0x352>
    4294:	af 14       	cp	r10, r15
    4296:	28 f4       	brcc	.+10     	; 0x42a2 <vfprintf+0x342>
    4298:	e7 2c       	mov	r14, r7
    429a:	ef 0c       	add	r14, r15
    429c:	ea 18       	sub	r14, r10
    429e:	af 2c       	mov	r10, r15
    42a0:	08 c0       	rjmp	.+16     	; 0x42b2 <vfprintf+0x352>
    42a2:	e7 2c       	mov	r14, r7
    42a4:	06 c0       	rjmp	.+12     	; 0x42b2 <vfprintf+0x352>
    42a6:	80 e2       	ldi	r24, 0x20	; 32
    42a8:	90 e0       	ldi	r25, 0x00	; 0
    42aa:	b6 01       	movw	r22, r12
    42ac:	0e 94 e6 21 	call	0x43cc	; 0x43cc <fputc>
    42b0:	a3 94       	inc	r10
    42b2:	af 14       	cp	r10, r15
    42b4:	c0 f3       	brcs	.-16     	; 0x42a6 <vfprintf+0x346>
    42b6:	04 c0       	rjmp	.+8      	; 0x42c0 <vfprintf+0x360>
    42b8:	af 14       	cp	r10, r15
    42ba:	10 f4       	brcc	.+4      	; 0x42c0 <vfprintf+0x360>
    42bc:	fa 18       	sub	r15, r10
    42be:	01 c0       	rjmp	.+2      	; 0x42c2 <vfprintf+0x362>
    42c0:	ff 24       	eor	r15, r15
    42c2:	84 fe       	sbrs	r8, 4
    42c4:	0f c0       	rjmp	.+30     	; 0x42e4 <vfprintf+0x384>
    42c6:	80 e3       	ldi	r24, 0x30	; 48
    42c8:	90 e0       	ldi	r25, 0x00	; 0
    42ca:	b6 01       	movw	r22, r12
    42cc:	0e 94 e6 21 	call	0x43cc	; 0x43cc <fputc>
    42d0:	82 fe       	sbrs	r8, 2
    42d2:	1f c0       	rjmp	.+62     	; 0x4312 <vfprintf+0x3b2>
    42d4:	81 fe       	sbrs	r8, 1
    42d6:	03 c0       	rjmp	.+6      	; 0x42de <vfprintf+0x37e>
    42d8:	88 e5       	ldi	r24, 0x58	; 88
    42da:	90 e0       	ldi	r25, 0x00	; 0
    42dc:	10 c0       	rjmp	.+32     	; 0x42fe <vfprintf+0x39e>
    42de:	88 e7       	ldi	r24, 0x78	; 120
    42e0:	90 e0       	ldi	r25, 0x00	; 0
    42e2:	0d c0       	rjmp	.+26     	; 0x42fe <vfprintf+0x39e>
    42e4:	c4 01       	movw	r24, r8
    42e6:	86 78       	andi	r24, 0x86	; 134
    42e8:	90 70       	andi	r25, 0x00	; 0
    42ea:	00 97       	sbiw	r24, 0x00	; 0
    42ec:	91 f0       	breq	.+36     	; 0x4312 <vfprintf+0x3b2>
    42ee:	81 fc       	sbrc	r8, 1
    42f0:	02 c0       	rjmp	.+4      	; 0x42f6 <vfprintf+0x396>
    42f2:	80 e2       	ldi	r24, 0x20	; 32
    42f4:	01 c0       	rjmp	.+2      	; 0x42f8 <vfprintf+0x398>
    42f6:	8b e2       	ldi	r24, 0x2B	; 43
    42f8:	b7 fc       	sbrc	r11, 7
    42fa:	8d e2       	ldi	r24, 0x2D	; 45
    42fc:	90 e0       	ldi	r25, 0x00	; 0
    42fe:	b6 01       	movw	r22, r12
    4300:	0e 94 e6 21 	call	0x43cc	; 0x43cc <fputc>
    4304:	06 c0       	rjmp	.+12     	; 0x4312 <vfprintf+0x3b2>
    4306:	80 e3       	ldi	r24, 0x30	; 48
    4308:	90 e0       	ldi	r25, 0x00	; 0
    430a:	b6 01       	movw	r22, r12
    430c:	0e 94 e6 21 	call	0x43cc	; 0x43cc <fputc>
    4310:	ea 94       	dec	r14
    4312:	7e 14       	cp	r7, r14
    4314:	c0 f3       	brcs	.-16     	; 0x4306 <vfprintf+0x3a6>
    4316:	7a 94       	dec	r7
    4318:	f2 01       	movw	r30, r4
    431a:	e7 0d       	add	r30, r7
    431c:	f1 1d       	adc	r31, r1
    431e:	80 81       	ld	r24, Z
    4320:	90 e0       	ldi	r25, 0x00	; 0
    4322:	b6 01       	movw	r22, r12
    4324:	0e 94 e6 21 	call	0x43cc	; 0x43cc <fputc>
    4328:	77 20       	and	r7, r7
    432a:	a9 f7       	brne	.-22     	; 0x4316 <vfprintf+0x3b6>
    432c:	06 c0       	rjmp	.+12     	; 0x433a <vfprintf+0x3da>
    432e:	80 e2       	ldi	r24, 0x20	; 32
    4330:	90 e0       	ldi	r25, 0x00	; 0
    4332:	b6 01       	movw	r22, r12
    4334:	0e 94 e6 21 	call	0x43cc	; 0x43cc <fputc>
    4338:	fa 94       	dec	r15
    433a:	ff 20       	and	r15, r15
    433c:	c1 f7       	brne	.-16     	; 0x432e <vfprintf+0x3ce>
    433e:	37 ce       	rjmp	.-914    	; 0x3fae <vfprintf+0x4e>
    4340:	f6 01       	movw	r30, r12
    4342:	26 81       	ldd	r18, Z+6	; 0x06
    4344:	37 81       	ldd	r19, Z+7	; 0x07
    4346:	02 c0       	rjmp	.+4      	; 0x434c <vfprintf+0x3ec>
    4348:	2f ef       	ldi	r18, 0xFF	; 255
    434a:	3f ef       	ldi	r19, 0xFF	; 255
    434c:	c9 01       	movw	r24, r18
    434e:	2c 96       	adiw	r28, 0x0c	; 12
    4350:	0f b6       	in	r0, 0x3f	; 63
    4352:	f8 94       	cli
    4354:	de bf       	out	0x3e, r29	; 62
    4356:	0f be       	out	0x3f, r0	; 63
    4358:	cd bf       	out	0x3d, r28	; 61
    435a:	cf 91       	pop	r28
    435c:	df 91       	pop	r29
    435e:	1f 91       	pop	r17
    4360:	0f 91       	pop	r16
    4362:	ff 90       	pop	r15
    4364:	ef 90       	pop	r14
    4366:	df 90       	pop	r13
    4368:	cf 90       	pop	r12
    436a:	bf 90       	pop	r11
    436c:	af 90       	pop	r10
    436e:	9f 90       	pop	r9
    4370:	8f 90       	pop	r8
    4372:	7f 90       	pop	r7
    4374:	6f 90       	pop	r6
    4376:	5f 90       	pop	r5
    4378:	4f 90       	pop	r4
    437a:	3f 90       	pop	r3
    437c:	2f 90       	pop	r2
    437e:	08 95       	ret

00004380 <strnlen_P>:
    4380:	fc 01       	movw	r30, r24
    4382:	05 90       	lpm	r0, Z+
    4384:	61 50       	subi	r22, 0x01	; 1
    4386:	70 40       	sbci	r23, 0x00	; 0
    4388:	01 10       	cpse	r0, r1
    438a:	d8 f7       	brcc	.-10     	; 0x4382 <strnlen_P+0x2>
    438c:	80 95       	com	r24
    438e:	90 95       	com	r25
    4390:	8e 0f       	add	r24, r30
    4392:	9f 1f       	adc	r25, r31
    4394:	08 95       	ret

00004396 <strnlen>:
    4396:	fc 01       	movw	r30, r24
    4398:	61 50       	subi	r22, 0x01	; 1
    439a:	70 40       	sbci	r23, 0x00	; 0
    439c:	01 90       	ld	r0, Z+
    439e:	01 10       	cpse	r0, r1
    43a0:	d8 f7       	brcc	.-10     	; 0x4398 <strnlen+0x2>
    43a2:	80 95       	com	r24
    43a4:	90 95       	com	r25
    43a6:	8e 0f       	add	r24, r30
    43a8:	9f 1f       	adc	r25, r31
    43aa:	08 95       	ret

000043ac <strrev>:
    43ac:	dc 01       	movw	r26, r24
    43ae:	fc 01       	movw	r30, r24
    43b0:	67 2f       	mov	r22, r23
    43b2:	71 91       	ld	r23, Z+
    43b4:	77 23       	and	r23, r23
    43b6:	e1 f7       	brne	.-8      	; 0x43b0 <strrev+0x4>
    43b8:	32 97       	sbiw	r30, 0x02	; 2
    43ba:	04 c0       	rjmp	.+8      	; 0x43c4 <strrev+0x18>
    43bc:	7c 91       	ld	r23, X
    43be:	6d 93       	st	X+, r22
    43c0:	70 83       	st	Z, r23
    43c2:	62 91       	ld	r22, -Z
    43c4:	ae 17       	cp	r26, r30
    43c6:	bf 07       	cpc	r27, r31
    43c8:	c8 f3       	brcs	.-14     	; 0x43bc <strrev+0x10>
    43ca:	08 95       	ret

000043cc <fputc>:
    43cc:	0f 93       	push	r16
    43ce:	1f 93       	push	r17
    43d0:	cf 93       	push	r28
    43d2:	df 93       	push	r29
    43d4:	8c 01       	movw	r16, r24
    43d6:	eb 01       	movw	r28, r22
    43d8:	8b 81       	ldd	r24, Y+3	; 0x03
    43da:	81 ff       	sbrs	r24, 1
    43dc:	1b c0       	rjmp	.+54     	; 0x4414 <fputc+0x48>
    43de:	82 ff       	sbrs	r24, 2
    43e0:	0d c0       	rjmp	.+26     	; 0x43fc <fputc+0x30>
    43e2:	2e 81       	ldd	r18, Y+6	; 0x06
    43e4:	3f 81       	ldd	r19, Y+7	; 0x07
    43e6:	8c 81       	ldd	r24, Y+4	; 0x04
    43e8:	9d 81       	ldd	r25, Y+5	; 0x05
    43ea:	28 17       	cp	r18, r24
    43ec:	39 07       	cpc	r19, r25
    43ee:	64 f4       	brge	.+24     	; 0x4408 <fputc+0x3c>
    43f0:	e8 81       	ld	r30, Y
    43f2:	f9 81       	ldd	r31, Y+1	; 0x01
    43f4:	01 93       	st	Z+, r16
    43f6:	f9 83       	std	Y+1, r31	; 0x01
    43f8:	e8 83       	st	Y, r30
    43fa:	06 c0       	rjmp	.+12     	; 0x4408 <fputc+0x3c>
    43fc:	e8 85       	ldd	r30, Y+8	; 0x08
    43fe:	f9 85       	ldd	r31, Y+9	; 0x09
    4400:	80 2f       	mov	r24, r16
    4402:	19 95       	eicall
    4404:	00 97       	sbiw	r24, 0x00	; 0
    4406:	31 f4       	brne	.+12     	; 0x4414 <fputc+0x48>
    4408:	8e 81       	ldd	r24, Y+6	; 0x06
    440a:	9f 81       	ldd	r25, Y+7	; 0x07
    440c:	01 96       	adiw	r24, 0x01	; 1
    440e:	9f 83       	std	Y+7, r25	; 0x07
    4410:	8e 83       	std	Y+6, r24	; 0x06
    4412:	02 c0       	rjmp	.+4      	; 0x4418 <fputc+0x4c>
    4414:	0f ef       	ldi	r16, 0xFF	; 255
    4416:	1f ef       	ldi	r17, 0xFF	; 255
    4418:	c8 01       	movw	r24, r16
    441a:	df 91       	pop	r29
    441c:	cf 91       	pop	r28
    441e:	1f 91       	pop	r17
    4420:	0f 91       	pop	r16
    4422:	08 95       	ret

00004424 <__ultoa_invert>:
    4424:	fa 01       	movw	r30, r20
    4426:	aa 27       	eor	r26, r26
    4428:	28 30       	cpi	r18, 0x08	; 8
    442a:	51 f1       	breq	.+84     	; 0x4480 <__ultoa_invert+0x5c>
    442c:	20 31       	cpi	r18, 0x10	; 16
    442e:	81 f1       	breq	.+96     	; 0x4490 <__ultoa_invert+0x6c>
    4430:	e8 94       	clt
    4432:	6f 93       	push	r22
    4434:	6e 7f       	andi	r22, 0xFE	; 254
    4436:	6e 5f       	subi	r22, 0xFE	; 254
    4438:	7f 4f       	sbci	r23, 0xFF	; 255
    443a:	8f 4f       	sbci	r24, 0xFF	; 255
    443c:	9f 4f       	sbci	r25, 0xFF	; 255
    443e:	af 4f       	sbci	r26, 0xFF	; 255
    4440:	b1 e0       	ldi	r27, 0x01	; 1
    4442:	3e d0       	rcall	.+124    	; 0x44c0 <__ultoa_invert+0x9c>
    4444:	b4 e0       	ldi	r27, 0x04	; 4
    4446:	3c d0       	rcall	.+120    	; 0x44c0 <__ultoa_invert+0x9c>
    4448:	67 0f       	add	r22, r23
    444a:	78 1f       	adc	r23, r24
    444c:	89 1f       	adc	r24, r25
    444e:	9a 1f       	adc	r25, r26
    4450:	a1 1d       	adc	r26, r1
    4452:	68 0f       	add	r22, r24
    4454:	79 1f       	adc	r23, r25
    4456:	8a 1f       	adc	r24, r26
    4458:	91 1d       	adc	r25, r1
    445a:	a1 1d       	adc	r26, r1
    445c:	6a 0f       	add	r22, r26
    445e:	71 1d       	adc	r23, r1
    4460:	81 1d       	adc	r24, r1
    4462:	91 1d       	adc	r25, r1
    4464:	a1 1d       	adc	r26, r1
    4466:	20 d0       	rcall	.+64     	; 0x44a8 <__ultoa_invert+0x84>
    4468:	09 f4       	brne	.+2      	; 0x446c <__ultoa_invert+0x48>
    446a:	68 94       	set
    446c:	3f 91       	pop	r19
    446e:	2a e0       	ldi	r18, 0x0A	; 10
    4470:	26 9f       	mul	r18, r22
    4472:	11 24       	eor	r1, r1
    4474:	30 19       	sub	r19, r0
    4476:	30 5d       	subi	r19, 0xD0	; 208
    4478:	31 93       	st	Z+, r19
    447a:	de f6       	brtc	.-74     	; 0x4432 <__ultoa_invert+0xe>
    447c:	cf 01       	movw	r24, r30
    447e:	08 95       	ret
    4480:	46 2f       	mov	r20, r22
    4482:	47 70       	andi	r20, 0x07	; 7
    4484:	40 5d       	subi	r20, 0xD0	; 208
    4486:	41 93       	st	Z+, r20
    4488:	b3 e0       	ldi	r27, 0x03	; 3
    448a:	0f d0       	rcall	.+30     	; 0x44aa <__ultoa_invert+0x86>
    448c:	c9 f7       	brne	.-14     	; 0x4480 <__ultoa_invert+0x5c>
    448e:	f6 cf       	rjmp	.-20     	; 0x447c <__ultoa_invert+0x58>
    4490:	46 2f       	mov	r20, r22
    4492:	4f 70       	andi	r20, 0x0F	; 15
    4494:	40 5d       	subi	r20, 0xD0	; 208
    4496:	4a 33       	cpi	r20, 0x3A	; 58
    4498:	18 f0       	brcs	.+6      	; 0x44a0 <__ultoa_invert+0x7c>
    449a:	49 5d       	subi	r20, 0xD9	; 217
    449c:	31 fd       	sbrc	r19, 1
    449e:	40 52       	subi	r20, 0x20	; 32
    44a0:	41 93       	st	Z+, r20
    44a2:	02 d0       	rcall	.+4      	; 0x44a8 <__ultoa_invert+0x84>
    44a4:	a9 f7       	brne	.-22     	; 0x4490 <__ultoa_invert+0x6c>
    44a6:	ea cf       	rjmp	.-44     	; 0x447c <__ultoa_invert+0x58>
    44a8:	b4 e0       	ldi	r27, 0x04	; 4
    44aa:	a6 95       	lsr	r26
    44ac:	97 95       	ror	r25
    44ae:	87 95       	ror	r24
    44b0:	77 95       	ror	r23
    44b2:	67 95       	ror	r22
    44b4:	ba 95       	dec	r27
    44b6:	c9 f7       	brne	.-14     	; 0x44aa <__ultoa_invert+0x86>
    44b8:	00 97       	sbiw	r24, 0x00	; 0
    44ba:	61 05       	cpc	r22, r1
    44bc:	71 05       	cpc	r23, r1
    44be:	08 95       	ret
    44c0:	9b 01       	movw	r18, r22
    44c2:	ac 01       	movw	r20, r24
    44c4:	0a 2e       	mov	r0, r26
    44c6:	06 94       	lsr	r0
    44c8:	57 95       	ror	r21
    44ca:	47 95       	ror	r20
    44cc:	37 95       	ror	r19
    44ce:	27 95       	ror	r18
    44d0:	ba 95       	dec	r27
    44d2:	c9 f7       	brne	.-14     	; 0x44c6 <__ultoa_invert+0xa2>
    44d4:	62 0f       	add	r22, r18
    44d6:	73 1f       	adc	r23, r19
    44d8:	84 1f       	adc	r24, r20
    44da:	95 1f       	adc	r25, r21
    44dc:	a0 1d       	adc	r26, r0
    44de:	08 95       	ret

000044e0 <_exit>:
    44e0:	ff cf       	rjmp	.-2      	; 0x44e0 <_exit>
